{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":"Opulse <p>     Opulse is a dynamic operator generation system designed to create and manage mathematical operators, with 'pulse' reflecting its dynamic and impactful nature in the creation process!      Explore the docs \u00bb </p> Table of Contents <ol> <li> Getting Started <ul> <li>Installation</li> </ul> </li> <li>Usage</li> </ol>"},{"location":"#getting-started","title":"Getting Started","text":""},{"location":"#installation","title":"Installation","text":"<ol> <li>Clone the repository and set up your environment:</li> </ol> <pre><code>git clone https://github.com/opulse-exp/op_plus.git\nconda create --name op_plus python=3.10\ncd op_plus\npip install -r requirement.txt\n</code></pre> <ol> <li>Download the required data from Hugging Face: </li> </ol> <pre><code>https://huggingface.co/datasets/mkj69/op_plus\n</code></pre> <ol> <li>Extract the downloaded data. This directory contains the pre-compiled .so files for 100,000 operator calculation functions and counting functions, compiled using Cython. Since the files are compiled with Python 3.10, you will need to use a Python 3.10 environment to work with these modules. If you wish to use a different Python version, you can recompile the .so files during runtime.</li> </ol> <pre><code>cd opulse\ntar -xzvf operator_funcs_so.tar.gz\n</code></pre> <p>(back to top)</p>"},{"location":"#usage","title":"Usage","text":""},{"location":"#generate-operator","title":"generate operator","text":"<p>For detailed usage and configurations, refer to the following documents:</p> <ul> <li>Generate Operator Config</li> <li>Generate Operator Progess</li> </ul>"},{"location":"#generate-expression","title":"generate expression","text":"<p>For detailed usage and configurations, refer to the following documents:</p> <ul> <li>Generate Expression Config</li> <li>Generate Expression Progess</li> </ul> <p>(back to top)</p>"},{"location":"generate_expression/","title":"Expression Generate Process","text":""},{"location":"generate_expression/#generate_expression_single","title":"generate_expression_single:","text":"<p>Generate expressions with a single operator.</p>"},{"location":"generate_expression/#how-to-use","title":"How to Use","text":"<p>To run the script, execute the following command with the desired parameters:</p> <pre><code>python generate_expression_single.py \\\n    --config &lt;config_path&gt; \\\n    --cython-cache-dir &lt;cython_cache_dir&gt; \\\n    --operators-path &lt;operators_path&gt; \\\n    --generated-expression-path &lt;generated_expression_path&gt; \\\n    --num &lt;num&gt; \\\n    --workers &lt;workers&gt; \\\n    --func_id &lt;func_id&gt; \\\n    --base &lt;base&gt;\n</code></pre>"},{"location":"generate_expression/#command-line-arguments","title":"Command-Line Arguments:","text":"<ul> <li><code>--config</code>: The path to the configuration file for the expression generation process.</li> <li><code>--cython-cache-dir</code>: The directory where the Cython cache is stored.</li> <li><code>--operators-path</code>: The path to the JSONL file containing the operators to be used in the generation (e.g., <code>final_base.jsonl</code>).</li> <li><code>--generated-expression-path</code>: The directory where the generated expressions will be saved (e.g., <code>data/exps/expr_test</code>).</li> <li><code>--num</code>: The number of expressions to generate (default: 10000).</li> <li><code>--workers</code>: The number of worker processes to use for parallelism (default: 8).</li> <li><code>--func_id</code>: The function ID for expression generation. Use <code>\"all\"</code> to generate expressions for all operators.</li> <li><code>--base</code>: The numerical base for expression generation (e.g., 10 for decimal, 2 for binary).</li> </ul>"},{"location":"generate_expression/#bash-script-for-convenience","title":"Bash Script for Convenience","text":"<p>To facilitate the execution process, a bash script is provided that can be run with modified parameters.</p> <pre><code>nohup bash run_generate_singleop_expression.sh &gt; output.log 2&gt;&amp;1 &amp;\n</code></pre>"},{"location":"generate_expression/#generate_expression_combination","title":"generate_expression_combination:","text":"<p>Generate expressions containing combinations of operators for different bases at different depths.</p>"},{"location":"generate_expression/#how-to-use_1","title":"How to Use","text":"<p>To run the script, execute the following command with the desired parameters:</p> <pre><code>python generate_expression_combination.py \\\n    --config &lt;config_path&gt; \\\n    --cython-cache-dir &lt;cython_cache_dir&gt; \\\n    --operators-path &lt;operators_path&gt; \\\n    --generated-expression-path &lt;generated_expression_path&gt; \\\n    --generated-opexpr-dependency-path &lt;generated_opexpr_dependency_path&gt; \\\n    --num &lt;num&gt; \\\n    --workers &lt;workers&gt; \\\n    --base &lt;base&gt; \\\n    --depth &lt;depth&gt;\n</code></pre>"},{"location":"generate_expression/#command-line-arguments_1","title":"Command-Line Arguments:","text":"<ul> <li><code>--config</code>: The path to the configuration file for the expression generation process.</li> <li><code>--cython-cache-dir</code>: The directory where the Cython cache is stored.</li> <li><code>--operators-path</code>: The path to the JSONL file containing the operators to be used in the generation.</li> <li><code>--generated-expression-path</code>: The directory where the generated expressions will be saved.</li> <li><code>--generated-opexpr-dependency-path</code>: The path to save dependencies related to the generated expressions.</li> <li><code>--num</code>: The number of expressions to generate.</li> <li><code>--workers</code>: The number of worker processes to use for parallelism.</li> <li><code>--base</code>: The numerical base for expression generation.</li> <li><code>--depth</code>: The depth of the expressions to generate (default: 2). Higher depth means more complex expressions.</li> </ul>"},{"location":"generate_expression/#bash-script-for-convenience_1","title":"Bash Script for Convenience","text":"<p>To facilitate the execution process, a bash script is provided that can be run with modified parameters.</p> <pre><code>nohup run_generate_expression_base_n_depth_m.sh &gt; output.log 2&gt;&amp;1 &amp;\n</code></pre>"},{"location":"generate_operator/","title":"Operator Generate Process","text":""},{"location":"generate_operator/#generate_operator_type","title":"generate_operator_type","text":"<p>Generate an operator of a certain order and a certain type of definition.</p>"},{"location":"generate_operator/#how-to-use","title":"How to Use","text":"<p>To run the script, execute the following command with the desired parameters:</p> <pre><code>python generate_operator_type.py \\\n    --config &lt;config_path&gt; \\\n    --initial-operators-path &lt;initial_operators_path&gt; \\\n    --generated-operators-path &lt;generated_operators_path&gt; \\\n    --cython-cache-dir &lt;cython_cache_dir&gt; \\\n    --mode &lt;mode&gt; \\\n    --num &lt;num&gt; \\\n    --n_order &lt;n_order&gt;\n</code></pre>"},{"location":"generate_operator/#command-line-arguments","title":"Command-Line Arguments:","text":"<ul> <li><code>--config</code>: The path to the configuration YAML file for operator generation.</li> <li><code>--initial-operators-path</code>: The path to the initial operator JSONL file.</li> <li><code>--generated-operators-path</code>: The path where the generated operators will be saved.</li> <li><code>--cython-cache-dir</code>: The directory where Cython compiled functions will be cached.</li> <li><code>--mode</code>: The mode for operator generation. Choose between:</li> <li><code>raise</code>: Generate operators for the raise mode (e.g., exponentiation-like operations, which represent higher-order relationships).</li> <li><code>expand</code>: Generate operators for the expand mode (e.g., expansion operations like polynomial expansion or algebraic transformations).</li> <li><code>--num</code>: The number of operators to generate.</li> <li><code>--n_order</code>: The order of the operators to generate.</li> </ul>"},{"location":"generate_operator/#generate_operator_multiprocess","title":"generate_operator_multiprocess","text":"<p>Generate operators at a large scale using multiprocessing.</p>"},{"location":"generate_operator/#how-to-use_1","title":"How to Use","text":"<p>To run the script, execute the following command with the desired parameters:</p> <pre><code>python generate_operator_multiprocess.py \\\n    --config &lt;config_path&gt; \\\n    --initial-operators-path &lt;initial_operators_path&gt; \\\n    --generated-operators-path &lt;generated_operators_path&gt; \\\n    --cython-cache-dir &lt;cython_cache_dir&gt; \\\n    --num &lt;num&gt; \\\n    --max-workers &lt;max_workers&gt; \\\n    --ratio &lt;ratio&gt; \\\n    --raise-increase-at-order &lt;raise_increase_at_order&gt; \\\n    --increase-count &lt;increase_count&gt; \\\n    --continue-mode &lt;continue_mode&gt;\n\n</code></pre>"},{"location":"generate_operator/#command-line-arguments_1","title":"Command-Line Arguments:","text":"<ul> <li><code>--config</code>: The path to the configuration YAML file for operator generation.</li> <li><code>--initial-operators-path</code>: The path to the initial operator JSONL file.</li> <li><code>--generated-operators-path</code>: The path where the generated operators will be saved.</li> <li><code>--cython-cache-dir</code>: The directory where Cython compiled functions will be cached.</li> <li><code>--num</code>: The number of operators to generate.</li> <li><code>--max-workers</code>: This argument specifies the maximum number of worker processes for parallel execution. </li> <li><code>--ratio</code>: This argument specifies the ratio of each layer compared to the previous one, which is useful for expanding operators. The default value is <code>0.6</code>.</li> <li><code>--raise-increase-at-order</code>: At which order the recursive definition starts generating higher-order operators.. The default value is <code>3</code>.</li> <li><code>--increase-count</code>: This argument specifies the number of operators to add after the raise-order point is reached. The default value is <code>3</code>.</li> <li><code>--continue-mode</code>: This argument specifies whether to continue the generation process from the last checkpoint (<code>True</code>) or start a fresh generation process (<code>False</code>). The default value is <code>True</code>.</li> </ul>"},{"location":"generate_operator/#bash-script-for-convenience","title":"Bash Script for Convenience","text":"<p>To facilitate the execution process, a bash script is provided that can be run with modified parameters.</p> <pre><code>nohup bash run_generate_operator_multiprocess.sh &gt; output.log 2&gt;&amp;1 &amp;\n</code></pre>"},{"location":"generate_operator/#assign_operator_priority","title":"assign_operator_priority","text":"<p>Assign priority and associativity after the operator data generation completes.</p>"},{"location":"generate_operator/#how-to-run","title":"How to Run","text":"<p>To run the script, execute the following command with the desired parameters:</p> <pre><code>python assign_operator_priority.py \\\n    --config &lt;config_path&gt; \\\n    --operator-file &lt;operator_input_path&gt; \\\n    --output-operator-file &lt;output_operator_path&gt; \\\n    --cython-cache-dir &lt;cython_cache_directory&gt;\n</code></pre>"},{"location":"generate_operator/#command-line-arguments_2","title":"Command-Line Arguments:","text":"<ul> <li><code>--config</code>: The path to the configuration YAML file for operator generation.</li> <li><code>--operator-file</code>: Defines the path to the input JSONL file containing the initial operator data. This argument is required.  </li> <li><code>--output-operator-file</code>: Determines the output path where the generated operators will be stored. This is also a required argument.  </li> <li><code>--cython-cache-dir</code>: Specifies the directory where Cython compiled functions will be cached. </li> </ul>"},{"location":"generate_operator/#generate_base_operator","title":"generate_base_operator","text":"<p>Generate unary operators representing various bases.</p>"},{"location":"generate_operator/#how-to-run_1","title":"How to Run","text":"<p>To run the script, execute the following command with the desired parameters: </p> <pre><code>python generate_base_operator.py \\\n    --config &lt;config_path&gt; \\\n    --max_base &lt;max_base_value&gt; \\\n    --operator-file &lt;operator_file_path&gt; \\\n    --output-file &lt;output_file_path&gt; \\\n    --cython-cache-dir &lt;cython_cache_directory&gt;\n</code></pre>"},{"location":"generate_operator/#command-line-arguments_3","title":"Command-Line Arguments:","text":"<ul> <li><code>--config</code>: Specifies the path to the configuration file that defines the operator generation rules.</li> <li><code>--max_base</code>:Defines the maximum base value for numeral systems in the generated operators.</li> <li><code>--operator-file</code>: Indicates the path to the input file containing existing operators. </li> <li><code>--output-file</code>: Specifies the path where the generated operators will be saved. </li> <li><code>--cython-cache-dir</code>: Defines the directory where Cython compiled functions will be stored.   </li> </ul>"},{"location":"generate_operator/#op_func_transform","title":"op_func_transform","text":"<p>Reverse transform a computation function back into an operator definition.</p>"},{"location":"config/generate_expression/","title":"YAML Configuration for Expression Generation","text":""},{"location":"config/generate_expression/#1-logging-configuration","title":"1. Logging Configuration","text":"<pre><code>logging:\n  level: INFO  # INFO or DEBUG, WARNING, ERROR, CRITICAL\n  log_dir: \"logs\"  # Log directory\n  log_file: \"data.log\"  # Log file name\n  save_file: true  # Whether to save the logs to a file\n</code></pre> <ul> <li>level: Defines the logging level. Options include <code>DEBUG</code>, <code>WARNING</code>, <code>ERROR</code>, and <code>CRITICAL</code>. It controls the verbosity of the logs. <code>DEBUG</code> is the most detailed.</li> <li>log_dir: The directory where log files will be stored.</li> <li>log_file: The name of the log file that will contain the logs. Sure! Here's the full explanation for the logging section, continuing from where you left off:</li> <li>save_file: A flag to specify whether to save the logs to a file. If set to <code>true</code>, the logs will be written to the log file. If set to <code>false</code>, logging information may be displayed on the console or ignored, depending on other configurations.</li> </ul>"},{"location":"config/generate_expression/#2-numeric-representation","title":"2. Numeric Representation","text":"<pre><code>max_base: 16\ncustom_digits: \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n</code></pre> <ul> <li>max_base: The maximum numeric base to be used for numerical operations. In this case, the base is set to 16, allowing hexadecimal operations.</li> <li>custom_digits: A string defining the custom set of digits used for representing numbers in different bases. Here it supports bases up to 36, with digits 0-9 and letters A-Z.</li> </ul>"},{"location":"config/generate_expression/#3-other-symbol-atoms","title":"3. Other Symbol Atoms","text":"<pre><code>other_symbols_atoms:\n  left_parenthesis: \"(\" \n  right_parenthesis: \")\"\n  equals_sign: \"=\"\n  nan_symbol: \"NaN\" \n  inf_symbol: \"Inf\"  \n  neg_inf_symbol: \"-Inf\"  \n</code></pre> <ul> <li>left_parenthesis: Defines the left parenthesis <code>(</code> used in expressions.</li> <li>right_parenthesis: Defines the right parenthesis <code>)</code> used in expressions.</li> <li>equals_sign: Defines the equal sign <code>=</code>, typically used for assignments or equality checks.</li> <li>nan_symbol: Defines the symbol for \"NaN\" (Not a Number), indicating that the expression does not have a solution.</li> <li>inf_symbol: Defines the symbol for positive infinity.</li> <li>neg_inf_symbol: Defines the symbol for negative infinity.</li> </ul>"},{"location":"config/generate_expression/#4-expression-generation","title":"4. Expression Generation","text":"<pre><code>expr_variables:\n  - a\n  - b\nexpr_numeric_range: \n  max_value: 1000\n  min_value: 0 \nexpr_max_depth: 3\nexpr_type_weights: \n  binary: 0.7\n  unary_prefix: 0.2\n  unary_postfix: 0.1\n  atoms: 0 # Indicates that only numbers, not single variables, will be generated as atoms\nexpr_atom_type_weights: \n  variable: 0.3\n  number: 0.7\nrandom_base:\n  flag: false\n  base: 10\nresult_base: \n  random_flag: false\n  base: 10\nlonger_result_compute:\n  flag: true\n  base: 10\n</code></pre> <ul> <li> <p>expr_variables: Defines the variables available for expression generation. In this case, only <code>a</code> and <code>b</code> will be used as operands.</p> </li> <li> <p>expr_numeric_range: Specifies the numeric range for the expressions, from <code>0</code> to <code>1000</code>. This applies to numeric atoms and intermediate values.</p> </li> <li> <p>expr_max_depth: Sets the maximum depth of generated expressions. A depth of <code>3</code> allows up to three levels of nested operations.</p> </li> <li> <p>expr_type_weights: Specifies the probability distribution for expression types:</p> </li> <li>binary (0.7): 70% binary operations (e.g., <code>a + b</code>).</li> <li>unary_prefix (0.2): 20% unary prefix operations (e.g., <code>-a</code>).</li> <li>unary_postfix (0.1): 10% unary postfix operations (e.g., <code>a!</code>).</li> <li> <p>atoms (0): No single variables or numbers generated as atoms.</p> </li> <li> <p>expr_atom_type_weights: Defines the probability of atoms being variables or numbers:</p> </li> <li>variable (0.3): 30% variables (e.g., <code>a</code>, <code>b</code>).</li> <li> <p>number (0.7): 70% numbers (e.g., <code>1</code>, <code>42</code>, <code>1000</code>).</p> </li> <li> <p>random_base: Determines if random bases will be used for numbers. If enabled (<code>true</code>), numbers can be in different bases. Default is decimal (<code>base: 10</code>).</p> </li> <li> <p>result_base: Controls the base for the result of expressions. Default is decimal (<code>base: 10</code>), but it can be randomly selected if enabled.</p> </li> <li> <p>longer_result_compute: Enables more complex calculations for longer results. If enabled (<code>true</code>), results will be computed in the specified base (<code>base: 10</code>).</p> </li> </ul>"},{"location":"config/generate_operator/","title":"YAML Configuration for Operator Generation","text":""},{"location":"config/generate_operator/#1-logging-configuration","title":"1. Logging Configuration","text":"<pre><code>logging:\n  level: INFO  # INFO or DEBUG, WARNING, ERROR, CRITICAL\n  log_dir: \"logs\"  # Log directory\n  log_file: \"data.log\"  # Log file name\n  save_file: true  # Whether to save the logs to a file\n</code></pre> <ul> <li>level: Defines the logging level. Options include <code>DEBUG</code>, <code>WARNING</code>, <code>ERROR</code>, and <code>CRITICAL</code>. It controls the verbosity of the logs. <code>DEBUG</code> is the most detailed.</li> <li>log_dir: The directory where log files will be stored.</li> <li>log_file: The name of the log file that will contain the logs. Sure! Here's the full explanation for the logging section, continuing from where you left off:</li> <li>save_file: A flag to specify whether to save the logs to a file. If set to <code>true</code>, the logs will be written to the log file. If set to <code>false</code>, logging information may be displayed on the console or ignored, depending on other configurations.</li> </ul>"},{"location":"config/generate_operator/#2-numeric-representation","title":"2. Numeric Representation","text":"<pre><code>max_base: 16\ncustom_digits: \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n</code></pre> <ul> <li>max_base: The maximum numeric base to be used for numerical operations. In this case, the base is set to 16, allowing hexadecimal operations.</li> <li>custom_digits: A string defining the custom set of digits used for representing numbers in different bases. Here it supports bases up to 36, with digits 0-9 and letters A-Z.</li> </ul>"},{"location":"config/generate_operator/#3-variable-atoms","title":"3. Variable Atoms","text":"<pre><code>variable_atoms:\n  - left_operand: \"a\"\n  - right_operand: \"b\"\n</code></pre> <ul> <li>variable_atoms: Defines the variables that will be used as operands in expressions. Here, \"a\" is used as the left operand and \"b\" as the right operand.</li> </ul>"},{"location":"config/generate_operator/#4-other-symbol-atoms","title":"4. Other Symbol Atoms","text":"<pre><code>other_symbols_atoms:\n  left_parenthesis: \"(\" \n  right_parenthesis: \")\"\n  equals_sign: \"=\"\n  nan_symbol: \"NaN\" \n  inf_symbol: \"Inf\"  \n  neg_inf_symbol: \"-Inf\"  \n</code></pre> <ul> <li>left_parenthesis: Defines the left parenthesis <code>(</code> used in expressions.</li> <li>right_parenthesis: Defines the right parenthesis <code>)</code> used in expressions.</li> <li>equals_sign: Defines the equal sign <code>=</code>, typically used for assignments or equality checks.</li> <li>nan_symbol: Defines the symbol for \"NaN\" (Not a Number), indicating that the expression does not have a solution.</li> <li>inf_symbol: Defines the symbol for positive infinity.</li> <li>neg_inf_symbol: Defines the symbol for negative infinity.</li> </ul>"},{"location":"config/generate_operator/#5-operator-generation","title":"5. Operator Generation","text":"<pre><code>operator_symbol_min_len: 1\noperator_symbol_max_len: 3\nbasic_operator_symbols: [\"+\", \"-\", \"*\", \"/\", \"%\"]\ncomparison_ops: [\"==\", \"&gt;\", \"&lt;\", \"&gt;=\", \"&lt;=\", \"!=\"]\nlogical_connectors: [\"and\", \"or\"]\ncondition_numeric_range:\n  max_value: 1000\n  min_value: 0\ncondition_probabilities:\n  1: 0.7\n  2: 0.2\n  3: 0.1\n</code></pre> <ul> <li>operator_symbol_min_len: Minimum length of an operator symbol. For example, the <code>+</code> symbol has a length of 1.</li> <li>operator_symbol_max_len: Maximum length of an operator symbol. This will limit operator lengths to 3 characters.</li> <li>basic_operator_symbols: A list of basic operators used for arithmetic calculations, such as addition (<code>+</code>), subtraction (<code>-</code>), multiplication (<code>*</code>), division (<code>/</code>), and modulus (<code>%</code>).</li> <li>comparison_ops: A list of comparison operators for conditions, such as equality (<code>==</code>), greater than (<code>&gt;</code>), less than (<code>&lt;</code>), etc.</li> <li>logical_connectors: A list of logical connectors used in expressions, such as <code>and</code> and <code>or</code>.</li> <li>condition_numeric_range: Defines the numeric range used for conditions. The values are between <code>0</code> and <code>1000</code> (no negative numbers here).</li> <li>condition_probabilities: Defines the probability distribution for different condition types. For example, there is a 70% chance that a condition will be of type 1, a 20% chance for type 2, and a 10% chance for type 3.</li> </ul>"},{"location":"config/generate_operator/#6-configuration-parameters-for-defining-strings-used-in-expressions-during-operator-definition-generation","title":"6. Configuration Parameters for Defining Strings Used in Expressions During Operator Definition Generation","text":"<pre><code>expr_variables:\n  - a\n  - b\nexpr_numeric_range: \n  max_value: 1000\n  min_value: 0\nexpr_max_depth: 3\nexpr_type_weights: \n  binary: 0.7\n  unary_prefix: 0.2\n  unary_postfix: 0.1\n  atoms: 0.1\nexpr_atom_type_weights: \n  variable: 0.8\n  number: 0.2\n</code></pre> <ul> <li>expr_variables: The variables used in expression generation.</li> <li>expr_numeric_range: Defines the numeric range used in expressions. The values range from 0 to 1000.</li> <li>expr_max_depth: The maximum depth of the generated expressions. For example, if set to 3, the expression will have a maximum of 3 levels of operations.</li> <li>expr_type_weights: Defines the probability distribution for the types of expressions to be generated. For example, 70% of expressions will be binary, 20% unary prefix, 10% unary postfix, and 10% atoms.</li> <li>expr_atom_type_weights: Defines the probability distribution for the types of atoms in the expressions. 80% will be variables and 20% will be numbers.</li> </ul>"},{"location":"config/generate_operator/#7-base-configuration-settings-not-applied-in-operator-generation","title":"7. Base Configuration Settings Not Applied in Operator Generation","text":"<pre><code>random_base:\n  flag: false\n  base: 10\nresult_base: \n  random_flag: false\n  base: 10\nlonger_result_compute:\n  flag: true\n  base: 10\n</code></pre>"},{"location":"expression/base_converter/","title":"BaseConverter","text":""},{"location":"expression/base_converter/#opulse.expression.base_converter.BaseConverter","title":"<code>BaseConverter</code>","text":"<p>Tool class that converts an integer to a string representation in the specified binary.</p> <p>Supports any base between 2 and 36, using numbers and letters as symbols. The conversion behavior can be customized by setting different configuration items.</p> Source code in <code>opulse/expression/base_converter.py</code> <pre><code>class BaseConverter:\n    \"\"\"\n    Tool class that converts an integer to a string representation in the specified binary.\n\n    Supports any base between 2 and 36, using numbers and letters as symbols.\n    The conversion behavior can be customized by setting different configuration items.\n    \"\"\"\n\n    # \u9ed8\u8ba4\u5b57\u7b26\u96c6\uff1a0-9, A-Z\n    DEFAULT_DIGITS = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\n    def __init__(self, max_base=10, digits: str = None):\n        \"\"\"\n        Initializes the BaseConverter instance.\n\n        Parameters:\n            max_base (int): target base, defaults to 10.\n            digits (str): the character set used to represent the value, defaults to the default character set.\n        \"\"\"\n        self.max_base = max_base\n        self.digits = digits if digits else self.DEFAULT_DIGITS[:max_base]\n\n    def get_digits(self):\n        return self.digits\n\n    def get_max_base(self):\n        return self.max_base\n\n    def convert(self, number: int, base: int) -&gt; str:\n        \"\"\"\n        Converts an integer to a string representation in the specified binary.\n\n        Parameters:\n            number (int): The integer to be converted.\n\n        Returns:\n            (str): The string representation in the specified hexadecimal system.\n        \"\"\"\n        if number == 0:\n            return f\"{self.digits[0]}\"\n\n        if number &lt; 0:\n            sign = \"-\"\n            number = -number\n        else:\n            sign = \"\"\n\n        result = \"\"\n        try:\n            while number &gt; 0:\n                remainder = number % base\n                result = self.digits[remainder] + result\n                number = number // base\n        except Exception as e:\n            print(f\"remainder: {remainder}, number: {number}, base: {base} {e}\")\n            raise e\n        return f\"{sign}{result}\"\n\n    @staticmethod\n    def get_supported_bases():\n        \"\"\"\n        Return the supported base range\n\n        Returns:\n            (List[int]): The supported base range.\n        \"\"\"\n        return list(range(2, 37))\n</code></pre>"},{"location":"expression/base_converter/#opulse.expression.base_converter.BaseConverter.__init__","title":"<code>__init__(max_base=10, digits=None)</code>","text":"<p>Initializes the BaseConverter instance.</p> <p>Parameters:</p> Name Type Description Default <code>max_base</code> <code>int</code> <p>target base, defaults to 10.</p> <code>10</code> <code>digits</code> <code>str</code> <p>the character set used to represent the value, defaults to the default character set.</p> <code>None</code> Source code in <code>opulse/expression/base_converter.py</code> <pre><code>def __init__(self, max_base=10, digits: str = None):\n    \"\"\"\n    Initializes the BaseConverter instance.\n\n    Parameters:\n        max_base (int): target base, defaults to 10.\n        digits (str): the character set used to represent the value, defaults to the default character set.\n    \"\"\"\n    self.max_base = max_base\n    self.digits = digits if digits else self.DEFAULT_DIGITS[:max_base]\n</code></pre>"},{"location":"expression/base_converter/#opulse.expression.base_converter.BaseConverter.convert","title":"<code>convert(number, base)</code>","text":"<p>Converts an integer to a string representation in the specified binary.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>int</code> <p>The integer to be converted.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The string representation in the specified hexadecimal system.</p> Source code in <code>opulse/expression/base_converter.py</code> <pre><code>def convert(self, number: int, base: int) -&gt; str:\n    \"\"\"\n    Converts an integer to a string representation in the specified binary.\n\n    Parameters:\n        number (int): The integer to be converted.\n\n    Returns:\n        (str): The string representation in the specified hexadecimal system.\n    \"\"\"\n    if number == 0:\n        return f\"{self.digits[0]}\"\n\n    if number &lt; 0:\n        sign = \"-\"\n        number = -number\n    else:\n        sign = \"\"\n\n    result = \"\"\n    try:\n        while number &gt; 0:\n            remainder = number % base\n            result = self.digits[remainder] + result\n            number = number // base\n    except Exception as e:\n        print(f\"remainder: {remainder}, number: {number}, base: {base} {e}\")\n        raise e\n    return f\"{sign}{result}\"\n</code></pre>"},{"location":"expression/base_converter/#opulse.expression.base_converter.BaseConverter.get_supported_bases","title":"<code>get_supported_bases()</code>  <code>staticmethod</code>","text":"<p>Return the supported base range</p> <p>Returns:</p> Type Description <code>List[int]</code> <p>The supported base range.</p> Source code in <code>opulse/expression/base_converter.py</code> <pre><code>@staticmethod\ndef get_supported_bases():\n    \"\"\"\n    Return the supported base range\n\n    Returns:\n        (List[int]): The supported base range.\n    \"\"\"\n    return list(range(2, 37))\n</code></pre>"},{"location":"expression/expression_base_converter/","title":"ExpressionBaseConverter","text":""},{"location":"expression/expression_base_converter/#opulse.expression.expression_base_converter.ExpressionBaseConverter","title":"<code>ExpressionBaseConverter</code>","text":"Source code in <code>opulse/expression/expression_base_converter.py</code> <pre><code>class ExpressionBaseConverter:\n    # def __init__(self, input_base: int = 10, output_base: int = 10):\n    #     \"\"\"\n    #     Initializes the ExpressionBaseConverter class and sets the base for input and output.\n\n    #     :param input_base: Enter the base of the expression, which defaults to decimal (10).\n    #     :param output_base: The base of the output expression, defaults to decimal (10).\n    #     \"\"\"\n    #     self.input_base = input_base\n    #     self.output_base = output_base\n    @staticmethod\n    def convert_int_to_targetbase(\n        input: int,\n        output_base: int,\n        base_converter: BaseConverter,\n        operator_manager: OperatorManager,\n    ) -&gt; str:\n        op_info = operator_manager.base_operators[output_base]\n        # only for debugging\n        if len(op_info) == 0:\n            return f\"{input}\"\n        assert len(op_info) == 1\n        return f\"{op_info[0].symbol}{base_converter.convert(input, output_base)}\"\n\n    @staticmethod\n    def convert_expr_str_to_targetbase(\n        expression: str,\n        output_base: int,\n        base_converter: BaseConverter,\n        operator_manager: OperatorManager,\n    ) -&gt; str:\n        \"\"\"\n        Converts all decimal digits surrounded by $ in the expression to the target base and removes the $ sign.\n\n        This static method takes a mathematical expression string where numbers are marked with dollar signs ($),\n        converts those numbers from decimal to the specified target base, and returns a new string with the updated numbers.\n        The conversion is performed using the provided BaseConverter instance.\n\n        Args:\n            expression (str): The original math expression string containing numbers marked with $...$.\n            output_base (int): The target base to which the numbers should be converted.\n            base_converter (BaseConverter): An instance of BaseConverter used for converting between bases.\n\n        Returns:\n            str: A new math expression string with numbers converted to the target base and without the $ sign.\n\n        Example:\n            Given an expression \"$100$ + $25$\" and output_base 2,\n            the returned string would be \"1100100 + 11001\".\n        \"\"\"\n\n        def replacer(match):\n            decimal_str = match.group(1)\n            decimal_num = int(decimal_str)\n            converted_str = base_converter.convert(decimal_num, output_base)\n            return converted_str\n\n\n        pattern = r\"\\$(\\d+)\\$\"\n        new_expression = re.sub(pattern, replacer, expression)\n        return new_expression\n</code></pre>"},{"location":"expression/expression_base_converter/#opulse.expression.expression_base_converter.ExpressionBaseConverter.convert_expr_str_to_targetbase","title":"<code>convert_expr_str_to_targetbase(expression, output_base, base_converter, operator_manager)</code>  <code>staticmethod</code>","text":"<p>Converts all decimal digits surrounded by $ in the expression to the target base and removes the $ sign.</p> <p>This static method takes a mathematical expression string where numbers are marked with dollar signs ($), converts those numbers from decimal to the specified target base, and returns a new string with the updated numbers. The conversion is performed using the provided BaseConverter instance.</p> <p>Parameters:</p> Name Type Description Default <code>expression</code> <code>str</code> <p>The original math expression string containing numbers marked with $...$.</p> required <code>output_base</code> <code>int</code> <p>The target base to which the numbers should be converted.</p> required <code>base_converter</code> <code>BaseConverter</code> <p>An instance of BaseConverter used for converting between bases.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A new math expression string with numbers converted to the target base and without the $ sign.</p> Example <p>Given an expression \"$100$ + $25$\" and output_base 2, the returned string would be \"1100100 + 11001\".</p> Source code in <code>opulse/expression/expression_base_converter.py</code> <pre><code>@staticmethod\ndef convert_expr_str_to_targetbase(\n    expression: str,\n    output_base: int,\n    base_converter: BaseConverter,\n    operator_manager: OperatorManager,\n) -&gt; str:\n    \"\"\"\n    Converts all decimal digits surrounded by $ in the expression to the target base and removes the $ sign.\n\n    This static method takes a mathematical expression string where numbers are marked with dollar signs ($),\n    converts those numbers from decimal to the specified target base, and returns a new string with the updated numbers.\n    The conversion is performed using the provided BaseConverter instance.\n\n    Args:\n        expression (str): The original math expression string containing numbers marked with $...$.\n        output_base (int): The target base to which the numbers should be converted.\n        base_converter (BaseConverter): An instance of BaseConverter used for converting between bases.\n\n    Returns:\n        str: A new math expression string with numbers converted to the target base and without the $ sign.\n\n    Example:\n        Given an expression \"$100$ + $25$\" and output_base 2,\n        the returned string would be \"1100100 + 11001\".\n    \"\"\"\n\n    def replacer(match):\n        decimal_str = match.group(1)\n        decimal_num = int(decimal_str)\n        converted_str = base_converter.convert(decimal_num, output_base)\n        return converted_str\n\n\n    pattern = r\"\\$(\\d+)\\$\"\n    new_expression = re.sub(pattern, replacer, expression)\n    return new_expression\n</code></pre>"},{"location":"expression/expression_evaluator/","title":"ExpressionEvaluator","text":""},{"location":"expression/expression_evaluator/#opulse.expression.expression_evaluator.ExpressionEvaluator","title":"<code>ExpressionEvaluator</code>","text":"Source code in <code>opulse/expression/expression_evaluator.py</code> <pre><code>class ExpressionEvaluator:\n\n    def __init__(\n        self,\n        param_config: ParamConfig,\n        logger: LogConfig,\n        cython_cache_dir: str,\n        operator_manager: OperatorManager,\n        base_converter: BaseConverter = None,\n    ):\n        \"\"\"\n        Initializes an instance of the ExpressionEvaluator class.\n\n        This constructor sets up the expression evaluator with necessary configurations and managers.\n        It initializes attributes to manage expression trees, operators, logging, and base conversions.\n        Additionally, it prepares data structures to track operator priorities, operation counts, and highest n-order values.\n\n        Parameters:\n            param_config (ParamConfig): Configuration settings for controlling the behavior of the expression evaluator.\n            logger (LogConfig): Configuration for setting up logging. Used to create a logger instance for this evaluator.\n            operator_manager (OperatorManager): Manager object that provides information about operators used in expressions.\n            base_converter (BaseConverter, optional): Converter object for handling different numerical bases in expressions. Defaults to None.\n        \"\"\"\n        self.param_config = param_config\n        self.logger = logger.get_logger()\n        # Initialization of relevant expressions to None\n        self.id = None\n        self.expression_tree: ExpressionNode = None\n        self.expression_str: str = None\n        self.operator_manager = operator_manager\n        self.base_converter = base_converter\n        self.all_priority = []\n        self.operation_count = 0\n        self.highest_n_order = 0\n        # Record all operators key: op id, value: number of occurrences\n        self.all_operators: Dict[str, int] = defaultdict(int)\n        self.with_all_brackets = False\n        self.cython_cache_dir = cython_cache_dir\n        # Used to replace meta words in expression strings\n        self.load_atoms()\n\n    def set_with_all_brackets(self, with_all_brackets: bool) -&gt; None:\n        \"\"\"\n        Sets whether to include all brackets in the expression string.\n\n        This method configures the behavior for generating expression strings. If set to True, it ensures that all parts of the\n        expression that require parentheses for correct order of operations will be enclosed in brackets. This can be useful\n        for ensuring clarity or for specific formatting requirements.\n\n        Parameters:\n            with_all_brackets (bool): A flag indicating whether to include all necessary brackets in the expression string.\n        \"\"\"\n        self.with_all_brackets = with_all_brackets\n\n    def load_atoms(self) -&gt; None:\n        \"\"\"\n        Loads atomic symbols from the parameter configuration.\n        \"\"\"\n        self.atoms = {\n            \"left_bracket\": self.param_config.get(\"other_symbols_atoms\")[\n                \"left_parenthesis\"\n            ],\n            \"right_bracket\": self.param_config.get(\"other_symbols_atoms\")[\n                \"right_parenthesis\"\n            ],\n            \"NaN\": self.param_config.get(\"other_symbols_atoms\")[\"nan_symbol\"],\n            \"equal\": self.param_config.get(\"other_symbols_atoms\")[\"equals_sign\"],\n            \"Inf\": self.param_config.get(\"other_symbols_atoms\")[\"inf_symbol\"],\n            \"-Inf\": self.param_config.get(\"other_symbols_atoms\")[\"neg_inf_symbol\"],\n        }\n\n    def init_expr(\n        self,\n        expression_tree,\n        id,\n        op_mode: bool = False,\n        expr_result_base: int = None,\n        longer_result_info: LongerResultInfo = None,\n    ):\n        \"\"\"\n        Initializes expression attributes with an expression tree and ID.\n\n        This method sets up the initial state for an expression by assigning an identifier and an expression tree.\n        It also initializes counters and dictionaries that will be used to track various properties of the expression,\n        such as operator priorities, operation counts, and operator occurrences. Finally, it generates string representations\n        of the expression based on the provided tree structure and optional parameters.\n\n        Parameters:\n            expression_tree (ExpressionNode): The root node of the expression tree to initialize.\n            id (any): An identifier for the expression, which can be any type that uniquely identifies the expression.\n            op_mode (bool, optional): A flag indicating whether the expression should be processed in operator mode. Defaults to False.\n        \"\"\"\n        self.id = id\n        self.expression_tree = expression_tree\n        self.cot_info: List[str] = []\n        self.cot: List[str] = []\n        self.all_priority = []\n        self.operation_count = 0\n        self.number_count = 0\n        self.variable_count = 0\n        self.highest_n_order = 0\n        self.expr_result = None\n        self.normalized_expansion_degree = None\n        self.all_operators: Dict[str, int] = defaultdict(int)\n        self.expr_result_base = expr_result_base\n        self.longer_result_info = longer_result_info\n        if op_mode:\n            self.expression_str = self.tree_to_str(self.expression_tree, op_mode=True)\n        else:\n            self.expression_str = self.tree_to_str(self.expression_tree, statistic_analysis=True)\n            self.expression_str_no_base_symbol = self.tree_to_str(\n                self.expression_tree, with_base_symbol=False\n            )\n\n    def op_info_sub_tree(self, node) -&gt; None:\n        if isinstance(node, NumberNode):\n            return\n        if isinstance(node, BinaryExpressionNode):\n            self.op_info_sub_tree(node.left_expr)\n            self.op_info_sub_tree(node.right_expr)\n            self.all_operators[node.operator.func_id] += 1\n            return\n        elif isinstance(node, UnaryExpressionNode):\n            self.op_info_sub_tree(node.unary_expr)\n            self.all_operators[node.operator.func_id] += 1\n            return\n        elif isinstance(node, VariableNode):\n            return\n        else:\n            raise NotImplementedError(\"ExpressionEvaluator.op_info_sub_tree\")\n\n    def all_op_info(self) -&gt; Dict[int, int]:\n        self.all_operators = defaultdict(int)\n        self.op_info_sub_tree(self.expression_tree)\n\n        return self.all_operators\n\n    def tree_to_str(\n        self,\n        node: ExpressionNode,\n        parent_op: OperatorInfo = None,\n        with_base_symbol: bool = True,\n        op_mode: bool = False,\n        statistic_analysis:bool = False,\n    ) -&gt; str:\n        \"\"\"\n        Converts an expression tree node to a string representation.\n\n        This method recursively traverses the expression tree and builds a string representation based on the node type.\n        For binary and unary expression nodes, it checks the operator priority relative to the parent node's operator priority\n        to determine if parentheses are needed to preserve correct order of operations.\n        For number and variable nodes, it returns their direct string representations.\n\n        Parameters:\n            node (ExpressionNode): The expression node to convert.\n            parent_op (OperatorInfo, optional): Information about the parent operator, used to determine if parentheses are needed. Defaults to None.\n            with_base_symbol (bool, optional): Whether to include base symbols in the string. Defaults to True.\n            op_mode (bool, optional): A flag indicating operator mode. Defaults to False.\n\n        Returns:\n            str: String representation of the expression node.\n\n        Raises:\n            NotImplementedError: If an unsupported expression node type is encountered.\n        \"\"\"\n\n        # Requires the priority of the parent node's operator for determining whether to add brackets\n        if isinstance(node, NumberNode):\n            node = cast(NumberNode, node)\n            if op_mode:\n                # when op_mode, we don't generate any base-related symbol\n                return f\"{node.to_str_no_base_symbol()}\"\n            else:\n                if statistic_analysis:\n                    self.number_count += 1\n                if with_base_symbol:\n                    return f\"{node.to_str(self.operator_manager,self.base_converter)}\"\n                else:\n                    return f\"{node.to_str_no_base_symbol(surround_symbol='$')}\"\n        elif isinstance(node, VariableNode):\n            return f\"{node.v}\"\n        elif isinstance(node, BinaryExpressionNode):\n            node = cast(BinaryExpressionNode, node)\n            if not op_mode:\n                if statistic_analysis:\n                    # Statistical priority for calculating calculate_priority_hierarchical_complexity\n                    if (\n                        node.operator.priority != None\n                        and node.operator.priority not in self.all_priority\n                    ):\n                        self.all_priority.append(node.operator.priority)\n                    # Count the number of operations and associate the expression with the operator\n                    self.operation_count += 1\n                    self.all_operators[node.operator.func_id] += 1\n                    # Count the n_order info\n                    if self.highest_n_order &lt; node.operator.n_order:\n                        self.highest_n_order = node.operator.n_order\n            else:\n                self.operation_count += 1\n                self.all_operators[node.operator.func_id] += 1\n            # Convert the expression of the subtree\n            left_str = self.tree_to_str(\n                node.left_expr,\n                node.operator,\n                with_base_symbol=with_base_symbol,\n                op_mode=op_mode,\n                statistic_analysis=statistic_analysis,\n            )\n            right_str = self.tree_to_str(\n                node.right_expr,\n                node.operator,\n                with_base_symbol=with_base_symbol,\n                op_mode=op_mode,\n                statistic_analysis=statistic_analysis,\n            )\n\n            if self.with_all_brackets:\n                return f\"{self.atoms['left_bracket']}{left_str}{node.operator.symbol}{right_str}{self.atoms['right_bracket']}\"\n            # self.logger.debug(f\"parent_op: {parent_op}\")\n            if parent_op != None and node.operator.priority &lt; parent_op.priority:\n                return f\"{self.atoms['left_bracket']}{left_str}{node.operator.symbol}{right_str}{self.atoms['right_bracket']}\"\n            elif parent_op != None and node.operator.priority == parent_op.priority:\n                # If it has the same priority as parent op, choose whether to add parentheses or not based on location and binding.\n                if (\n                    parent_op.associativity_direction == \"left\"\n                    and node.position == \"right\"\n                ):\n                    return f\"{self.atoms['left_bracket']}{left_str}{node.operator.symbol}{right_str}{self.atoms['right_bracket']}\"\n                elif (\n                    parent_op.associativity_direction == \"right\"\n                    and node.position == \"left\"\n                ):\n                    return f\"{self.atoms['left_bracket']}{left_str}{node.operator.symbol}{right_str}{self.atoms['right_bracket']}\"\n                else:\n                    return f\"{left_str}{node.operator.symbol}{right_str}\"\n            else:\n                return f\"{left_str}{node.operator.symbol}{right_str}\"\n        elif isinstance(node, UnaryExpressionNode):\n            node = cast(UnaryExpressionNode, node)\n            if not op_mode:\n                if statistic_analysis:\n                    # Statistical priority for calculating calculate_priority_hierarchical_complexity\n                    if (\n                        node.operator.priority != None\n                        and node.operator.priority not in self.all_priority\n                    ):\n                        self.all_priority.append(node.operator.priority)\n                    # Count the number of operations and associate the expression with the operator\n                    self.operation_count += 1\n                    self.all_operators[node.operator.func_id] += 1\n                    # Count the n_order info\n                    if node.operator.n_order==None:\n                        print(node.operator.func_id)\n                    if self.highest_n_order &lt; node.operator.n_order:\n                        self.highest_n_order = node.operator.n_order\n            else:\n                self.operation_count += 1\n                self.all_operators[node.operator.func_id] += 1\n            unary_str = self.tree_to_str(\n                node.unary_expr,\n                node.operator,\n                with_base_symbol=with_base_symbol,\n                op_mode=op_mode,\n                statistic_analysis=statistic_analysis,\n            )\n            if node.operator.unary_position=='postfix':\n                return f\"({unary_str}{node.operator.symbol})\"\n            elif node.operator.unary_position=='prefix':\n            # Doubt: Always choose to add brackets to unary\n                return f\"({node.operator.symbol}{unary_str})\"\n        else:\n            raise NotImplementedError(\"ExpressionEvaluator.tree_to_str\")\n\n    def calculate_highest_n_order(self) -&gt; int:\n        \"\"\"\n        Calculates the highest n-order of the expression.\n\n        Returns:\n            (int): The highest n-order value.\n        \"\"\"\n        return self.highest_n_order\n\n    def calculate_priority_hierarchical_complexity(self) -&gt; int:\n        \"\"\"\n        Calculates the priority-based hierarchical complexity.\n\n        Returns:\n            (int): The complexity value.\n        \"\"\"\n        return len(self.all_priority)\n\n    def calculate_normalized_expansion_degree(self) -&gt; Union[int, str]:\n        # Implementing the computational logic for normalized expansion degree\n        \"\"\"\n        Calculates the normalized expansion degree of the expression.\n\n        Returns:\n            (int): The normalized expansion degree or \"NaN\".\n        \"\"\"\n        normalized_expansion_degree = self.normalized_expansion_degree\n        if self.normalized_expansion_degree is not None:\n            # return (\n            #     self.normalized_expansion_degree\n            #     if self.normalized_expansion_degree != \"NaN\"\n            #     else self.atoms[\"NaN\"]\n            # )\n            normalized_expansion_degree = self.normalized_expansion_degree\n        else:\n            degree, result = self.calculate_normalized_expansion_degree_node(\n                self.expression_tree\n            )\n            self.normalized_expansion_degree = degree\n            self.expr_result = result\n            normalized_expansion_degree = degree\n\n        if normalized_expansion_degree != normalized_expansion_degree:\n            return self.atoms[\"NaN\"]\n        elif normalized_expansion_degree == float(\"inf\"):\n            return self.atoms[\"Inf\"]\n        elif normalized_expansion_degree == float(\"-inf\"):\n            return self.atoms[\"-Inf\"]\n        else:\n            return self.normalized_expansion_degree\n\n    def calculate_result(self) -&gt; Union[str, int]:\n        \"\"\"\n        Calculates the normalized expansion degree of the expression.\n\n        The normalized expansion degree is a measure that represents how much an expression has been expanded or simplified.\n        It can be used to evaluate the complexity of the expression in terms of its structure and size after operations.\n\n        Returns:\n            (Union[int, str]): The normalized expansion degree or \"NaN\".s an integer or \"NaN\" if it cannot be calculated.\n        \"\"\"\n        expr_result = None\n        if self.expr_result is not None:\n            expr_result = self.expr_result\n            # return self.expr_result if self.expr_result != \"NaN\" else self.atoms[\"NaN\"]\n        else:\n            degree, result = self.calculate_normalized_expansion_degree_node(\n                self.expression_tree\n            )\n            self.normalized_expansion_degree = degree\n            self.expr_result = result\n            expr_result = result\n            # return self.expr_result if self.expr_result != \"NaN\" else self.atoms[\"NaN\"]\n\n        if self.expr_result_base != None and type(expr_result) == int:\n            return ExpressionBaseConverter.convert_int_to_targetbase(\n                input=expr_result,\n                output_base=self.expr_result_base,\n                base_converter=self.base_converter,\n                operator_manager=self.operator_manager,\n            )\n        elif expr_result != expr_result:\n            return self.atoms[\"NaN\"]\n        elif expr_result == float(\"inf\"):\n            return self.atoms[\"Inf\"]\n        elif expr_result == float(\"-inf\"):\n            return self.atoms[\"-Inf\"]\n        else:\n            return expr_result\n\n    def get_compute_count_func(self, operator:OperatorInfo):\n        if operator.module == None:\n            # for depend_id in operator.dependencies:\n            #     so_file = f\"module_{depend_id}.cpython-310-x86_64-linux-gnu.so\"\n            #     full_path = os.path.join(self.cython_cache_dir, so_file)\n            #     if os.path.exists(full_path):\n            #         self.operator_manager.compiler.import_module_from_path(f\"module_{operator.func_id}\")\n            so_file = f\"module_{operator.func_id}.cpython-310-x86_64-linux-gnu.so\"\n            full_path = os.path.join(self.cython_cache_dir, so_file)\n            if os.path.exists(full_path):\n                operator.module = self.operator_manager.compiler.import_module_from_path(f\"module_{operator.func_id}\")\n        compute_func = getattr(operator.module, f\"op_{operator.func_id}\", None)\n        count_func = getattr(operator.module, f\"op_count_{operator.func_id}\", None)\n        return compute_func, count_func\n\n    def get_target_base_str(self, value:int, target_base:int )-&gt;str:\n        if value == float(\"inf\") or value == float(\"-inf\") or value != value:\n            value_str_with_base=f\"{value}\"\n        else:\n            value_str_with_base=ExpressionBaseConverter.convert_int_to_targetbase(\n                input=int(value),\n                output_base=self.longer_result_info.target_base,\n                base_converter=self.base_converter,\n                operator_manager=self.operator_manager,\n            )\n        return value_str_with_base\n\n    def calculate_normalized_expansion_degree_node(\n        self, node: ExpressionNode, cot_layer: int = 0\n    ) -&gt; Tuple[Union[int, str], Union[int, str]]:\n        \"\"\"\n        Helper method to recursively calculate the normalized expansion degree for each node in the expression tree.\n\n        This method traverses the expression tree and computes the degree based on the type and structure of nodes.\n\n        Args:\n            node (ExpressionNode): The current node in the expression tree.\n\n        Returns:\n            (Tuple[Union[int, str], Union[int, str]]): A tuple containing the normalized expansion degree and the evaluation result of the node.\n\n        Raises:\n            NotImplementedError: If the node type is not recognized.\n\n        \"\"\"\n        # For a single expression tree node, compute the normalized expansion of the tree rooted at this node and the resultant\n        # if isinstance(node, NumberNode):\n        #     return 0, node.value\n        # elif isinstance(node, UnaryExpressionNode):\n        #     sub_degree, sub_result = self.calculate_normalized_expansion_degree_node(\n        #         node.unary_expr\n        #     )\n        #     if sub_degree == \"NaN\" or sub_result == \"NaN\":\n        #         return \"NaN\", \"NaN\"\n        #     cur_result = node.operator.get_compute_function()(sub_result)\n        #     cur_degree = node.operator.get_count_function()(sub_result)\n        #     if cur_degree == \"NaN\" or cur_result == \"NaN\":\n        #         return \"NaN\", \"NaN\"\n        #     return cur_degree + sub_degree, cur_result\n        # elif isinstance(node, BinaryExpressionNode):\n        #     # \u4e8c\u5143\u64cd\u4f5c\u7b26\uff0c\u5206\u522b\u8ba1\u7b97\u5de6\u53f3\u5b50\u6811\u7684\u5f52\u4e00\u5c55\u5f00\u5ea6\n        #     left_degree, left_result = self.calculate_normalized_expansion_degree_node(\n        #         node.left_expr\n        #     )\n        #     if left_degree == \"NaN\" or left_result == \"NaN\":\n        #         return \"NaN\", \"NaN\"\n        #     right_degree, right_result = (\n        #         self.calculate_normalized_expansion_degree_node(node.right_expr)\n        #     )\n        #     if right_degree == \"NaN\" or right_result == \"NaN\":\n        #         return \"NaN\", \"NaN\"\n        #     cur_result = node.operator.get_compute_function()(left_result, right_result)\n        #     cur_degree = node.operator.get_count_function()(left_result, right_result)\n        #     if cur_degree == \"NaN\" or cur_result == \"NaN\":\n        #         return \"NaN\", \"NaN\"\n        #     return cur_degree + left_degree + right_degree, cur_result\n        # elif isinstance(node, VariableNode):\n        #     return \"NaN\", \"NaN\"\n        # else:\n        #     raise NotImplementedError(\n        #         \"ExpressionEvaluator.calculate_normalized_expansion_degree_node\"\n        #     )\n\n        digits = self.base_converter.get_digits()\n\n\n\n        def check_carry(input: List[int], output: int):\n            pass\n        special_values = [float(\"inf\"), float(\"-inf\")]\n        try:\n            if isinstance(node, NumberNode):\n                self.cot_info.append(\n                    {\n                        \"info\": f\"number node, value={node.value}\",\n                        \"layer\": cot_layer,\n                    }\n                )\n                return 0, node.value\n            elif isinstance(node, UnaryExpressionNode):\n                sub_degree, sub_result = (\n                    self.calculate_normalized_expansion_degree_node(\n                        node.unary_expr, cot_layer=cot_layer + 1\n                    )\n                )\n                # print(f\"in compute, {node.operator.id}\")\n                # cur_result = getattr(op_func, f\"op_{node.operator.id}\")(sub_result)\n                # cur_degree = getattr(op_func, f\"op_count_{node.operator.id}\")(sub_result)\n\n                # cur_result = node.operator.get_compute_function()(sub_result)\n                # cur_degree = node.operator.get_count_function()(sub_result)\n                compute_func,count_func=self.get_compute_count_func(node.operator)\n\n                cur_result = compute_func(sub_result)\n                cur_degree = count_func(sub_result)\n\n                if self.longer_result_info and self.longer_result_info.flag == False:\n                    # if get a longer result by target base, set the flag to True\n                    if cur_result == float(\"inf\") or cur_result == float(\"-inf\") or sub_result == float(\"inf\") or sub_result == float(\"-inf\") or cur_result != cur_result or sub_result != sub_result:\n                        self.longer_result_info.flag = False # TODO: check this\n                    else:\n                        cur_result_str = self.base_converter.convert(\n                            number=int(cur_result), base=self.longer_result_info.target_base\n                        )\n                        sub_result_str = self.base_converter.convert(\n                            number=int(sub_result), base=self.longer_result_info.target_base\n                        )\n                        if len(cur_result_str) &gt; len(sub_result_str):\n                            self.longer_result_info.flag = True\n\n                self.cot_info.append({\n                    \"info\":f\"compute unary expreesion, input={sub_result}, op_id = {node.operator.func_id}, unary_op_definition = '{node.operator.definition}', output={cur_result}\",\"layer\":cot_layer}\n                )\n\n                # prepare for cot\n                cur_result_str_with_base = self.get_target_base_str(value = cur_result,target_base = self.longer_result_info.target_base)\n                sub_result_str_with_base = self.get_target_base_str(value = sub_result,target_base = self.longer_result_info.target_base)\n\n                if node.operator.unary_position==\"prefix\":\n                    self.cot.append({\"info\":f\"{node.operator.symbol}{sub_result_str_with_base}={cur_result_str_with_base}\",\"layer\":cot_layer})\n                elif node.operator.unary_position==\"postfix\":\n                    self.cot.append({\"info\":f\"{sub_result_str_with_base}{node.operator.symbol}={cur_result_str_with_base}\",\"layer\":cot_layer})\n\n                if cur_result !=cur_result or cur_result in special_values:\n                    pass\n                else:\n                    cur_result = int(cur_result)\n                return cur_degree + sub_degree, cur_result\n            elif isinstance(node, BinaryExpressionNode):\n                # \u4e8c\u5143\u64cd\u4f5c\u7b26\uff0c\u5206\u522b\u8ba1\u7b97\u5de6\u53f3\u5b50\u6811\u7684\u5f52\u4e00\u5c55\u5f00\u5ea6\n                left_degree, left_result = (\n                    self.calculate_normalized_expansion_degree_node(\n                        node.left_expr, cot_layer=cot_layer + 1\n                    )\n                )\n                right_degree, right_result = (\n                    self.calculate_normalized_expansion_degree_node(\n                        node.right_expr, cot_layer=cot_layer + 1\n                    )\n                )\n\n                # print(f\"in compute, {node.operator.id}\")\n                # cur_result = getattr(op_func, f\"op_{node.operator.id}\")(left_result, right_result)\n                # cur_degree = getattr(op_func, f\"op_count_{node.operator.id}\")(left_result, right_result)\n                compute_func,count_func=self.get_compute_count_func(node.operator)\n\n                cur_result = compute_func(left_result, right_result)\n                cur_degree = count_func(left_result, right_result)\n                # cur_result = node.operator.get_compute_function()(\n                #     left_result, right_result\n                # )\n                # cur_degree = node.operator.get_count_function()(\n                #     left_result, right_result\n                # )\n                if self.longer_result_info and self.longer_result_info.flag == False:\n                    if cur_result == float(\"inf\") or cur_result == float(\"-inf\") or left_result == float(\"inf\") or left_result == float(\"-inf\") or right_result == float(\"inf\") or right_result == float(\"-inf\") or cur_result != cur_result or left_result != left_result or right_result != right_result:\n                        self.longer_result_info.flag = False\n                    else:\n                    # if get a longer result by target base, set the flag to True\n                        cur_result_str = self.base_converter.convert(\n                            number=int(cur_result), base=self.longer_result_info.target_base\n                        )\n                        left_result_str = self.base_converter.convert(\n                            number=int(left_result), base=self.longer_result_info.target_base\n                        )\n                        right_result_str = self.base_converter.convert(\n                            number=int(right_result), base=self.longer_result_info.target_base\n                        )\n                        if len(cur_result_str) &gt; len(left_result_str) and len(\n                            cur_result_str\n                        ) &gt; len(right_result_str):\n                            self.longer_result_info.flag = True\n\n                self.cot_info.append(\n                    {\n                        \"info\": f\"compute binary expreesion, left_input={left_result}, right_input={right_result}, op_id = {node.operator.func_id} binary_op_definition= '{node.operator.definition}', output={cur_result}\",\n                        \"layer\": cot_layer,\n                    }\n                )\n                # prepare for cot\n                left_result_str_with_base = self.get_target_base_str(value = left_result,target_base = self.longer_result_info.target_base)\n                right_result_str_with_base = self.get_target_base_str(value = right_result,target_base = self.longer_result_info.target_base)\n                cur_result_str_with_base = self.get_target_base_str(value = cur_result,target_base = self.longer_result_info.target_base)\n\n                self.cot.append({ \"info\": f\"{left_result_str_with_base}{node.operator.symbol}{right_result_str_with_base}={cur_result_str_with_base}\",\"layer\": cot_layer,})\n\n                if cur_result !=cur_result or cur_result in special_values:\n                    pass\n                else:\n                    cur_result = int(cur_result)\n                return cur_degree + left_degree + right_degree, cur_result\n            elif isinstance(node, VariableNode):\n                return float(\"nan\"), float(\"nan\")\n            else:\n                raise NotImplementedError(\n                    \"ExpressionEvaluator.calculate_normalized_expansion_degree_node\"\n                )\n        except Exception as e:\n            # print(f\"node: {node.operator.id}\")\n            if isinstance(node, BinaryExpressionNode):\n                self.logger.error(f\"Error in ExpressionEvaluator.tree_to_str: {e},cur_result={cur_result},left_result={left_result},right_result={right_result}\")\n            elif isinstance(node,UnaryExpressionNode):\n                self.logger.error(f\"Error in ExpressionEvaluator.tree_to_str: {e},cur_result={cur_result},sub_result={sub_result}\")\n            else:\n                self.logger.error(f\"Error in ExpressionEvaluator.tree_to_str: {e}\")\n            raise e\n\n    def calculate_operation_count(self):\n        \"\"\"\n        Calculates the total number of operations in the expression.\n\n        This method returns the count of all operations that were encountered during the construction of the expression tree.\n\n        Returns:\n            (int): The operation count as an integer.\n        \"\"\"\n        return self.operation_count\n\n    def all_dependent_operators(self)-&gt;List:\n        used_ops_func_id = list(self.all_operators.keys())\n        dependent_ops = []\n        for op_func_id in used_ops_func_id:\n            if self.operator_manager.get_operator_by_func_id(op_func_id=op_func_id).dependencies!=None:\n                dependent_ops += self.operator_manager.get_operator_by_func_id(op_func_id=op_func_id).dependencies\n        return dependent_ops\n\n    def number_count(self)-&gt;int:\n        return self.number_count\n\n    def calculate_complexity_ratio(self):\n        \"\"\"\n        Calculates the complexity ratio based on normalized expansion degree and operation count.\n\n        The complexity ratio provides a measure of how complex the expression is relative to the number of operations it contains.\n        It is calculated by dividing the normalized expansion degree by the operation count.\n\n        Returns:\n            (int): The complexity ratio as a floating-point number. Returns 0 if the operation count is 0 or the expansion degree is \"NaN\".\n        \"\"\"\n        operation_count = self.calculate_operation_count()\n        normalized_expansion_degree = self.calculate_normalized_expansion_degree()\n        return (\n            normalized_expansion_degree / operation_count\n            if operation_count &gt; 0 and normalized_expansion_degree != \"NaN\"\n            else 0\n        )\n\n    # def calculate_max_digit_count(self):\n    #     \"\"\"\n    #     Calculates the maximum digit count in the expression string.\n\n    #     This method extracts all numbers from the expression string, converts them to integers, and determines the length of the largest number.\n\n    #     Returns:\n    #         (int): The maximum digit count as an integer. Returns 0 if there are no digits in the expression string.\n    #     \"\"\"\n    #     numbers = [int(num) for num in self.expression_str.split() if num.isdigit()]\n    #     return max((len(str(num)) for num in numbers), default=0)\n    def get_base(self):\n        if self.param_config.get(\"random_base\")[\"flag\"]==False:\n            return self.param_config.get(\"random_base\")[\"base\"]\n        else:\n            return None\n    def evaluate(self):\n        \"\"\"\n        Evaluates the expression and returns its properties.\n\n        This method aggregates various metrics about the expression, such as its highest n-order, hierarchical complexity,\n        normalized expansion degree, operation count, complexity ratio, maximum digit count, and result.\n\n        Returns:\n            (dict): A dictionary containing various properties of the evaluated expression.\n        \"\"\"\n        return {\n            \"id\": self.id,\n            \"expression_no_base_symbol\": self.expression_str_no_base_symbol,\n            \"expression\": self.expression_str,\n            \"highest_n_order\": self.calculate_highest_n_order(),\n            \"priority_hierarchical_complexity\": self.calculate_priority_hierarchical_complexity(),\n            \"normalized_expansion_degree\": self.calculate_normalized_expansion_degree(),\n            \"operation_count\": self.calculate_operation_count(),\n            \"complexity_ratio\": self.calculate_complexity_ratio(),\n            # \"max_digit_count\": self.calculate_max_digit_count(),\n            \"tree\": self.expression_tree.to_dict(),\n            \"used_operators\": list(self.all_operators.keys()),\n            \"dependent_operators\": self.all_dependent_operators(),\n            \"result\": self.calculate_result(),\n            \"longer_result_info\": asdict(self.longer_result_info),\n            \"cot_info\": self.cot_info,\n            \"base\": self.get_base(),\n            \"result_base\": self.expr_result_base,\n            \"text\": f\"{self.expression_str}={self.calculate_result()}\",\n            \"cot\": self.cot,\n        }\n</code></pre>"},{"location":"expression/expression_evaluator/#opulse.expression.expression_evaluator.ExpressionEvaluator.__init__","title":"<code>__init__(param_config, logger, cython_cache_dir, operator_manager, base_converter=None)</code>","text":"<p>Initializes an instance of the ExpressionEvaluator class.</p> <p>This constructor sets up the expression evaluator with necessary configurations and managers. It initializes attributes to manage expression trees, operators, logging, and base conversions. Additionally, it prepares data structures to track operator priorities, operation counts, and highest n-order values.</p> <p>Parameters:</p> Name Type Description Default <code>param_config</code> <code>ParamConfig</code> <p>Configuration settings for controlling the behavior of the expression evaluator.</p> required <code>logger</code> <code>LogConfig</code> <p>Configuration for setting up logging. Used to create a logger instance for this evaluator.</p> required <code>operator_manager</code> <code>OperatorManager</code> <p>Manager object that provides information about operators used in expressions.</p> required <code>base_converter</code> <code>BaseConverter</code> <p>Converter object for handling different numerical bases in expressions. Defaults to None.</p> <code>None</code> Source code in <code>opulse/expression/expression_evaluator.py</code> <pre><code>def __init__(\n    self,\n    param_config: ParamConfig,\n    logger: LogConfig,\n    cython_cache_dir: str,\n    operator_manager: OperatorManager,\n    base_converter: BaseConverter = None,\n):\n    \"\"\"\n    Initializes an instance of the ExpressionEvaluator class.\n\n    This constructor sets up the expression evaluator with necessary configurations and managers.\n    It initializes attributes to manage expression trees, operators, logging, and base conversions.\n    Additionally, it prepares data structures to track operator priorities, operation counts, and highest n-order values.\n\n    Parameters:\n        param_config (ParamConfig): Configuration settings for controlling the behavior of the expression evaluator.\n        logger (LogConfig): Configuration for setting up logging. Used to create a logger instance for this evaluator.\n        operator_manager (OperatorManager): Manager object that provides information about operators used in expressions.\n        base_converter (BaseConverter, optional): Converter object for handling different numerical bases in expressions. Defaults to None.\n    \"\"\"\n    self.param_config = param_config\n    self.logger = logger.get_logger()\n    # Initialization of relevant expressions to None\n    self.id = None\n    self.expression_tree: ExpressionNode = None\n    self.expression_str: str = None\n    self.operator_manager = operator_manager\n    self.base_converter = base_converter\n    self.all_priority = []\n    self.operation_count = 0\n    self.highest_n_order = 0\n    # Record all operators key: op id, value: number of occurrences\n    self.all_operators: Dict[str, int] = defaultdict(int)\n    self.with_all_brackets = False\n    self.cython_cache_dir = cython_cache_dir\n    # Used to replace meta words in expression strings\n    self.load_atoms()\n</code></pre>"},{"location":"expression/expression_evaluator/#opulse.expression.expression_evaluator.ExpressionEvaluator.calculate_complexity_ratio","title":"<code>calculate_complexity_ratio()</code>","text":"<p>Calculates the complexity ratio based on normalized expansion degree and operation count.</p> <p>The complexity ratio provides a measure of how complex the expression is relative to the number of operations it contains. It is calculated by dividing the normalized expansion degree by the operation count.</p> <p>Returns:</p> Type Description <code>int</code> <p>The complexity ratio as a floating-point number. Returns 0 if the operation count is 0 or the expansion degree is \"NaN\".</p> Source code in <code>opulse/expression/expression_evaluator.py</code> <pre><code>def calculate_complexity_ratio(self):\n    \"\"\"\n    Calculates the complexity ratio based on normalized expansion degree and operation count.\n\n    The complexity ratio provides a measure of how complex the expression is relative to the number of operations it contains.\n    It is calculated by dividing the normalized expansion degree by the operation count.\n\n    Returns:\n        (int): The complexity ratio as a floating-point number. Returns 0 if the operation count is 0 or the expansion degree is \"NaN\".\n    \"\"\"\n    operation_count = self.calculate_operation_count()\n    normalized_expansion_degree = self.calculate_normalized_expansion_degree()\n    return (\n        normalized_expansion_degree / operation_count\n        if operation_count &gt; 0 and normalized_expansion_degree != \"NaN\"\n        else 0\n    )\n</code></pre>"},{"location":"expression/expression_evaluator/#opulse.expression.expression_evaluator.ExpressionEvaluator.calculate_highest_n_order","title":"<code>calculate_highest_n_order()</code>","text":"<p>Calculates the highest n-order of the expression.</p> <p>Returns:</p> Type Description <code>int</code> <p>The highest n-order value.</p> Source code in <code>opulse/expression/expression_evaluator.py</code> <pre><code>def calculate_highest_n_order(self) -&gt; int:\n    \"\"\"\n    Calculates the highest n-order of the expression.\n\n    Returns:\n        (int): The highest n-order value.\n    \"\"\"\n    return self.highest_n_order\n</code></pre>"},{"location":"expression/expression_evaluator/#opulse.expression.expression_evaluator.ExpressionEvaluator.calculate_normalized_expansion_degree","title":"<code>calculate_normalized_expansion_degree()</code>","text":"<p>Calculates the normalized expansion degree of the expression.</p> <p>Returns:</p> Type Description <code>int</code> <p>The normalized expansion degree or \"NaN\".</p> Source code in <code>opulse/expression/expression_evaluator.py</code> <pre><code>def calculate_normalized_expansion_degree(self) -&gt; Union[int, str]:\n    # Implementing the computational logic for normalized expansion degree\n    \"\"\"\n    Calculates the normalized expansion degree of the expression.\n\n    Returns:\n        (int): The normalized expansion degree or \"NaN\".\n    \"\"\"\n    normalized_expansion_degree = self.normalized_expansion_degree\n    if self.normalized_expansion_degree is not None:\n        # return (\n        #     self.normalized_expansion_degree\n        #     if self.normalized_expansion_degree != \"NaN\"\n        #     else self.atoms[\"NaN\"]\n        # )\n        normalized_expansion_degree = self.normalized_expansion_degree\n    else:\n        degree, result = self.calculate_normalized_expansion_degree_node(\n            self.expression_tree\n        )\n        self.normalized_expansion_degree = degree\n        self.expr_result = result\n        normalized_expansion_degree = degree\n\n    if normalized_expansion_degree != normalized_expansion_degree:\n        return self.atoms[\"NaN\"]\n    elif normalized_expansion_degree == float(\"inf\"):\n        return self.atoms[\"Inf\"]\n    elif normalized_expansion_degree == float(\"-inf\"):\n        return self.atoms[\"-Inf\"]\n    else:\n        return self.normalized_expansion_degree\n</code></pre>"},{"location":"expression/expression_evaluator/#opulse.expression.expression_evaluator.ExpressionEvaluator.calculate_normalized_expansion_degree_node","title":"<code>calculate_normalized_expansion_degree_node(node, cot_layer=0)</code>","text":"<p>Helper method to recursively calculate the normalized expansion degree for each node in the expression tree.</p> <p>This method traverses the expression tree and computes the degree based on the type and structure of nodes.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>ExpressionNode</code> <p>The current node in the expression tree.</p> required <p>Returns:</p> Type Description <code>Tuple[Union[int, str], Union[int, str]]</code> <p>A tuple containing the normalized expansion degree and the evaluation result of the node.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the node type is not recognized.</p> Source code in <code>opulse/expression/expression_evaluator.py</code> <pre><code>def calculate_normalized_expansion_degree_node(\n    self, node: ExpressionNode, cot_layer: int = 0\n) -&gt; Tuple[Union[int, str], Union[int, str]]:\n    \"\"\"\n    Helper method to recursively calculate the normalized expansion degree for each node in the expression tree.\n\n    This method traverses the expression tree and computes the degree based on the type and structure of nodes.\n\n    Args:\n        node (ExpressionNode): The current node in the expression tree.\n\n    Returns:\n        (Tuple[Union[int, str], Union[int, str]]): A tuple containing the normalized expansion degree and the evaluation result of the node.\n\n    Raises:\n        NotImplementedError: If the node type is not recognized.\n\n    \"\"\"\n    # For a single expression tree node, compute the normalized expansion of the tree rooted at this node and the resultant\n    # if isinstance(node, NumberNode):\n    #     return 0, node.value\n    # elif isinstance(node, UnaryExpressionNode):\n    #     sub_degree, sub_result = self.calculate_normalized_expansion_degree_node(\n    #         node.unary_expr\n    #     )\n    #     if sub_degree == \"NaN\" or sub_result == \"NaN\":\n    #         return \"NaN\", \"NaN\"\n    #     cur_result = node.operator.get_compute_function()(sub_result)\n    #     cur_degree = node.operator.get_count_function()(sub_result)\n    #     if cur_degree == \"NaN\" or cur_result == \"NaN\":\n    #         return \"NaN\", \"NaN\"\n    #     return cur_degree + sub_degree, cur_result\n    # elif isinstance(node, BinaryExpressionNode):\n    #     # \u4e8c\u5143\u64cd\u4f5c\u7b26\uff0c\u5206\u522b\u8ba1\u7b97\u5de6\u53f3\u5b50\u6811\u7684\u5f52\u4e00\u5c55\u5f00\u5ea6\n    #     left_degree, left_result = self.calculate_normalized_expansion_degree_node(\n    #         node.left_expr\n    #     )\n    #     if left_degree == \"NaN\" or left_result == \"NaN\":\n    #         return \"NaN\", \"NaN\"\n    #     right_degree, right_result = (\n    #         self.calculate_normalized_expansion_degree_node(node.right_expr)\n    #     )\n    #     if right_degree == \"NaN\" or right_result == \"NaN\":\n    #         return \"NaN\", \"NaN\"\n    #     cur_result = node.operator.get_compute_function()(left_result, right_result)\n    #     cur_degree = node.operator.get_count_function()(left_result, right_result)\n    #     if cur_degree == \"NaN\" or cur_result == \"NaN\":\n    #         return \"NaN\", \"NaN\"\n    #     return cur_degree + left_degree + right_degree, cur_result\n    # elif isinstance(node, VariableNode):\n    #     return \"NaN\", \"NaN\"\n    # else:\n    #     raise NotImplementedError(\n    #         \"ExpressionEvaluator.calculate_normalized_expansion_degree_node\"\n    #     )\n\n    digits = self.base_converter.get_digits()\n\n\n\n    def check_carry(input: List[int], output: int):\n        pass\n    special_values = [float(\"inf\"), float(\"-inf\")]\n    try:\n        if isinstance(node, NumberNode):\n            self.cot_info.append(\n                {\n                    \"info\": f\"number node, value={node.value}\",\n                    \"layer\": cot_layer,\n                }\n            )\n            return 0, node.value\n        elif isinstance(node, UnaryExpressionNode):\n            sub_degree, sub_result = (\n                self.calculate_normalized_expansion_degree_node(\n                    node.unary_expr, cot_layer=cot_layer + 1\n                )\n            )\n            # print(f\"in compute, {node.operator.id}\")\n            # cur_result = getattr(op_func, f\"op_{node.operator.id}\")(sub_result)\n            # cur_degree = getattr(op_func, f\"op_count_{node.operator.id}\")(sub_result)\n\n            # cur_result = node.operator.get_compute_function()(sub_result)\n            # cur_degree = node.operator.get_count_function()(sub_result)\n            compute_func,count_func=self.get_compute_count_func(node.operator)\n\n            cur_result = compute_func(sub_result)\n            cur_degree = count_func(sub_result)\n\n            if self.longer_result_info and self.longer_result_info.flag == False:\n                # if get a longer result by target base, set the flag to True\n                if cur_result == float(\"inf\") or cur_result == float(\"-inf\") or sub_result == float(\"inf\") or sub_result == float(\"-inf\") or cur_result != cur_result or sub_result != sub_result:\n                    self.longer_result_info.flag = False # TODO: check this\n                else:\n                    cur_result_str = self.base_converter.convert(\n                        number=int(cur_result), base=self.longer_result_info.target_base\n                    )\n                    sub_result_str = self.base_converter.convert(\n                        number=int(sub_result), base=self.longer_result_info.target_base\n                    )\n                    if len(cur_result_str) &gt; len(sub_result_str):\n                        self.longer_result_info.flag = True\n\n            self.cot_info.append({\n                \"info\":f\"compute unary expreesion, input={sub_result}, op_id = {node.operator.func_id}, unary_op_definition = '{node.operator.definition}', output={cur_result}\",\"layer\":cot_layer}\n            )\n\n            # prepare for cot\n            cur_result_str_with_base = self.get_target_base_str(value = cur_result,target_base = self.longer_result_info.target_base)\n            sub_result_str_with_base = self.get_target_base_str(value = sub_result,target_base = self.longer_result_info.target_base)\n\n            if node.operator.unary_position==\"prefix\":\n                self.cot.append({\"info\":f\"{node.operator.symbol}{sub_result_str_with_base}={cur_result_str_with_base}\",\"layer\":cot_layer})\n            elif node.operator.unary_position==\"postfix\":\n                self.cot.append({\"info\":f\"{sub_result_str_with_base}{node.operator.symbol}={cur_result_str_with_base}\",\"layer\":cot_layer})\n\n            if cur_result !=cur_result or cur_result in special_values:\n                pass\n            else:\n                cur_result = int(cur_result)\n            return cur_degree + sub_degree, cur_result\n        elif isinstance(node, BinaryExpressionNode):\n            # \u4e8c\u5143\u64cd\u4f5c\u7b26\uff0c\u5206\u522b\u8ba1\u7b97\u5de6\u53f3\u5b50\u6811\u7684\u5f52\u4e00\u5c55\u5f00\u5ea6\n            left_degree, left_result = (\n                self.calculate_normalized_expansion_degree_node(\n                    node.left_expr, cot_layer=cot_layer + 1\n                )\n            )\n            right_degree, right_result = (\n                self.calculate_normalized_expansion_degree_node(\n                    node.right_expr, cot_layer=cot_layer + 1\n                )\n            )\n\n            # print(f\"in compute, {node.operator.id}\")\n            # cur_result = getattr(op_func, f\"op_{node.operator.id}\")(left_result, right_result)\n            # cur_degree = getattr(op_func, f\"op_count_{node.operator.id}\")(left_result, right_result)\n            compute_func,count_func=self.get_compute_count_func(node.operator)\n\n            cur_result = compute_func(left_result, right_result)\n            cur_degree = count_func(left_result, right_result)\n            # cur_result = node.operator.get_compute_function()(\n            #     left_result, right_result\n            # )\n            # cur_degree = node.operator.get_count_function()(\n            #     left_result, right_result\n            # )\n            if self.longer_result_info and self.longer_result_info.flag == False:\n                if cur_result == float(\"inf\") or cur_result == float(\"-inf\") or left_result == float(\"inf\") or left_result == float(\"-inf\") or right_result == float(\"inf\") or right_result == float(\"-inf\") or cur_result != cur_result or left_result != left_result or right_result != right_result:\n                    self.longer_result_info.flag = False\n                else:\n                # if get a longer result by target base, set the flag to True\n                    cur_result_str = self.base_converter.convert(\n                        number=int(cur_result), base=self.longer_result_info.target_base\n                    )\n                    left_result_str = self.base_converter.convert(\n                        number=int(left_result), base=self.longer_result_info.target_base\n                    )\n                    right_result_str = self.base_converter.convert(\n                        number=int(right_result), base=self.longer_result_info.target_base\n                    )\n                    if len(cur_result_str) &gt; len(left_result_str) and len(\n                        cur_result_str\n                    ) &gt; len(right_result_str):\n                        self.longer_result_info.flag = True\n\n            self.cot_info.append(\n                {\n                    \"info\": f\"compute binary expreesion, left_input={left_result}, right_input={right_result}, op_id = {node.operator.func_id} binary_op_definition= '{node.operator.definition}', output={cur_result}\",\n                    \"layer\": cot_layer,\n                }\n            )\n            # prepare for cot\n            left_result_str_with_base = self.get_target_base_str(value = left_result,target_base = self.longer_result_info.target_base)\n            right_result_str_with_base = self.get_target_base_str(value = right_result,target_base = self.longer_result_info.target_base)\n            cur_result_str_with_base = self.get_target_base_str(value = cur_result,target_base = self.longer_result_info.target_base)\n\n            self.cot.append({ \"info\": f\"{left_result_str_with_base}{node.operator.symbol}{right_result_str_with_base}={cur_result_str_with_base}\",\"layer\": cot_layer,})\n\n            if cur_result !=cur_result or cur_result in special_values:\n                pass\n            else:\n                cur_result = int(cur_result)\n            return cur_degree + left_degree + right_degree, cur_result\n        elif isinstance(node, VariableNode):\n            return float(\"nan\"), float(\"nan\")\n        else:\n            raise NotImplementedError(\n                \"ExpressionEvaluator.calculate_normalized_expansion_degree_node\"\n            )\n    except Exception as e:\n        # print(f\"node: {node.operator.id}\")\n        if isinstance(node, BinaryExpressionNode):\n            self.logger.error(f\"Error in ExpressionEvaluator.tree_to_str: {e},cur_result={cur_result},left_result={left_result},right_result={right_result}\")\n        elif isinstance(node,UnaryExpressionNode):\n            self.logger.error(f\"Error in ExpressionEvaluator.tree_to_str: {e},cur_result={cur_result},sub_result={sub_result}\")\n        else:\n            self.logger.error(f\"Error in ExpressionEvaluator.tree_to_str: {e}\")\n        raise e\n</code></pre>"},{"location":"expression/expression_evaluator/#opulse.expression.expression_evaluator.ExpressionEvaluator.calculate_operation_count","title":"<code>calculate_operation_count()</code>","text":"<p>Calculates the total number of operations in the expression.</p> <p>This method returns the count of all operations that were encountered during the construction of the expression tree.</p> <p>Returns:</p> Type Description <code>int</code> <p>The operation count as an integer.</p> Source code in <code>opulse/expression/expression_evaluator.py</code> <pre><code>def calculate_operation_count(self):\n    \"\"\"\n    Calculates the total number of operations in the expression.\n\n    This method returns the count of all operations that were encountered during the construction of the expression tree.\n\n    Returns:\n        (int): The operation count as an integer.\n    \"\"\"\n    return self.operation_count\n</code></pre>"},{"location":"expression/expression_evaluator/#opulse.expression.expression_evaluator.ExpressionEvaluator.calculate_priority_hierarchical_complexity","title":"<code>calculate_priority_hierarchical_complexity()</code>","text":"<p>Calculates the priority-based hierarchical complexity.</p> <p>Returns:</p> Type Description <code>int</code> <p>The complexity value.</p> Source code in <code>opulse/expression/expression_evaluator.py</code> <pre><code>def calculate_priority_hierarchical_complexity(self) -&gt; int:\n    \"\"\"\n    Calculates the priority-based hierarchical complexity.\n\n    Returns:\n        (int): The complexity value.\n    \"\"\"\n    return len(self.all_priority)\n</code></pre>"},{"location":"expression/expression_evaluator/#opulse.expression.expression_evaluator.ExpressionEvaluator.calculate_result","title":"<code>calculate_result()</code>","text":"<p>Calculates the normalized expansion degree of the expression.</p> <p>The normalized expansion degree is a measure that represents how much an expression has been expanded or simplified. It can be used to evaluate the complexity of the expression in terms of its structure and size after operations.</p> <p>Returns:</p> Type Description <code>Union[int, str]</code> <p>The normalized expansion degree or \"NaN\".s an integer or \"NaN\" if it cannot be calculated.</p> Source code in <code>opulse/expression/expression_evaluator.py</code> <pre><code>def calculate_result(self) -&gt; Union[str, int]:\n    \"\"\"\n    Calculates the normalized expansion degree of the expression.\n\n    The normalized expansion degree is a measure that represents how much an expression has been expanded or simplified.\n    It can be used to evaluate the complexity of the expression in terms of its structure and size after operations.\n\n    Returns:\n        (Union[int, str]): The normalized expansion degree or \"NaN\".s an integer or \"NaN\" if it cannot be calculated.\n    \"\"\"\n    expr_result = None\n    if self.expr_result is not None:\n        expr_result = self.expr_result\n        # return self.expr_result if self.expr_result != \"NaN\" else self.atoms[\"NaN\"]\n    else:\n        degree, result = self.calculate_normalized_expansion_degree_node(\n            self.expression_tree\n        )\n        self.normalized_expansion_degree = degree\n        self.expr_result = result\n        expr_result = result\n        # return self.expr_result if self.expr_result != \"NaN\" else self.atoms[\"NaN\"]\n\n    if self.expr_result_base != None and type(expr_result) == int:\n        return ExpressionBaseConverter.convert_int_to_targetbase(\n            input=expr_result,\n            output_base=self.expr_result_base,\n            base_converter=self.base_converter,\n            operator_manager=self.operator_manager,\n        )\n    elif expr_result != expr_result:\n        return self.atoms[\"NaN\"]\n    elif expr_result == float(\"inf\"):\n        return self.atoms[\"Inf\"]\n    elif expr_result == float(\"-inf\"):\n        return self.atoms[\"-Inf\"]\n    else:\n        return expr_result\n</code></pre>"},{"location":"expression/expression_evaluator/#opulse.expression.expression_evaluator.ExpressionEvaluator.evaluate","title":"<code>evaluate()</code>","text":"<p>Evaluates the expression and returns its properties.</p> <p>This method aggregates various metrics about the expression, such as its highest n-order, hierarchical complexity, normalized expansion degree, operation count, complexity ratio, maximum digit count, and result.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing various properties of the evaluated expression.</p> Source code in <code>opulse/expression/expression_evaluator.py</code> <pre><code>def evaluate(self):\n    \"\"\"\n    Evaluates the expression and returns its properties.\n\n    This method aggregates various metrics about the expression, such as its highest n-order, hierarchical complexity,\n    normalized expansion degree, operation count, complexity ratio, maximum digit count, and result.\n\n    Returns:\n        (dict): A dictionary containing various properties of the evaluated expression.\n    \"\"\"\n    return {\n        \"id\": self.id,\n        \"expression_no_base_symbol\": self.expression_str_no_base_symbol,\n        \"expression\": self.expression_str,\n        \"highest_n_order\": self.calculate_highest_n_order(),\n        \"priority_hierarchical_complexity\": self.calculate_priority_hierarchical_complexity(),\n        \"normalized_expansion_degree\": self.calculate_normalized_expansion_degree(),\n        \"operation_count\": self.calculate_operation_count(),\n        \"complexity_ratio\": self.calculate_complexity_ratio(),\n        # \"max_digit_count\": self.calculate_max_digit_count(),\n        \"tree\": self.expression_tree.to_dict(),\n        \"used_operators\": list(self.all_operators.keys()),\n        \"dependent_operators\": self.all_dependent_operators(),\n        \"result\": self.calculate_result(),\n        \"longer_result_info\": asdict(self.longer_result_info),\n        \"cot_info\": self.cot_info,\n        \"base\": self.get_base(),\n        \"result_base\": self.expr_result_base,\n        \"text\": f\"{self.expression_str}={self.calculate_result()}\",\n        \"cot\": self.cot,\n    }\n</code></pre>"},{"location":"expression/expression_evaluator/#opulse.expression.expression_evaluator.ExpressionEvaluator.init_expr","title":"<code>init_expr(expression_tree, id, op_mode=False, expr_result_base=None, longer_result_info=None)</code>","text":"<p>Initializes expression attributes with an expression tree and ID.</p> <p>This method sets up the initial state for an expression by assigning an identifier and an expression tree. It also initializes counters and dictionaries that will be used to track various properties of the expression, such as operator priorities, operation counts, and operator occurrences. Finally, it generates string representations of the expression based on the provided tree structure and optional parameters.</p> <p>Parameters:</p> Name Type Description Default <code>expression_tree</code> <code>ExpressionNode</code> <p>The root node of the expression tree to initialize.</p> required <code>id</code> <code>any</code> <p>An identifier for the expression, which can be any type that uniquely identifies the expression.</p> required <code>op_mode</code> <code>bool</code> <p>A flag indicating whether the expression should be processed in operator mode. Defaults to False.</p> <code>False</code> Source code in <code>opulse/expression/expression_evaluator.py</code> <pre><code>def init_expr(\n    self,\n    expression_tree,\n    id,\n    op_mode: bool = False,\n    expr_result_base: int = None,\n    longer_result_info: LongerResultInfo = None,\n):\n    \"\"\"\n    Initializes expression attributes with an expression tree and ID.\n\n    This method sets up the initial state for an expression by assigning an identifier and an expression tree.\n    It also initializes counters and dictionaries that will be used to track various properties of the expression,\n    such as operator priorities, operation counts, and operator occurrences. Finally, it generates string representations\n    of the expression based on the provided tree structure and optional parameters.\n\n    Parameters:\n        expression_tree (ExpressionNode): The root node of the expression tree to initialize.\n        id (any): An identifier for the expression, which can be any type that uniquely identifies the expression.\n        op_mode (bool, optional): A flag indicating whether the expression should be processed in operator mode. Defaults to False.\n    \"\"\"\n    self.id = id\n    self.expression_tree = expression_tree\n    self.cot_info: List[str] = []\n    self.cot: List[str] = []\n    self.all_priority = []\n    self.operation_count = 0\n    self.number_count = 0\n    self.variable_count = 0\n    self.highest_n_order = 0\n    self.expr_result = None\n    self.normalized_expansion_degree = None\n    self.all_operators: Dict[str, int] = defaultdict(int)\n    self.expr_result_base = expr_result_base\n    self.longer_result_info = longer_result_info\n    if op_mode:\n        self.expression_str = self.tree_to_str(self.expression_tree, op_mode=True)\n    else:\n        self.expression_str = self.tree_to_str(self.expression_tree, statistic_analysis=True)\n        self.expression_str_no_base_symbol = self.tree_to_str(\n            self.expression_tree, with_base_symbol=False\n        )\n</code></pre>"},{"location":"expression/expression_evaluator/#opulse.expression.expression_evaluator.ExpressionEvaluator.load_atoms","title":"<code>load_atoms()</code>","text":"<p>Loads atomic symbols from the parameter configuration.</p> Source code in <code>opulse/expression/expression_evaluator.py</code> <pre><code>def load_atoms(self) -&gt; None:\n    \"\"\"\n    Loads atomic symbols from the parameter configuration.\n    \"\"\"\n    self.atoms = {\n        \"left_bracket\": self.param_config.get(\"other_symbols_atoms\")[\n            \"left_parenthesis\"\n        ],\n        \"right_bracket\": self.param_config.get(\"other_symbols_atoms\")[\n            \"right_parenthesis\"\n        ],\n        \"NaN\": self.param_config.get(\"other_symbols_atoms\")[\"nan_symbol\"],\n        \"equal\": self.param_config.get(\"other_symbols_atoms\")[\"equals_sign\"],\n        \"Inf\": self.param_config.get(\"other_symbols_atoms\")[\"inf_symbol\"],\n        \"-Inf\": self.param_config.get(\"other_symbols_atoms\")[\"neg_inf_symbol\"],\n    }\n</code></pre>"},{"location":"expression/expression_evaluator/#opulse.expression.expression_evaluator.ExpressionEvaluator.set_with_all_brackets","title":"<code>set_with_all_brackets(with_all_brackets)</code>","text":"<p>Sets whether to include all brackets in the expression string.</p> <p>This method configures the behavior for generating expression strings. If set to True, it ensures that all parts of the expression that require parentheses for correct order of operations will be enclosed in brackets. This can be useful for ensuring clarity or for specific formatting requirements.</p> <p>Parameters:</p> Name Type Description Default <code>with_all_brackets</code> <code>bool</code> <p>A flag indicating whether to include all necessary brackets in the expression string.</p> required Source code in <code>opulse/expression/expression_evaluator.py</code> <pre><code>def set_with_all_brackets(self, with_all_brackets: bool) -&gt; None:\n    \"\"\"\n    Sets whether to include all brackets in the expression string.\n\n    This method configures the behavior for generating expression strings. If set to True, it ensures that all parts of the\n    expression that require parentheses for correct order of operations will be enclosed in brackets. This can be useful\n    for ensuring clarity or for specific formatting requirements.\n\n    Parameters:\n        with_all_brackets (bool): A flag indicating whether to include all necessary brackets in the expression string.\n    \"\"\"\n    self.with_all_brackets = with_all_brackets\n</code></pre>"},{"location":"expression/expression_evaluator/#opulse.expression.expression_evaluator.ExpressionEvaluator.tree_to_str","title":"<code>tree_to_str(node, parent_op=None, with_base_symbol=True, op_mode=False, statistic_analysis=False)</code>","text":"<p>Converts an expression tree node to a string representation.</p> <p>This method recursively traverses the expression tree and builds a string representation based on the node type. For binary and unary expression nodes, it checks the operator priority relative to the parent node's operator priority to determine if parentheses are needed to preserve correct order of operations. For number and variable nodes, it returns their direct string representations.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>ExpressionNode</code> <p>The expression node to convert.</p> required <code>parent_op</code> <code>OperatorInfo</code> <p>Information about the parent operator, used to determine if parentheses are needed. Defaults to None.</p> <code>None</code> <code>with_base_symbol</code> <code>bool</code> <p>Whether to include base symbols in the string. Defaults to True.</p> <code>True</code> <code>op_mode</code> <code>bool</code> <p>A flag indicating operator mode. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>String representation of the expression node.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If an unsupported expression node type is encountered.</p> Source code in <code>opulse/expression/expression_evaluator.py</code> <pre><code>def tree_to_str(\n    self,\n    node: ExpressionNode,\n    parent_op: OperatorInfo = None,\n    with_base_symbol: bool = True,\n    op_mode: bool = False,\n    statistic_analysis:bool = False,\n) -&gt; str:\n    \"\"\"\n    Converts an expression tree node to a string representation.\n\n    This method recursively traverses the expression tree and builds a string representation based on the node type.\n    For binary and unary expression nodes, it checks the operator priority relative to the parent node's operator priority\n    to determine if parentheses are needed to preserve correct order of operations.\n    For number and variable nodes, it returns their direct string representations.\n\n    Parameters:\n        node (ExpressionNode): The expression node to convert.\n        parent_op (OperatorInfo, optional): Information about the parent operator, used to determine if parentheses are needed. Defaults to None.\n        with_base_symbol (bool, optional): Whether to include base symbols in the string. Defaults to True.\n        op_mode (bool, optional): A flag indicating operator mode. Defaults to False.\n\n    Returns:\n        str: String representation of the expression node.\n\n    Raises:\n        NotImplementedError: If an unsupported expression node type is encountered.\n    \"\"\"\n\n    # Requires the priority of the parent node's operator for determining whether to add brackets\n    if isinstance(node, NumberNode):\n        node = cast(NumberNode, node)\n        if op_mode:\n            # when op_mode, we don't generate any base-related symbol\n            return f\"{node.to_str_no_base_symbol()}\"\n        else:\n            if statistic_analysis:\n                self.number_count += 1\n            if with_base_symbol:\n                return f\"{node.to_str(self.operator_manager,self.base_converter)}\"\n            else:\n                return f\"{node.to_str_no_base_symbol(surround_symbol='$')}\"\n    elif isinstance(node, VariableNode):\n        return f\"{node.v}\"\n    elif isinstance(node, BinaryExpressionNode):\n        node = cast(BinaryExpressionNode, node)\n        if not op_mode:\n            if statistic_analysis:\n                # Statistical priority for calculating calculate_priority_hierarchical_complexity\n                if (\n                    node.operator.priority != None\n                    and node.operator.priority not in self.all_priority\n                ):\n                    self.all_priority.append(node.operator.priority)\n                # Count the number of operations and associate the expression with the operator\n                self.operation_count += 1\n                self.all_operators[node.operator.func_id] += 1\n                # Count the n_order info\n                if self.highest_n_order &lt; node.operator.n_order:\n                    self.highest_n_order = node.operator.n_order\n        else:\n            self.operation_count += 1\n            self.all_operators[node.operator.func_id] += 1\n        # Convert the expression of the subtree\n        left_str = self.tree_to_str(\n            node.left_expr,\n            node.operator,\n            with_base_symbol=with_base_symbol,\n            op_mode=op_mode,\n            statistic_analysis=statistic_analysis,\n        )\n        right_str = self.tree_to_str(\n            node.right_expr,\n            node.operator,\n            with_base_symbol=with_base_symbol,\n            op_mode=op_mode,\n            statistic_analysis=statistic_analysis,\n        )\n\n        if self.with_all_brackets:\n            return f\"{self.atoms['left_bracket']}{left_str}{node.operator.symbol}{right_str}{self.atoms['right_bracket']}\"\n        # self.logger.debug(f\"parent_op: {parent_op}\")\n        if parent_op != None and node.operator.priority &lt; parent_op.priority:\n            return f\"{self.atoms['left_bracket']}{left_str}{node.operator.symbol}{right_str}{self.atoms['right_bracket']}\"\n        elif parent_op != None and node.operator.priority == parent_op.priority:\n            # If it has the same priority as parent op, choose whether to add parentheses or not based on location and binding.\n            if (\n                parent_op.associativity_direction == \"left\"\n                and node.position == \"right\"\n            ):\n                return f\"{self.atoms['left_bracket']}{left_str}{node.operator.symbol}{right_str}{self.atoms['right_bracket']}\"\n            elif (\n                parent_op.associativity_direction == \"right\"\n                and node.position == \"left\"\n            ):\n                return f\"{self.atoms['left_bracket']}{left_str}{node.operator.symbol}{right_str}{self.atoms['right_bracket']}\"\n            else:\n                return f\"{left_str}{node.operator.symbol}{right_str}\"\n        else:\n            return f\"{left_str}{node.operator.symbol}{right_str}\"\n    elif isinstance(node, UnaryExpressionNode):\n        node = cast(UnaryExpressionNode, node)\n        if not op_mode:\n            if statistic_analysis:\n                # Statistical priority for calculating calculate_priority_hierarchical_complexity\n                if (\n                    node.operator.priority != None\n                    and node.operator.priority not in self.all_priority\n                ):\n                    self.all_priority.append(node.operator.priority)\n                # Count the number of operations and associate the expression with the operator\n                self.operation_count += 1\n                self.all_operators[node.operator.func_id] += 1\n                # Count the n_order info\n                if node.operator.n_order==None:\n                    print(node.operator.func_id)\n                if self.highest_n_order &lt; node.operator.n_order:\n                    self.highest_n_order = node.operator.n_order\n        else:\n            self.operation_count += 1\n            self.all_operators[node.operator.func_id] += 1\n        unary_str = self.tree_to_str(\n            node.unary_expr,\n            node.operator,\n            with_base_symbol=with_base_symbol,\n            op_mode=op_mode,\n            statistic_analysis=statistic_analysis,\n        )\n        if node.operator.unary_position=='postfix':\n            return f\"({unary_str}{node.operator.symbol})\"\n        elif node.operator.unary_position=='prefix':\n        # Doubt: Always choose to add brackets to unary\n            return f\"({node.operator.symbol}{unary_str})\"\n    else:\n        raise NotImplementedError(\"ExpressionEvaluator.tree_to_str\")\n</code></pre>"},{"location":"expression/expression_generator/","title":"ExpressionGenerator","text":""},{"location":"expression/expression_generator/#opulse.expression.expression_generator.ExpressionGenerator","title":"<code>ExpressionGenerator</code>","text":"Source code in <code>opulse/expression/expression_generator.py</code> <pre><code>class ExpressionGenerator:\n\n    def __init__(\n        self,\n        param_config: ParamConfig,\n        logger: LogConfig,\n        cython_cache_dir : str,\n        operator_manager: OperatorManager,\n        # variables: List[str] = None,\n        # min_value: int = 0,\n        # max_value: int = 100,\n        # max_depth: int = 3,\n        # expr_type_weights: Dict[str, float] = None,\n        # atoms_type_weights: Dict[str, float] = None,\n    ):\n        \"\"\"\n        Initializes the ExpressionGenerator with configuration parameters and dependencies.\n\n        Args:\n            param_config (ParamConfig): Configuration parameters for expression generation.\n            logger (LogConfig): Logging configuration to record events and errors.\n            operator_manager (OperatorManager): Manager for handling operators used in expressions.\n        \"\"\"\n        self.param_config = param_config\n        self.logger = logger.get_logger()\n\n        self.variables = self.param_config.get(\"expr_variables\")\n        self.max_value = self.param_config.get(\"expr_numeric_range\")[\"max_value\"]\n        self.min_value = self.param_config.get(\"expr_numeric_range\")[\"min_value\"]\n\n        self.max_depth = self.param_config.get(\"expr_max_depth\")\n\n        self.expr_type_weights = self.param_config.get(\"expr_type_weights\")\n\n        self.atoms_type_weights = self.param_config.get(\"expr_atom_type_weights\")\n\n        self.cur_expr_id = 0\n        self.operator_manager = operator_manager\n\n        unary_prefix_ops, unary_postfix_ops, self.binary_ops = (\n            operator_manager.get_unary_and_binary_operators()\n        )\n\n        self.unary_postfix_ops = [\n            opinfo for opinfo in unary_postfix_ops if opinfo.is_base is None\n        ]\n        self.unary_prefix_ops = [\n            opinfo for opinfo in unary_prefix_ops if opinfo.is_base is None\n        ]\n\n\n        self.operators2expr: Dict[int, list[int]] = defaultdict(list)\n\n\n        self.base_converter = BaseConverter(\n            self.param_config.get(\"max_base\"), self.param_config.get(\"custom_digits\")\n        )\n        self.max_base = self.param_config.get(\"max_base\")\n        self.random_base_flag: bool = self.param_config.get(\"random_base\")[\"flag\"]\n        self.current_base: int = self.param_config.get(\"random_base\")[\"base\"]\n        # self.logger.debug(f\"init: current base: {self.current_base}\")\n        self.result_base: int = self.param_config.get(\"result_base\")[\"base\"]\n        self.result_base_random_flag: bool = self.param_config.get(\"result_base\")[\n            \"random_flag\"\n        ]\n        # related to longer result compute\n        self.longer_result_compute_flag: bool = self.param_config.get(\"longer_result_compute\")[\"flag\"]\n        self.longer_result_compute_base: int = self.param_config.get(\"longer_result_compute\")[\"base\"]\n\n        self.expr_evaluator = ExpressionEvaluator(\n            param_config,\n            logger,\n            cython_cache_dir,\n            operator_manager,\n            base_converter=self.base_converter,\n        )\n\n    def set_random_base(self, random_flag: bool, target_base: int = 10):\n        self.random_base_flag = random_flag\n        if random_flag == False:\n            self.current_base = target_base\n\n    def set_variables(self, new_variables: List[str]):\n        \"\"\"\n        Updates the list of variables used in expression generation.\n\n        Args:\n            new_variables (List[str]): A list of variable names to be used in expressions.\n        \"\"\"\n        self.variables = new_variables\n\n    def set_max_depth(self, max_depth: int) -&gt; None:\n        \"\"\"\n        Sets the maximum depth for generated expression trees.\n\n        Args:\n            max_depth (int): The maximum depth of the expression tree.\n        \"\"\"\n        self.max_depth = max_depth\n\n    def generate_random_value(self) -&gt; int:\n        \"\"\"\n        Generates a random integer value within the predefined min and max range.\n\n        Returns:\n            int: A randomly generated integer value.\n        \"\"\"\n        mid_value = random.randint(self.min_value, self.max_value)\n        value = random.randint(self.min_value, mid_value)\n        return value\n        # return random.randint(self.min_value, self.max_value)\n\n    def generate_random_base(self) -&gt; int:\n        \"\"\"\n        Generates a random base for number representation within the allowed range.\n\n        Returns:\n            int: A randomly selected base for number representation.\n        \"\"\"\n        # self.logger.debug(f\"current base: {self.current_base}\")\n        if self.random_base_flag:\n            return random.randint(2, self.max_base)\n        else:\n            return self.current_base\n\n    def generate_atoms(self, atom_choice: str) -&gt; ExpressionNode:\n        \"\"\"\n        Generates an atomic node based on the specified type.\n\n        Args:\n            atom_choice (str): Specifies the type of atomic element to generate. Options are 'variable', 'number', or 'variable_and_number'.\n\n        Returns:\n            ExpressionNode: An atomic node representing either a variable or a number.\n\n        Raises:\n            ValueError: If the provided atom_choice is not recognized.\n        \"\"\"\n        atoms_node = None\n        if atom_choice == \"variable\":\n\n            atoms_node = VariableNode(random.choice(self.variables))\n        elif atom_choice == \"number\":\n\n            atoms_node = NumberNode(\n                self.generate_random_value(), self.generate_random_base()\n            )\n        elif atom_choice == \"variable_and_number\":\n\n            atoms_type = random.choices(\n                [\"variable\", \"number\"],\n                weights=[\n                    self.atoms_type_weights[\"variable\"],\n                    self.atoms_type_weights[\"number\"],\n                ],\n            )[0]\n            if atoms_type == \"variable\":\n                atoms_node = VariableNode(random.choice(self.variables))\n            else:\n                atoms_node = NumberNode(\n                    self.generate_random_value(), self.generate_random_base()\n                )\n        else:\n            raise ValueError(\n                f\"Unknown atom_choice value: {atom_choice}. Valid options are 'variable', 'number', or 'variable_and_number'.\"\n            )\n        if atoms_node == None:\n            self.logger.error(\"atoms_node is None\")\n        return atoms_node\n\n    def generate_expression(\n        self, cur_depth, max_depth, atom_choice: str, is_op_weight: bool = False, fixed_op: OperatorInfo = None\n    ) -&gt; Dict[str, Any]:\n        \"\"\"\n        Recursively generates a random expression tree up to a specified depth.\n\n        Args:\n            cur_depth (int): Current depth of recursion.\n            max_depth (int): Maximum depth of the expression tree.\n            atom_choice (str): Determines what type of atoms can be generated ('variable', 'number', 'variable_and_number').\n\n        Returns:\n            ExpressionNode: A node representing part of the expression tree.\n        \"\"\"\n        if cur_depth &gt;= max_depth:\n            expr_node = self.generate_atoms(atom_choice)\n            return expr_node\n\n        if fixed_op is not None:\n            available_type=[\"atoms\",\"fixed_op\"]\n            expr_type=random.choices(available_type,weights=[0.5,0.5])[0]\n            if expr_type==\"atoms\":\n                expr_node = expr_node = self.generate_atoms(atom_choice)\n                return expr_node\n            elif expr_type==\"fixed_op\":\n                if fixed_op.n_ary==1:\n                    expr_node = UnaryExpressionNode(fixed_op)\n                    expr_node.unary_expr = self.generate_expression(\n                        cur_depth + 1, max_depth, atom_choice,fixed_op=fixed_op\n                    )\n                    expr_node.unary_expr.position = \"unary\"\n                    return expr_node\n                else:\n                    expr_node = BinaryExpressionNode(fixed_op)\n                    expr_node.left_expr = self.generate_expression(\n                        cur_depth + 1, max_depth, atom_choice,fixed_op=fixed_op\n                    )\n                    expr_node.left_expr.position = \"left\"\n                    expr_node.right_expr = self.generate_expression(\n                        cur_depth + 1, max_depth, atom_choice,fixed_op=fixed_op\n                    )\n                    expr_node.right_expr.position = \"right\"\n                    return expr_node\n\n        expr_type = random.choices(\n            [\"binary\", \"unary_prefix\", \"unary_postfix\", \"atoms\"],\n            weights=[\n                self.expr_type_weights[\"binary\"],\n                self.expr_type_weights[\"unary_prefix\"],\n                self.expr_type_weights[\"unary_postfix\"],\n                self.expr_type_weights[\"atoms\"],\n            ],\n        )[0]\n\n        if expr_type == \"binary\":\n\n            if not self.binary_ops:\n\n                return self.generate_expression(cur_depth, max_depth, atom_choice)\n            binary_op_weights = [opinfo.weight for opinfo in self.binary_ops]\n            if is_op_weight:\n                select_op = random.choices(\n                    self.binary_ops,\n                    weights=binary_op_weights,\n                )[0]\n            else:\n                equal_weight = [1] * len(self.binary_ops)\n                select_op = random.choices(\n                    self.binary_ops,\n                    weights=equal_weight,\n                )[0]\n\n            # select_op = random.choice(self.binary_ops)\n            expr_node = BinaryExpressionNode(select_op)\n\n            # The reason for recording the position here is that when converting to an expression string, \n            # parentheses need to be added appropriately, especially considering associativity.\n            # For example, in the expression tree: 1 + (2 + 3), after outputting 2 + 3, \n            # the recursive upper level needs to determine whether to add parentheses.\n\n            expr_node.left_expr = self.generate_expression(\n                cur_depth + 1, max_depth, atom_choice\n            )\n            expr_node.left_expr.position = \"left\"\n            expr_node.right_expr = self.generate_expression(\n                cur_depth + 1, max_depth, atom_choice\n            )\n            expr_node.right_expr.position = \"right\"\n            return expr_node\n        elif expr_type == \"unary_prefix\":\n            if not self.unary_prefix_ops:\n                return self.generate_expression(cur_depth, max_depth, atom_choice)\n            unary_prefix_ops_weights = [\n                opinfo.weight for opinfo in self.unary_prefix_ops\n            ]\n            if is_op_weight:\n                select_op = random.choices(\n                    self.unary_prefix_ops,\n                    weights=unary_prefix_ops_weights,\n                )[0]\n            else:\n                equal_weight = [1] * len(self.unary_prefix_ops)\n                select_op = random.choices(\n                    self.unary_prefix_ops,\n                    weights=equal_weight,\n                )[0]\n            # select_op = random.choice(self.unary_prefix_ops)\n            # if select_op.is_base:\n            #     print(\"error\")\n            #     exit(1)\n            expr_node = UnaryExpressionNode(select_op)\n            expr_node.unary_expr = self.generate_expression(\n                cur_depth + 1, max_depth, atom_choice\n            )\n            expr_node.unary_expr.position = \"unary\"\n            return expr_node\n        elif expr_type == \"unary_postfix\":\n            if not self.unary_postfix_ops:\n                return self.generate_expression(cur_depth, max_depth, atom_choice)\n            unary_postfix_ops_weights = [\n                opinfo.weight for opinfo in self.unary_postfix_ops\n            ]\n            if is_op_weight:\n                select_op = random.choices(\n                    self.unary_postfix_ops,\n                    weights=unary_postfix_ops_weights,\n                )[0]\n            else:\n                equal_weight = [1] * len(self.unary_postfix_ops)\n                select_op = random.choices(\n                    self.unary_postfix_ops,\n                    weights=equal_weight,\n                )[0]\n            # select_op = random.choice(self.unary_postfix_ops)\n            expr_node = UnaryExpressionNode(select_op)\n            expr_node.unary_expr = self.generate_expression(\n                cur_depth + 1, max_depth, atom_choice\n            )\n            expr_node.unary_expr.position = \"unary\"\n            return expr_node\n        elif expr_type == \"atoms\":\n            expr_node = expr_node = self.generate_atoms(atom_choice)\n            return expr_node\n\n\n    def create_single_operator_expression(self, func_id:str):\n        opinfo=self.operator_manager.get_operator_by_func_id(func_id)\n        if opinfo.n_ary==1:\n            expr_node = UnaryExpressionNode(opinfo)\n            expr_node.unary_expr = NumberNode(\n                self.generate_random_value(), self.generate_random_base()\n            )\n            expr_node.unary_expr.position = \"unary\"\n        elif opinfo.n_ary==2:\n            expr_node = BinaryExpressionNode(opinfo)\n            expr_node.left_expr = NumberNode(\n                self.generate_random_value(), self.generate_random_base()\n            )\n            expr_node.left_expr.position = \"left\"\n            expr_node.right_expr = NumberNode(\n                self.generate_random_value(), self.generate_random_base()\n            )\n            expr_node.right_expr.position = \"right\"\n\n\n        expr_result_base = None\n        longer_result_info = None\n        if self.result_base_random_flag:\n            expr_result_base = random.randint(2, self.max_base)\n        else:\n            expr_result_base = self.result_base\n        if self.longer_result_compute_flag:\n            longer_result_info = LongerResultInfo(\n                target_base=self.longer_result_compute_base, flag=False,\n            )\n\n        self.expr_evaluator.init_expr(\n            expression_tree=expr_node,\n            id=self.cur_expr_id,\n            op_mode=False,\n            expr_result_base=expr_result_base,\n            longer_result_info=longer_result_info,\n        )\n        # self.logger.debug(f\"Evaluating expression {self.cur_expr_id}\")\n        properties = self.expr_evaluator.evaluate()\n        # print(properties[\"used_operators\"])\n        for op_id in properties[\"used_operators\"]:\n            self.operators2expr[op_id].append(self.cur_expr_id)\n\n        self.cur_expr_id += 1\n\n        return properties\n\n    def create_expression(self, atom_choice: str, fix_func_id:str = None) -&gt; Dict[str, Any]:\n        \"\"\"\n        Creates a new expression, evaluates it, and records the used operators.\n\n        Args:\n            atom_choice (str): Determines the type of atoms that can be included in the expression.\n\n        Returns:\n            Dict[str, Any]: Properties of the evaluated expression, including used operators.\n        \"\"\"\n        # self.logger.debug(f\"Generating expression {self.cur_expr_id}\")\n        if fix_func_id is None:\n            expression_tree = self.generate_expression(\n                cur_depth=0, max_depth=self.max_depth, atom_choice=atom_choice, \n            )\n        else:\n            expression_tree = self.generate_expression(\n                cur_depth=0, max_depth=self.max_depth, atom_choice=atom_choice, fixed_op=\n                self.operator_manager.get_operator_by_func_id(fix_func_id)\n            )\n\n        expr_result_base = None\n        longer_result_info = None\n        if self.result_base_random_flag:\n            expr_result_base = random.randint(2, self.max_base)\n        else:\n            expr_result_base = self.result_base\n        if self.longer_result_compute_flag:\n            longer_result_info = LongerResultInfo(\n                target_base=self.longer_result_compute_base, flag=False,\n            )\n\n        self.expr_evaluator.init_expr(\n            expression_tree=expression_tree,\n            id=self.cur_expr_id,\n            op_mode=False,\n            expr_result_base=expr_result_base,\n            longer_result_info=longer_result_info,\n        )\n        # self.logger.debug(f\"Evaluating expression {self.cur_expr_id}\")\n        properties = self.expr_evaluator.evaluate()\n        # print(properties[\"used_operators\"])\n        for op_id in properties[\"used_operators\"]:\n            self.operators2expr[op_id].append(self.cur_expr_id)\n\n        # return expression_tree\n        self.cur_expr_id += 1\n\n        return properties\n\n\n    def create_expression_str(self, max_depth: int, atom_choice: str) -&gt; str:\n        \"\"\"\n        Generates a string representation of an expression with all sub-expressions enclosed in brackets.\n\n        This method creates a new expression tree and evaluates it to obtain a string representation,\n        ensuring that all parts of the expression are fully parenthesized for clarity. It also updates\n        the unary and binary operators before generating the expression.\n\n        Args:\n            atom_choice (str): Specifies the type of atomic elements to include in the expression ('variable', 'number', or 'variable_and_number').\n\n        Returns:\n            str: A fully parenthesized string representation of the generated expression.\n        \"\"\"\n        self.unary_prefix_ops, self.unary_postfix_ops, self.binary_ops = (\n            self.operator_manager.get_unary_and_binary_operators()\n        )\n        expression_tree = self.generate_expression(\n            cur_depth=0, max_depth=max_depth, atom_choice=atom_choice\n        )\n        self.expr_evaluator.set_with_all_brackets(True)\n        self.expr_evaluator.init_expr(expression_tree, self.cur_expr_id, op_mode=True)\n        # evaluator = ExpressionEvaluator(expression_tree, self.operator_manager)\n        # properties = self.expr_evaluator.evaluate()\n\n        return self.expr_evaluator.expression_str\n\n    def create_expression_str_by_order(self, max_depth: int, atom_choice: str) -&gt; str:\n        pass\n\n    def create_n_expression_str_with_order(\n        self, max_depth: int, atom_choice: str, order: int, branch_num: int\n    ) -&gt; List[str]:\n\n        unary_prefix_ops, unary_postfix_ops, binary_ops = (\n            self.operator_manager.get_unary_and_binary_operators()\n        )\n        self.unary_postfix_ops = [opinfo for opinfo in unary_postfix_ops if opinfo.n_order&lt;=order] \n        self.unary_prefix_ops = [opinfo for opinfo in unary_prefix_ops if opinfo.n_order&lt;=order]\n        self.binary_ops = [opinfo for opinfo in binary_ops if opinfo.n_order&lt;=order]\n\n        n_order_binary_ops = [\n            opinfo for opinfo in binary_ops if opinfo.n_order == order\n        ]\n        n_order_unary_prefix_ops = [\n            opinfo for opinfo in unary_prefix_ops if opinfo.n_order == order\n        ]\n        n_order_unary_postfix_ops = [\n            opinfo for opinfo in unary_postfix_ops if opinfo.n_order == order\n        ]\n        n_order_unary_ops = n_order_unary_prefix_ops + n_order_unary_postfix_ops\n\n        select_n_order_op = random.choice(n_order_binary_ops + n_order_unary_ops)\n        while True:\n            expression_trees = []\n            all_op_dicts: List[int, int] = []\n            for _ in range(branch_num):\n                expression_tree = self.generate_expression(\n                    cur_depth=0, max_depth=max_depth, atom_choice=atom_choice\n                )\n                self.expr_evaluator.set_with_all_brackets(True)\n                self.expr_evaluator.init_expr(\n                    expression_tree, self.cur_expr_id, op_mode=True\n                )\n                all_op_dicts.append(self.expr_evaluator.all_operators)\n                expression_trees.append(expression_tree)\n            all_op_id = set().union(*all_op_dicts)\n            all_op_info = [\n                self.operator_manager.get_operator_by_func_id(op_id) for op_id in all_op_id\n            ]\n\n            candidate_replace_op_info = [\n                opinfo\n                for opinfo in all_op_info\n                if opinfo.n_ary == select_n_order_op.n_ary\n            ]\n            if len(candidate_replace_op_info) &gt; 0:\n                break\n        replace_op = random.choice(candidate_replace_op_info)\n\n        def replace_target_op(\n            node: ExpressionNode, replaced_op: OperatorInfo, target_op: OperatorInfo\n        ):\n            if isinstance(node, BinaryExpressionNode):\n                if node.operator == replaced_op:\n                    node.operator = target_op\n                replace_target_op(node.left_expr, replaced_op, target_op)\n                replace_target_op(node.right_expr, replaced_op, target_op)\n            elif isinstance(node, UnaryExpressionNode):\n                if node.operator == replaced_op:\n                    node.operator = target_op\n                replace_target_op(node.unary_expr, replaced_op, target_op)\n            else:\n                return\n\n        for expression_tree in expression_trees:\n            replace_target_op(expression_tree, replace_op, select_n_order_op)\n\n        expression_strs = []\n        for expression_tree in expression_trees:\n            self.expr_evaluator.set_with_all_brackets(True)\n            self.expr_evaluator.init_expr(\n                expression_tree, self.cur_expr_id, op_mode=True\n            )\n            expression_strs.append(self.expr_evaluator.expression_str)\n\n        return expression_strs\n\n    def dump_op2expr(self, file_path):\n        \"\"\"\n        Dumps the mapping of operator IDs to expression IDs into a JSON Lines file.\n\n        Each line in the output file contains a JSON object representing the relationship between\n        an operator ID and the list of expression IDs that use this operator.\n\n        Args:\n            file_path (str): The path to the output file where the operator-expression mappings will be saved.\n        \"\"\"\n        with open(file_path, \"w\") as f:\n            for op_id in self.operators2expr:\n                data = {\n                    \"op_id\": op_id,\n                    \"expr_id\": self.operators2expr[op_id],\n                }\n                json.dump(data, f)\n                f.write(\"\\n\")\n</code></pre>"},{"location":"expression/expression_generator/#opulse.expression.expression_generator.ExpressionGenerator.__init__","title":"<code>__init__(param_config, logger, cython_cache_dir, operator_manager)</code>","text":"<p>Initializes the ExpressionGenerator with configuration parameters and dependencies.</p> <p>Parameters:</p> Name Type Description Default <code>param_config</code> <code>ParamConfig</code> <p>Configuration parameters for expression generation.</p> required <code>logger</code> <code>LogConfig</code> <p>Logging configuration to record events and errors.</p> required <code>operator_manager</code> <code>OperatorManager</code> <p>Manager for handling operators used in expressions.</p> required Source code in <code>opulse/expression/expression_generator.py</code> <pre><code>def __init__(\n    self,\n    param_config: ParamConfig,\n    logger: LogConfig,\n    cython_cache_dir : str,\n    operator_manager: OperatorManager,\n    # variables: List[str] = None,\n    # min_value: int = 0,\n    # max_value: int = 100,\n    # max_depth: int = 3,\n    # expr_type_weights: Dict[str, float] = None,\n    # atoms_type_weights: Dict[str, float] = None,\n):\n    \"\"\"\n    Initializes the ExpressionGenerator with configuration parameters and dependencies.\n\n    Args:\n        param_config (ParamConfig): Configuration parameters for expression generation.\n        logger (LogConfig): Logging configuration to record events and errors.\n        operator_manager (OperatorManager): Manager for handling operators used in expressions.\n    \"\"\"\n    self.param_config = param_config\n    self.logger = logger.get_logger()\n\n    self.variables = self.param_config.get(\"expr_variables\")\n    self.max_value = self.param_config.get(\"expr_numeric_range\")[\"max_value\"]\n    self.min_value = self.param_config.get(\"expr_numeric_range\")[\"min_value\"]\n\n    self.max_depth = self.param_config.get(\"expr_max_depth\")\n\n    self.expr_type_weights = self.param_config.get(\"expr_type_weights\")\n\n    self.atoms_type_weights = self.param_config.get(\"expr_atom_type_weights\")\n\n    self.cur_expr_id = 0\n    self.operator_manager = operator_manager\n\n    unary_prefix_ops, unary_postfix_ops, self.binary_ops = (\n        operator_manager.get_unary_and_binary_operators()\n    )\n\n    self.unary_postfix_ops = [\n        opinfo for opinfo in unary_postfix_ops if opinfo.is_base is None\n    ]\n    self.unary_prefix_ops = [\n        opinfo for opinfo in unary_prefix_ops if opinfo.is_base is None\n    ]\n\n\n    self.operators2expr: Dict[int, list[int]] = defaultdict(list)\n\n\n    self.base_converter = BaseConverter(\n        self.param_config.get(\"max_base\"), self.param_config.get(\"custom_digits\")\n    )\n    self.max_base = self.param_config.get(\"max_base\")\n    self.random_base_flag: bool = self.param_config.get(\"random_base\")[\"flag\"]\n    self.current_base: int = self.param_config.get(\"random_base\")[\"base\"]\n    # self.logger.debug(f\"init: current base: {self.current_base}\")\n    self.result_base: int = self.param_config.get(\"result_base\")[\"base\"]\n    self.result_base_random_flag: bool = self.param_config.get(\"result_base\")[\n        \"random_flag\"\n    ]\n    # related to longer result compute\n    self.longer_result_compute_flag: bool = self.param_config.get(\"longer_result_compute\")[\"flag\"]\n    self.longer_result_compute_base: int = self.param_config.get(\"longer_result_compute\")[\"base\"]\n\n    self.expr_evaluator = ExpressionEvaluator(\n        param_config,\n        logger,\n        cython_cache_dir,\n        operator_manager,\n        base_converter=self.base_converter,\n    )\n</code></pre>"},{"location":"expression/expression_generator/#opulse.expression.expression_generator.ExpressionGenerator.create_expression","title":"<code>create_expression(atom_choice, fix_func_id=None)</code>","text":"<p>Creates a new expression, evaluates it, and records the used operators.</p> <p>Parameters:</p> Name Type Description Default <code>atom_choice</code> <code>str</code> <p>Determines the type of atoms that can be included in the expression.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Properties of the evaluated expression, including used operators.</p> Source code in <code>opulse/expression/expression_generator.py</code> <pre><code>def create_expression(self, atom_choice: str, fix_func_id:str = None) -&gt; Dict[str, Any]:\n    \"\"\"\n    Creates a new expression, evaluates it, and records the used operators.\n\n    Args:\n        atom_choice (str): Determines the type of atoms that can be included in the expression.\n\n    Returns:\n        Dict[str, Any]: Properties of the evaluated expression, including used operators.\n    \"\"\"\n    # self.logger.debug(f\"Generating expression {self.cur_expr_id}\")\n    if fix_func_id is None:\n        expression_tree = self.generate_expression(\n            cur_depth=0, max_depth=self.max_depth, atom_choice=atom_choice, \n        )\n    else:\n        expression_tree = self.generate_expression(\n            cur_depth=0, max_depth=self.max_depth, atom_choice=atom_choice, fixed_op=\n            self.operator_manager.get_operator_by_func_id(fix_func_id)\n        )\n\n    expr_result_base = None\n    longer_result_info = None\n    if self.result_base_random_flag:\n        expr_result_base = random.randint(2, self.max_base)\n    else:\n        expr_result_base = self.result_base\n    if self.longer_result_compute_flag:\n        longer_result_info = LongerResultInfo(\n            target_base=self.longer_result_compute_base, flag=False,\n        )\n\n    self.expr_evaluator.init_expr(\n        expression_tree=expression_tree,\n        id=self.cur_expr_id,\n        op_mode=False,\n        expr_result_base=expr_result_base,\n        longer_result_info=longer_result_info,\n    )\n    # self.logger.debug(f\"Evaluating expression {self.cur_expr_id}\")\n    properties = self.expr_evaluator.evaluate()\n    # print(properties[\"used_operators\"])\n    for op_id in properties[\"used_operators\"]:\n        self.operators2expr[op_id].append(self.cur_expr_id)\n\n    # return expression_tree\n    self.cur_expr_id += 1\n\n    return properties\n</code></pre>"},{"location":"expression/expression_generator/#opulse.expression.expression_generator.ExpressionGenerator.create_expression_str","title":"<code>create_expression_str(max_depth, atom_choice)</code>","text":"<p>Generates a string representation of an expression with all sub-expressions enclosed in brackets.</p> <p>This method creates a new expression tree and evaluates it to obtain a string representation, ensuring that all parts of the expression are fully parenthesized for clarity. It also updates the unary and binary operators before generating the expression.</p> <p>Parameters:</p> Name Type Description Default <code>atom_choice</code> <code>str</code> <p>Specifies the type of atomic elements to include in the expression ('variable', 'number', or 'variable_and_number').</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A fully parenthesized string representation of the generated expression.</p> Source code in <code>opulse/expression/expression_generator.py</code> <pre><code>def create_expression_str(self, max_depth: int, atom_choice: str) -&gt; str:\n    \"\"\"\n    Generates a string representation of an expression with all sub-expressions enclosed in brackets.\n\n    This method creates a new expression tree and evaluates it to obtain a string representation,\n    ensuring that all parts of the expression are fully parenthesized for clarity. It also updates\n    the unary and binary operators before generating the expression.\n\n    Args:\n        atom_choice (str): Specifies the type of atomic elements to include in the expression ('variable', 'number', or 'variable_and_number').\n\n    Returns:\n        str: A fully parenthesized string representation of the generated expression.\n    \"\"\"\n    self.unary_prefix_ops, self.unary_postfix_ops, self.binary_ops = (\n        self.operator_manager.get_unary_and_binary_operators()\n    )\n    expression_tree = self.generate_expression(\n        cur_depth=0, max_depth=max_depth, atom_choice=atom_choice\n    )\n    self.expr_evaluator.set_with_all_brackets(True)\n    self.expr_evaluator.init_expr(expression_tree, self.cur_expr_id, op_mode=True)\n    # evaluator = ExpressionEvaluator(expression_tree, self.operator_manager)\n    # properties = self.expr_evaluator.evaluate()\n\n    return self.expr_evaluator.expression_str\n</code></pre>"},{"location":"expression/expression_generator/#opulse.expression.expression_generator.ExpressionGenerator.dump_op2expr","title":"<code>dump_op2expr(file_path)</code>","text":"<p>Dumps the mapping of operator IDs to expression IDs into a JSON Lines file.</p> <p>Each line in the output file contains a JSON object representing the relationship between an operator ID and the list of expression IDs that use this operator.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>The path to the output file where the operator-expression mappings will be saved.</p> required Source code in <code>opulse/expression/expression_generator.py</code> <pre><code>def dump_op2expr(self, file_path):\n    \"\"\"\n    Dumps the mapping of operator IDs to expression IDs into a JSON Lines file.\n\n    Each line in the output file contains a JSON object representing the relationship between\n    an operator ID and the list of expression IDs that use this operator.\n\n    Args:\n        file_path (str): The path to the output file where the operator-expression mappings will be saved.\n    \"\"\"\n    with open(file_path, \"w\") as f:\n        for op_id in self.operators2expr:\n            data = {\n                \"op_id\": op_id,\n                \"expr_id\": self.operators2expr[op_id],\n            }\n            json.dump(data, f)\n            f.write(\"\\n\")\n</code></pre>"},{"location":"expression/expression_generator/#opulse.expression.expression_generator.ExpressionGenerator.generate_atoms","title":"<code>generate_atoms(atom_choice)</code>","text":"<p>Generates an atomic node based on the specified type.</p> <p>Parameters:</p> Name Type Description Default <code>atom_choice</code> <code>str</code> <p>Specifies the type of atomic element to generate. Options are 'variable', 'number', or 'variable_and_number'.</p> required <p>Returns:</p> Name Type Description <code>ExpressionNode</code> <code>ExpressionNode</code> <p>An atomic node representing either a variable or a number.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the provided atom_choice is not recognized.</p> Source code in <code>opulse/expression/expression_generator.py</code> <pre><code>def generate_atoms(self, atom_choice: str) -&gt; ExpressionNode:\n    \"\"\"\n    Generates an atomic node based on the specified type.\n\n    Args:\n        atom_choice (str): Specifies the type of atomic element to generate. Options are 'variable', 'number', or 'variable_and_number'.\n\n    Returns:\n        ExpressionNode: An atomic node representing either a variable or a number.\n\n    Raises:\n        ValueError: If the provided atom_choice is not recognized.\n    \"\"\"\n    atoms_node = None\n    if atom_choice == \"variable\":\n\n        atoms_node = VariableNode(random.choice(self.variables))\n    elif atom_choice == \"number\":\n\n        atoms_node = NumberNode(\n            self.generate_random_value(), self.generate_random_base()\n        )\n    elif atom_choice == \"variable_and_number\":\n\n        atoms_type = random.choices(\n            [\"variable\", \"number\"],\n            weights=[\n                self.atoms_type_weights[\"variable\"],\n                self.atoms_type_weights[\"number\"],\n            ],\n        )[0]\n        if atoms_type == \"variable\":\n            atoms_node = VariableNode(random.choice(self.variables))\n        else:\n            atoms_node = NumberNode(\n                self.generate_random_value(), self.generate_random_base()\n            )\n    else:\n        raise ValueError(\n            f\"Unknown atom_choice value: {atom_choice}. Valid options are 'variable', 'number', or 'variable_and_number'.\"\n        )\n    if atoms_node == None:\n        self.logger.error(\"atoms_node is None\")\n    return atoms_node\n</code></pre>"},{"location":"expression/expression_generator/#opulse.expression.expression_generator.ExpressionGenerator.generate_expression","title":"<code>generate_expression(cur_depth, max_depth, atom_choice, is_op_weight=False, fixed_op=None)</code>","text":"<p>Recursively generates a random expression tree up to a specified depth.</p> <p>Parameters:</p> Name Type Description Default <code>cur_depth</code> <code>int</code> <p>Current depth of recursion.</p> required <code>max_depth</code> <code>int</code> <p>Maximum depth of the expression tree.</p> required <code>atom_choice</code> <code>str</code> <p>Determines what type of atoms can be generated ('variable', 'number', 'variable_and_number').</p> required <p>Returns:</p> Name Type Description <code>ExpressionNode</code> <code>Dict[str, Any]</code> <p>A node representing part of the expression tree.</p> Source code in <code>opulse/expression/expression_generator.py</code> <pre><code>def generate_expression(\n    self, cur_depth, max_depth, atom_choice: str, is_op_weight: bool = False, fixed_op: OperatorInfo = None\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Recursively generates a random expression tree up to a specified depth.\n\n    Args:\n        cur_depth (int): Current depth of recursion.\n        max_depth (int): Maximum depth of the expression tree.\n        atom_choice (str): Determines what type of atoms can be generated ('variable', 'number', 'variable_and_number').\n\n    Returns:\n        ExpressionNode: A node representing part of the expression tree.\n    \"\"\"\n    if cur_depth &gt;= max_depth:\n        expr_node = self.generate_atoms(atom_choice)\n        return expr_node\n\n    if fixed_op is not None:\n        available_type=[\"atoms\",\"fixed_op\"]\n        expr_type=random.choices(available_type,weights=[0.5,0.5])[0]\n        if expr_type==\"atoms\":\n            expr_node = expr_node = self.generate_atoms(atom_choice)\n            return expr_node\n        elif expr_type==\"fixed_op\":\n            if fixed_op.n_ary==1:\n                expr_node = UnaryExpressionNode(fixed_op)\n                expr_node.unary_expr = self.generate_expression(\n                    cur_depth + 1, max_depth, atom_choice,fixed_op=fixed_op\n                )\n                expr_node.unary_expr.position = \"unary\"\n                return expr_node\n            else:\n                expr_node = BinaryExpressionNode(fixed_op)\n                expr_node.left_expr = self.generate_expression(\n                    cur_depth + 1, max_depth, atom_choice,fixed_op=fixed_op\n                )\n                expr_node.left_expr.position = \"left\"\n                expr_node.right_expr = self.generate_expression(\n                    cur_depth + 1, max_depth, atom_choice,fixed_op=fixed_op\n                )\n                expr_node.right_expr.position = \"right\"\n                return expr_node\n\n    expr_type = random.choices(\n        [\"binary\", \"unary_prefix\", \"unary_postfix\", \"atoms\"],\n        weights=[\n            self.expr_type_weights[\"binary\"],\n            self.expr_type_weights[\"unary_prefix\"],\n            self.expr_type_weights[\"unary_postfix\"],\n            self.expr_type_weights[\"atoms\"],\n        ],\n    )[0]\n\n    if expr_type == \"binary\":\n\n        if not self.binary_ops:\n\n            return self.generate_expression(cur_depth, max_depth, atom_choice)\n        binary_op_weights = [opinfo.weight for opinfo in self.binary_ops]\n        if is_op_weight:\n            select_op = random.choices(\n                self.binary_ops,\n                weights=binary_op_weights,\n            )[0]\n        else:\n            equal_weight = [1] * len(self.binary_ops)\n            select_op = random.choices(\n                self.binary_ops,\n                weights=equal_weight,\n            )[0]\n\n        # select_op = random.choice(self.binary_ops)\n        expr_node = BinaryExpressionNode(select_op)\n\n        # The reason for recording the position here is that when converting to an expression string, \n        # parentheses need to be added appropriately, especially considering associativity.\n        # For example, in the expression tree: 1 + (2 + 3), after outputting 2 + 3, \n        # the recursive upper level needs to determine whether to add parentheses.\n\n        expr_node.left_expr = self.generate_expression(\n            cur_depth + 1, max_depth, atom_choice\n        )\n        expr_node.left_expr.position = \"left\"\n        expr_node.right_expr = self.generate_expression(\n            cur_depth + 1, max_depth, atom_choice\n        )\n        expr_node.right_expr.position = \"right\"\n        return expr_node\n    elif expr_type == \"unary_prefix\":\n        if not self.unary_prefix_ops:\n            return self.generate_expression(cur_depth, max_depth, atom_choice)\n        unary_prefix_ops_weights = [\n            opinfo.weight for opinfo in self.unary_prefix_ops\n        ]\n        if is_op_weight:\n            select_op = random.choices(\n                self.unary_prefix_ops,\n                weights=unary_prefix_ops_weights,\n            )[0]\n        else:\n            equal_weight = [1] * len(self.unary_prefix_ops)\n            select_op = random.choices(\n                self.unary_prefix_ops,\n                weights=equal_weight,\n            )[0]\n        # select_op = random.choice(self.unary_prefix_ops)\n        # if select_op.is_base:\n        #     print(\"error\")\n        #     exit(1)\n        expr_node = UnaryExpressionNode(select_op)\n        expr_node.unary_expr = self.generate_expression(\n            cur_depth + 1, max_depth, atom_choice\n        )\n        expr_node.unary_expr.position = \"unary\"\n        return expr_node\n    elif expr_type == \"unary_postfix\":\n        if not self.unary_postfix_ops:\n            return self.generate_expression(cur_depth, max_depth, atom_choice)\n        unary_postfix_ops_weights = [\n            opinfo.weight for opinfo in self.unary_postfix_ops\n        ]\n        if is_op_weight:\n            select_op = random.choices(\n                self.unary_postfix_ops,\n                weights=unary_postfix_ops_weights,\n            )[0]\n        else:\n            equal_weight = [1] * len(self.unary_postfix_ops)\n            select_op = random.choices(\n                self.unary_postfix_ops,\n                weights=equal_weight,\n            )[0]\n        # select_op = random.choice(self.unary_postfix_ops)\n        expr_node = UnaryExpressionNode(select_op)\n        expr_node.unary_expr = self.generate_expression(\n            cur_depth + 1, max_depth, atom_choice\n        )\n        expr_node.unary_expr.position = \"unary\"\n        return expr_node\n    elif expr_type == \"atoms\":\n        expr_node = expr_node = self.generate_atoms(atom_choice)\n        return expr_node\n</code></pre>"},{"location":"expression/expression_generator/#opulse.expression.expression_generator.ExpressionGenerator.generate_random_base","title":"<code>generate_random_base()</code>","text":"<p>Generates a random base for number representation within the allowed range.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>A randomly selected base for number representation.</p> Source code in <code>opulse/expression/expression_generator.py</code> <pre><code>def generate_random_base(self) -&gt; int:\n    \"\"\"\n    Generates a random base for number representation within the allowed range.\n\n    Returns:\n        int: A randomly selected base for number representation.\n    \"\"\"\n    # self.logger.debug(f\"current base: {self.current_base}\")\n    if self.random_base_flag:\n        return random.randint(2, self.max_base)\n    else:\n        return self.current_base\n</code></pre>"},{"location":"expression/expression_generator/#opulse.expression.expression_generator.ExpressionGenerator.generate_random_value","title":"<code>generate_random_value()</code>","text":"<p>Generates a random integer value within the predefined min and max range.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>A randomly generated integer value.</p> Source code in <code>opulse/expression/expression_generator.py</code> <pre><code>def generate_random_value(self) -&gt; int:\n    \"\"\"\n    Generates a random integer value within the predefined min and max range.\n\n    Returns:\n        int: A randomly generated integer value.\n    \"\"\"\n    mid_value = random.randint(self.min_value, self.max_value)\n    value = random.randint(self.min_value, mid_value)\n    return value\n</code></pre>"},{"location":"expression/expression_generator/#opulse.expression.expression_generator.ExpressionGenerator.set_max_depth","title":"<code>set_max_depth(max_depth)</code>","text":"<p>Sets the maximum depth for generated expression trees.</p> <p>Parameters:</p> Name Type Description Default <code>max_depth</code> <code>int</code> <p>The maximum depth of the expression tree.</p> required Source code in <code>opulse/expression/expression_generator.py</code> <pre><code>def set_max_depth(self, max_depth: int) -&gt; None:\n    \"\"\"\n    Sets the maximum depth for generated expression trees.\n\n    Args:\n        max_depth (int): The maximum depth of the expression tree.\n    \"\"\"\n    self.max_depth = max_depth\n</code></pre>"},{"location":"expression/expression_generator/#opulse.expression.expression_generator.ExpressionGenerator.set_variables","title":"<code>set_variables(new_variables)</code>","text":"<p>Updates the list of variables used in expression generation.</p> <p>Parameters:</p> Name Type Description Default <code>new_variables</code> <code>List[str]</code> <p>A list of variable names to be used in expressions.</p> required Source code in <code>opulse/expression/expression_generator.py</code> <pre><code>def set_variables(self, new_variables: List[str]):\n    \"\"\"\n    Updates the list of variables used in expression generation.\n\n    Args:\n        new_variables (List[str]): A list of variable names to be used in expressions.\n    \"\"\"\n    self.variables = new_variables\n</code></pre>"},{"location":"expression/expression_node/","title":"ExpressionNode","text":""},{"location":"expression/expression_node/#opulse.expression.expression_node.BinaryExpressionNode","title":"<code>BinaryExpressionNode</code>","text":"<p>               Bases: <code>ExpressionNode</code></p> Source code in <code>opulse/expression/expression_node.py</code> <pre><code>class BinaryExpressionNode(ExpressionNode):\n    def __init__(self, operator: OperatorInfo):\n        \"\"\"\n        Initializes a binary expression node with an operator.\n\n        Args:\n           operator (OperatorInfo): The operator information for the expression.\n        \"\"\"\n        super().__init__()\n        self.left_expr: ExpressionNode = None\n        self.right_expr: ExpressionNode = None\n        self.operator = operator\n\n    def to_dict(self):\n        \"\"\"\n        Converts the binary expression node to a dictionary representation.\n\n        Returns:\n            (dict): A dictionary with the node's type, operator, and child expressions.\n        \"\"\"\n        return {\n            \"type\": \"binary\",\n            \"operator\": self.operator.symbol,\n            \"left_expr\": self.left_expr.to_dict(),\n            \"right_expr\": self.right_expr.to_dict(),\n        }\n</code></pre>"},{"location":"expression/expression_node/#opulse.expression.expression_node.BinaryExpressionNode.__init__","title":"<code>__init__(operator)</code>","text":"<p>Initializes a binary expression node with an operator.</p> <p>Parameters:</p> Name Type Description Default <code>operator</code> <code>OperatorInfo</code> <p>The operator information for the expression.</p> required Source code in <code>opulse/expression/expression_node.py</code> <pre><code>def __init__(self, operator: OperatorInfo):\n    \"\"\"\n    Initializes a binary expression node with an operator.\n\n    Args:\n       operator (OperatorInfo): The operator information for the expression.\n    \"\"\"\n    super().__init__()\n    self.left_expr: ExpressionNode = None\n    self.right_expr: ExpressionNode = None\n    self.operator = operator\n</code></pre>"},{"location":"expression/expression_node/#opulse.expression.expression_node.BinaryExpressionNode.to_dict","title":"<code>to_dict()</code>","text":"<p>Converts the binary expression node to a dictionary representation.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary with the node's type, operator, and child expressions.</p> Source code in <code>opulse/expression/expression_node.py</code> <pre><code>def to_dict(self):\n    \"\"\"\n    Converts the binary expression node to a dictionary representation.\n\n    Returns:\n        (dict): A dictionary with the node's type, operator, and child expressions.\n    \"\"\"\n    return {\n        \"type\": \"binary\",\n        \"operator\": self.operator.symbol,\n        \"left_expr\": self.left_expr.to_dict(),\n        \"right_expr\": self.right_expr.to_dict(),\n    }\n</code></pre>"},{"location":"expression/expression_node/#opulse.expression.expression_node.ExpressionNode","title":"<code>ExpressionNode</code>","text":"Source code in <code>opulse/expression/expression_node.py</code> <pre><code>class ExpressionNode:\n    def __init__(self):\n        \"\"\"\n        Initializes a basic expression node with a position attribute.\n        \"\"\"\n        self.position = None\n\n    def to_dict(self):\n        \"\"\"\n        Abstract method to convert the node to a dictionary representation.\n        Subclasses should implement this method.\n        \"\"\"\n        raise NotImplementedError(\"Subclasses should implement this method\")\n</code></pre>"},{"location":"expression/expression_node/#opulse.expression.expression_node.ExpressionNode.__init__","title":"<code>__init__()</code>","text":"<p>Initializes a basic expression node with a position attribute.</p> Source code in <code>opulse/expression/expression_node.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Initializes a basic expression node with a position attribute.\n    \"\"\"\n    self.position = None\n</code></pre>"},{"location":"expression/expression_node/#opulse.expression.expression_node.ExpressionNode.to_dict","title":"<code>to_dict()</code>","text":"<p>Abstract method to convert the node to a dictionary representation. Subclasses should implement this method.</p> Source code in <code>opulse/expression/expression_node.py</code> <pre><code>def to_dict(self):\n    \"\"\"\n    Abstract method to convert the node to a dictionary representation.\n    Subclasses should implement this method.\n    \"\"\"\n    raise NotImplementedError(\"Subclasses should implement this method\")\n</code></pre>"},{"location":"expression/expression_node/#opulse.expression.expression_node.NumberNode","title":"<code>NumberNode</code>","text":"<p>               Bases: <code>ExpressionNode</code></p> Source code in <code>opulse/expression/expression_node.py</code> <pre><code>class NumberNode(ExpressionNode):\n    def __init__(self, value: int, base: int = 10):\n        \"\"\"\n        Initializes a number node with a value and an optional base.\n\n        Args:\n            value (int): The numeric value of the node.\n            base (int): The base of the number (default is 10).\n        \"\"\"\n        super().__init__()\n        self.value = value\n        self.base = base\n\n    def to_dict(self):\n        \"\"\"\n        Converts the number node to a dictionary representation.\n\n        Returns\n            (dict): A dictionary with the node's type, value, and base.\n        \"\"\"\n        return {\"type\": \"numeric_atoms\", \"value\": self.value, \"base\": self.base}\n\n    def to_str_no_base_symbol(self, surround_symbol: str = None):\n        \"\"\"\n        Converts the node's value to a string without base symbols.\n\n        Args:\n           surround_symbol: The symbol surrounding the value.\n\n        Returns:\n            (str): A string representation of the value.\n        \"\"\"\n        if surround_symbol:\n            return f\"{surround_symbol}{self.value}{surround_symbol}\"\n        else:\n            return f\"{self.value}\"\n\n    def to_str(self, operator_manager: OperatorManager, base_converter: BaseConverter):\n        \"\"\"\n        Converts the node's value to a string with base symbols.\n\n        Args:\n           operator_manager (OperatorManager): The operator manager to get base operators.\n           base_converter (BaseConverter): The base converter to convert the value.\n\n        Returns:\n            (str): A string representation of the value with base symbols.\n\n        Raises:\n            ValueError: If base_converter is None.\n        \"\"\"\n        return ExpressionBaseConverter.convert_int_to_targetbase(\n            input=self.value,\n            output_base=self.base,\n            base_converter=base_converter,\n            operator_manager=operator_manager,\n        )\n</code></pre>"},{"location":"expression/expression_node/#opulse.expression.expression_node.NumberNode.__init__","title":"<code>__init__(value, base=10)</code>","text":"<p>Initializes a number node with a value and an optional base.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>The numeric value of the node.</p> required <code>base</code> <code>int</code> <p>The base of the number (default is 10).</p> <code>10</code> Source code in <code>opulse/expression/expression_node.py</code> <pre><code>def __init__(self, value: int, base: int = 10):\n    \"\"\"\n    Initializes a number node with a value and an optional base.\n\n    Args:\n        value (int): The numeric value of the node.\n        base (int): The base of the number (default is 10).\n    \"\"\"\n    super().__init__()\n    self.value = value\n    self.base = base\n</code></pre>"},{"location":"expression/expression_node/#opulse.expression.expression_node.NumberNode.to_dict","title":"<code>to_dict()</code>","text":"<p>Converts the number node to a dictionary representation.</p> <p>Returns     (dict): A dictionary with the node's type, value, and base.</p> Source code in <code>opulse/expression/expression_node.py</code> <pre><code>def to_dict(self):\n    \"\"\"\n    Converts the number node to a dictionary representation.\n\n    Returns\n        (dict): A dictionary with the node's type, value, and base.\n    \"\"\"\n    return {\"type\": \"numeric_atoms\", \"value\": self.value, \"base\": self.base}\n</code></pre>"},{"location":"expression/expression_node/#opulse.expression.expression_node.NumberNode.to_str","title":"<code>to_str(operator_manager, base_converter)</code>","text":"<p>Converts the node's value to a string with base symbols.</p> <p>Parameters:</p> Name Type Description Default <code>operator_manager</code> <code>OperatorManager</code> <p>The operator manager to get base operators.</p> required <code>base_converter</code> <code>BaseConverter</code> <p>The base converter to convert the value.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A string representation of the value with base symbols.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If base_converter is None.</p> Source code in <code>opulse/expression/expression_node.py</code> <pre><code>def to_str(self, operator_manager: OperatorManager, base_converter: BaseConverter):\n    \"\"\"\n    Converts the node's value to a string with base symbols.\n\n    Args:\n       operator_manager (OperatorManager): The operator manager to get base operators.\n       base_converter (BaseConverter): The base converter to convert the value.\n\n    Returns:\n        (str): A string representation of the value with base symbols.\n\n    Raises:\n        ValueError: If base_converter is None.\n    \"\"\"\n    return ExpressionBaseConverter.convert_int_to_targetbase(\n        input=self.value,\n        output_base=self.base,\n        base_converter=base_converter,\n        operator_manager=operator_manager,\n    )\n</code></pre>"},{"location":"expression/expression_node/#opulse.expression.expression_node.NumberNode.to_str_no_base_symbol","title":"<code>to_str_no_base_symbol(surround_symbol=None)</code>","text":"<p>Converts the node's value to a string without base symbols.</p> <p>Parameters:</p> Name Type Description Default <code>surround_symbol</code> <code>str</code> <p>The symbol surrounding the value.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>A string representation of the value.</p> Source code in <code>opulse/expression/expression_node.py</code> <pre><code>def to_str_no_base_symbol(self, surround_symbol: str = None):\n    \"\"\"\n    Converts the node's value to a string without base symbols.\n\n    Args:\n       surround_symbol: The symbol surrounding the value.\n\n    Returns:\n        (str): A string representation of the value.\n    \"\"\"\n    if surround_symbol:\n        return f\"{surround_symbol}{self.value}{surround_symbol}\"\n    else:\n        return f\"{self.value}\"\n</code></pre>"},{"location":"expression/expression_node/#opulse.expression.expression_node.UnaryExpressionNode","title":"<code>UnaryExpressionNode</code>","text":"<p>               Bases: <code>ExpressionNode</code></p> Source code in <code>opulse/expression/expression_node.py</code> <pre><code>class UnaryExpressionNode(ExpressionNode):\n    def __init__(self, operator: OperatorInfo):\n        \"\"\"\n        Initializes a unary expression node with an operator.\n\n        Args:\n            operator (OperatorInfo): The operator information for the expression.\n        \"\"\"\n        super().__init__()\n        self.operator = operator\n        self.unary_expr: ExpressionNode = None\n\n    def to_dict(self):\n        \"\"\"\n        Converts the unary expression node to a dictionary representation.\n\n        Returns:\n            (dict): A dictionary with the node's type, operator, and unary expression.\n        \"\"\"\n        return {\n            \"type\": \"unary\",\n            \"operator\": self.operator.symbol,\n            \"unary_expr\": self.unary_expr.to_dict(),\n        }\n</code></pre>"},{"location":"expression/expression_node/#opulse.expression.expression_node.UnaryExpressionNode.__init__","title":"<code>__init__(operator)</code>","text":"<p>Initializes a unary expression node with an operator.</p> <p>Parameters:</p> Name Type Description Default <code>operator</code> <code>OperatorInfo</code> <p>The operator information for the expression.</p> required Source code in <code>opulse/expression/expression_node.py</code> <pre><code>def __init__(self, operator: OperatorInfo):\n    \"\"\"\n    Initializes a unary expression node with an operator.\n\n    Args:\n        operator (OperatorInfo): The operator information for the expression.\n    \"\"\"\n    super().__init__()\n    self.operator = operator\n    self.unary_expr: ExpressionNode = None\n</code></pre>"},{"location":"expression/expression_node/#opulse.expression.expression_node.UnaryExpressionNode.to_dict","title":"<code>to_dict()</code>","text":"<p>Converts the unary expression node to a dictionary representation.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary with the node's type, operator, and unary expression.</p> Source code in <code>opulse/expression/expression_node.py</code> <pre><code>def to_dict(self):\n    \"\"\"\n    Converts the unary expression node to a dictionary representation.\n\n    Returns:\n        (dict): A dictionary with the node's type, operator, and unary expression.\n    \"\"\"\n    return {\n        \"type\": \"unary\",\n        \"operator\": self.operator.symbol,\n        \"unary_expr\": self.unary_expr.to_dict(),\n    }\n</code></pre>"},{"location":"expression/expression_node/#opulse.expression.expression_node.VariableNode","title":"<code>VariableNode</code>","text":"<p>               Bases: <code>ExpressionNode</code></p> Source code in <code>opulse/expression/expression_node.py</code> <pre><code>class VariableNode(ExpressionNode):\n    def __init__(self, variable: str):\n        \"\"\"\n        Initializes a variable node with a variable name.\n\n        Args:\n           variable (str): The name of the variable.\n        \"\"\"\n        super().__init__()\n        self.v = variable\n\n    def to_dict(self):\n        \"\"\"\n        Converts the variable node to a dictionary representation.\n\n        Returns:\n            (dict): A dictionary with the node's type and variable name.\n        \"\"\"\n        return {\n            \"type\": \"variable\",\n            \"variable\": self.v,\n        }\n</code></pre>"},{"location":"expression/expression_node/#opulse.expression.expression_node.VariableNode.__init__","title":"<code>__init__(variable)</code>","text":"<p>Initializes a variable node with a variable name.</p> <p>Parameters:</p> Name Type Description Default <code>variable</code> <code>str</code> <p>The name of the variable.</p> required Source code in <code>opulse/expression/expression_node.py</code> <pre><code>def __init__(self, variable: str):\n    \"\"\"\n    Initializes a variable node with a variable name.\n\n    Args:\n       variable (str): The name of the variable.\n    \"\"\"\n    super().__init__()\n    self.v = variable\n</code></pre>"},{"location":"expression/expression_node/#opulse.expression.expression_node.VariableNode.to_dict","title":"<code>to_dict()</code>","text":"<p>Converts the variable node to a dictionary representation.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary with the node's type and variable name.</p> Source code in <code>opulse/expression/expression_node.py</code> <pre><code>def to_dict(self):\n    \"\"\"\n    Converts the variable node to a dictionary representation.\n\n    Returns:\n        (dict): A dictionary with the node's type and variable name.\n    \"\"\"\n    return {\n        \"type\": \"variable\",\n        \"variable\": self.v,\n    }\n</code></pre>"},{"location":"operatorplus/compiler/","title":"CythonCompiler","text":""},{"location":"operatorplus/compiler/#opulse.operatorplus.compiler.CythonCompiler","title":"<code>CythonCompiler</code>","text":"Source code in <code>opulse/operatorplus/compiler.py</code> <pre><code>class CythonCompiler:\n    def __init__(self, compile_dir: str = './compiled_funcs'):\n        \"\"\"\n        Initializes the Cython compiler, sets the compilation directory, and ensures it exists.\n\n        Parameters:\n            compile_dir (str): Directory to store compiled modules, default is './compiled_funcs'.\n\n        Raises:\n            OSError: If the directory cannot be created due to permission issues or other errors.\n        \"\"\"\n        self.compile_dir = Path(compile_dir)\n        if not self.compile_dir.exists():\n            self.compile_dir.mkdir()\n\n        sys.setdlopenflags(os.RTLD_NOW | os.RTLD_GLOBAL)\n\n    def compile_function(self, func_code: str, func_name: str, deps: list = None) -&gt; None:\n        \"\"\"\n        Dynamically compiles a Cython function and generates a module.\n\n        Parameters:\n            func_code (str): The new function code provided as a string.\n            func_name (str): The function name, used to generate the module name and file name.\n            deps (List[str]): List of dependent modules, default is None (no dependencies).\n\n        Raises:\n            Exception: If there is an error during the compilation process.\n        \"\"\"\n        module_name = f\"module_{func_name}\"\n        if self.import_module(module_name) == None:\n\n            if deps is None:\n                deps = []\n\n\n            pyx_file_path = self.compile_dir / f\"{module_name}.pyx\"\n\n            with open(pyx_file_path, \"w\") as f:\n                for dep in deps:\n                    f.write(f\"from {dep} import *\\n\")\n                f.write(func_code)\n            try:\n                # os.system(f\"cythonize -a -i -j 8 -3 {pyx_file_path}\")\n                os.system(f\"cythonize -i -j 8 -3 {pyx_file_path}\")\n                # cythonize([str(pyx_file_path)], build_dir=str(self.compile_dir))\n                print(f\"Successfully compiled {module_name}\")\n            except Exception as e:\n                print(f\"Error compiling {module_name}: {e}\")\n\n\n    def import_module(self, module_name) -&gt; Optional[ModuleType]:\n        \"\"\"\n        Attempts to import the specified module from the compilation directory.\n\n        Parameters:\n            module_name (str): The name of the module.\n\n        Returns:\n            Optional[ModuleType]: Returns the imported module object on success; returns `None` on failure.\n\n        Raises:\n            ImportError: If the module cannot be imported due to missing dependencies or other issues.\n        \"\"\"\n        compiled_dir = str(Path(self.compile_dir).resolve())\n        # Ensure sys.path is set up correctly\n        if compiled_dir not in sys.path:\n            sys.path.insert(0, compiled_dir)\n        try:\n            # Try importing the module\n            imported_module = importlib.import_module(module_name)\n            print(f\"Module {module_name} imported successfully.\")\n            return imported_module\n        except Exception as e:\n            # print(f\"Error importing module {module_name}: {e}\")\n            return None\n\n    def import_module_from_path(self, module_name) -&gt; ModuleType:\n        \"\"\"\n        Dynamically loads a module via its `.so` file path.\n\n        Parameters:\n            module_name (str): The name of the module.\n\n        Returns:\n            ModuleType: Returns the loaded module object on success.\n\n        Raises:\n            FileNotFoundError: If the `.so` file does not exist in the specified directory.\n            ImportError: If the module cannot be loaded due to invalid file format or other issues.\n        \"\"\"\n\n        compiled_dir = str(Path(self.compile_dir).resolve())\n        so_file = f\"{module_name}.cpython-310-x86_64-linux-gnu.so\"\n        full_path = os.path.join(compiled_dir, so_file)\n\n        spec = importlib.util.spec_from_file_location(module_name, full_path)\n        module = importlib.util.module_from_spec(spec)\n        sys.modules[module_name] = ModuleType\n        spec.loader.exec_module(module)\n        return module\n</code></pre>"},{"location":"operatorplus/compiler/#opulse.operatorplus.compiler.CythonCompiler.__init__","title":"<code>__init__(compile_dir='./compiled_funcs')</code>","text":"<p>Initializes the Cython compiler, sets the compilation directory, and ensures it exists.</p> <p>Parameters:</p> Name Type Description Default <code>compile_dir</code> <code>str</code> <p>Directory to store compiled modules, default is './compiled_funcs'.</p> <code>'./compiled_funcs'</code> <p>Raises:</p> Type Description <code>OSError</code> <p>If the directory cannot be created due to permission issues or other errors.</p> Source code in <code>opulse/operatorplus/compiler.py</code> <pre><code>def __init__(self, compile_dir: str = './compiled_funcs'):\n    \"\"\"\n    Initializes the Cython compiler, sets the compilation directory, and ensures it exists.\n\n    Parameters:\n        compile_dir (str): Directory to store compiled modules, default is './compiled_funcs'.\n\n    Raises:\n        OSError: If the directory cannot be created due to permission issues or other errors.\n    \"\"\"\n    self.compile_dir = Path(compile_dir)\n    if not self.compile_dir.exists():\n        self.compile_dir.mkdir()\n\n    sys.setdlopenflags(os.RTLD_NOW | os.RTLD_GLOBAL)\n</code></pre>"},{"location":"operatorplus/compiler/#opulse.operatorplus.compiler.CythonCompiler.compile_function","title":"<code>compile_function(func_code, func_name, deps=None)</code>","text":"<p>Dynamically compiles a Cython function and generates a module.</p> <p>Parameters:</p> Name Type Description Default <code>func_code</code> <code>str</code> <p>The new function code provided as a string.</p> required <code>func_name</code> <code>str</code> <p>The function name, used to generate the module name and file name.</p> required <code>deps</code> <code>List[str]</code> <p>List of dependent modules, default is None (no dependencies).</p> <code>None</code> <p>Raises:</p> Type Description <code>Exception</code> <p>If there is an error during the compilation process.</p> Source code in <code>opulse/operatorplus/compiler.py</code> <pre><code>def compile_function(self, func_code: str, func_name: str, deps: list = None) -&gt; None:\n    \"\"\"\n    Dynamically compiles a Cython function and generates a module.\n\n    Parameters:\n        func_code (str): The new function code provided as a string.\n        func_name (str): The function name, used to generate the module name and file name.\n        deps (List[str]): List of dependent modules, default is None (no dependencies).\n\n    Raises:\n        Exception: If there is an error during the compilation process.\n    \"\"\"\n    module_name = f\"module_{func_name}\"\n    if self.import_module(module_name) == None:\n\n        if deps is None:\n            deps = []\n\n\n        pyx_file_path = self.compile_dir / f\"{module_name}.pyx\"\n\n        with open(pyx_file_path, \"w\") as f:\n            for dep in deps:\n                f.write(f\"from {dep} import *\\n\")\n            f.write(func_code)\n        try:\n            # os.system(f\"cythonize -a -i -j 8 -3 {pyx_file_path}\")\n            os.system(f\"cythonize -i -j 8 -3 {pyx_file_path}\")\n            # cythonize([str(pyx_file_path)], build_dir=str(self.compile_dir))\n            print(f\"Successfully compiled {module_name}\")\n        except Exception as e:\n            print(f\"Error compiling {module_name}: {e}\")\n</code></pre>"},{"location":"operatorplus/compiler/#opulse.operatorplus.compiler.CythonCompiler.import_module","title":"<code>import_module(module_name)</code>","text":"<p>Attempts to import the specified module from the compilation directory.</p> <p>Parameters:</p> Name Type Description Default <code>module_name</code> <code>str</code> <p>The name of the module.</p> required <p>Returns:</p> Type Description <code>Optional[ModuleType]</code> <p>Optional[ModuleType]: Returns the imported module object on success; returns <code>None</code> on failure.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If the module cannot be imported due to missing dependencies or other issues.</p> Source code in <code>opulse/operatorplus/compiler.py</code> <pre><code>def import_module(self, module_name) -&gt; Optional[ModuleType]:\n    \"\"\"\n    Attempts to import the specified module from the compilation directory.\n\n    Parameters:\n        module_name (str): The name of the module.\n\n    Returns:\n        Optional[ModuleType]: Returns the imported module object on success; returns `None` on failure.\n\n    Raises:\n        ImportError: If the module cannot be imported due to missing dependencies or other issues.\n    \"\"\"\n    compiled_dir = str(Path(self.compile_dir).resolve())\n    # Ensure sys.path is set up correctly\n    if compiled_dir not in sys.path:\n        sys.path.insert(0, compiled_dir)\n    try:\n        # Try importing the module\n        imported_module = importlib.import_module(module_name)\n        print(f\"Module {module_name} imported successfully.\")\n        return imported_module\n    except Exception as e:\n        # print(f\"Error importing module {module_name}: {e}\")\n        return None\n</code></pre>"},{"location":"operatorplus/compiler/#opulse.operatorplus.compiler.CythonCompiler.import_module_from_path","title":"<code>import_module_from_path(module_name)</code>","text":"<p>Dynamically loads a module via its <code>.so</code> file path.</p> <p>Parameters:</p> Name Type Description Default <code>module_name</code> <code>str</code> <p>The name of the module.</p> required <p>Returns:</p> Name Type Description <code>ModuleType</code> <code>ModuleType</code> <p>Returns the loaded module object on success.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the <code>.so</code> file does not exist in the specified directory.</p> <code>ImportError</code> <p>If the module cannot be loaded due to invalid file format or other issues.</p> Source code in <code>opulse/operatorplus/compiler.py</code> <pre><code>def import_module_from_path(self, module_name) -&gt; ModuleType:\n    \"\"\"\n    Dynamically loads a module via its `.so` file path.\n\n    Parameters:\n        module_name (str): The name of the module.\n\n    Returns:\n        ModuleType: Returns the loaded module object on success.\n\n    Raises:\n        FileNotFoundError: If the `.so` file does not exist in the specified directory.\n        ImportError: If the module cannot be loaded due to invalid file format or other issues.\n    \"\"\"\n\n    compiled_dir = str(Path(self.compile_dir).resolve())\n    so_file = f\"{module_name}.cpython-310-x86_64-linux-gnu.so\"\n    full_path = os.path.join(compiled_dir, so_file)\n\n    spec = importlib.util.spec_from_file_location(module_name, full_path)\n    module = importlib.util.module_from_spec(spec)\n    sys.modules[module_name] = ModuleType\n    spec.loader.exec_module(module)\n    return module\n</code></pre>"},{"location":"operatorplus/condition_generator/","title":"ConditionGenerator","text":""},{"location":"operatorplus/condition_generator/#opulse.operatorplus.condition_generator.ConditionGenerator","title":"<code>ConditionGenerator</code>","text":"Source code in <code>opulse/operatorplus/condition_generator.py</code> <pre><code>class ConditionGenerator:\n    def __init__(\n        self,\n        param_config: ParamConfig,\n        logger: LogConfig,\n        operator_manager: \"OperatorManager\" = None,\n    ):\n        \"\"\"\n        Initializes the generator with a list of variable names, unary operators, binary operators, \n        numeric range for values, and the range for the number of conditions to generate.\n\n        Parameters:\n            param_config (ParamConfig): Configuration object containing necessary settings.\n            logger (LogConfig): Logger configuration object for logging.\n            operator_manager (OperatorManager, optional): Operator manager object for accessing operator information.\n        \"\"\"\n        self.param_config = param_config\n        self.logger = logger.get_logger()\n        self.operator_manager = operator_manager\n        self.variables = [self.param_config.atoms[\"left_operand\"], self.param_config.atoms[\"right_operand\"]]\n        self.comparison_ops = self.param_config.get(\"comparison_ops\")\n        self.logical_connectors = self.param_config.get(\"logical_connectors\")\n        self.min_value = self.param_config.get(\"condition_numeric_range\")[\"min_value\"]\n        self.max_value = self.param_config.get(\"condition_numeric_range\")[\"max_value\"]\n        self.condition_probabilities = self.param_config.get('condition_probabilities')\n\n        # Log initial configuration\n        self.logger.debug(f\"ConditionGenerator initialized with variables: {self.variables}\")\n        self.logger.debug(f\"Comparison operators: {self.comparison_ops}\")\n        self.logger.debug(f\"Logical connectors: {self.logical_connectors}\")\n        self.logger.debug(f\"Numeric range: {self.min_value} to {self.max_value}\")\n\n    def set_variables(self, new_variables: List[str]):\n        \"\"\"\n        Sets new values for the list of variables.\n\n        Parameters:\n            new_variables (List[str]): A new list of variables, e.g., ['a'] or ['a', 'b'].\n        \"\"\"\n        self.variables = new_variables\n        self.logger.debug(f\"Variables set to: {self.variables}\")\n\n    def set_condition_probabilities(self, condition_probs: Dict[int, float]):\n        \"\"\"\n        Sets the condition probability dictionary. The keys are numbers and the values are probabilities.\n        If an empty dictionary is passed, the default values are restored.\n\n        Parameters:\n            condition_probs (Dict[int, float]): A dictionary of condition probabilities, where keys are numbers and values are the probabilities.\n\n        Raises:\n            ValueError: If the values in the probability dictionary are not within the valid range (0, 1).\n        \"\"\"\n        # Check if the values in the dictionary are valid probabilities\n        for key, prob in condition_probs.items():\n            if not (0 &lt;= prob &lt;= 1):  # Ensure the probability is between 0 and 1\n                raise ValueError(f\"Probability for key {key} is out of valid range: {prob}\")\n\n        self.condition_probabilities = condition_probs\n        self.param_config['condition_probabilities'] = condition_probs\n        self.logger.debug(f\"Condition probabilities set to: {self.condition_probabilities}\")\n\n    def generate_operand(self, var: str) -&gt; str:\n        \"\"\"\n        Randomly generates an expression with a unary or binary operator, or simply returns a variable.\n\n        Parameters:\n            var (str): The variable name.\n\n        Returns:\n            str: The generated expression, which can be a variable, a unary operator applied to the variable, \n                 or a binary operator with a constant.\n        \"\"\"\n        unary_prefix_ops, unary_postfix_ops, binary_ops = (\n            self.operator_manager.get_unary_and_binary_operators()\n        )\n        # Randomly choose the type of expression to generate: variable, unary operator, or binary operator\n        expr_type = random.choice(\n            [\"variable\", \"unary_prefix\", \"unary_postfix\", \"binary\"]\n        )\n        self.logger.debug(f\"Generating operand for variable '{var}', chosen type: {expr_type}\")\n\n        if expr_type == \"unary_prefix\" and unary_prefix_ops:\n            # Generate unary operator prefix expression\n            unary_op = random.choice(unary_prefix_ops).symbol\n            self.logger.debug(f\"Generated unary prefix operator: {unary_op}\")\n            return f\"{self.param_config.atoms['left_parenthesis']}{unary_op}{var}{self.param_config.atoms['right_parenthesis']}\"\n\n        elif expr_type == \"unary_postfix\" and unary_postfix_ops:\n            # Generate unary operator postfix expression\n            unary_op = random.choice(unary_postfix_ops).symbol\n            self.logger.debug(f\"Generated unary postfix operator: {unary_op}\")\n            return f\"{self.param_config.atoms['left_parenthesis']}{var}{unary_op}{self.param_config.atoms['right_parenthesis']}\"\n\n        elif expr_type == \"binary\" and binary_ops:\n            # Generate binary operator expression\n            binary_op = random.choice(binary_ops).symbol\n            value = random.randint(self.min_value, self.max_value)  # Can adjust the range\n            self.logger.debug(f\"Generated binary operator: {binary_op} with value: {value}\")\n            return f\"{self.param_config.atoms['left_parenthesis']}{var} {binary_op} {value}{self.param_config.atoms['right_parenthesis']}\"\n\n        # Return the variable itself\n        self.logger.debug(f\"Returning variable: {var}\")\n        return var\n\n    def generate_condition(self) -&gt; str:\n        \"\"\"\n        Generates a condition expression.\n\n        Returns:\n            str: The generated condition expression, in the form \"operand comparison_op value\".\n        \"\"\"\n        var = random.choice(self.variables)\n        operand = self.generate_operand(var)\n        comp_op = random.choice(self.comparison_ops)\n        mid_value = random.randint(self.min_value, self.max_value)\n        value = random.randint(self.min_value, mid_value)\n        condition = f\"{operand} {comp_op} {value}\"\n        self.logger.debug(f\"Generated condition: {condition}\")\n        return condition\n\n    def choose_num_conditions(self) -&gt; int:\n        \"\"\"\n        Chooses the number of conditions based on the probability distribution in condition_probabilities.\n\n        Returns:\n            int: The number of conditions to generate, selected based on the probability distribution.\n        \"\"\"\n        # Select the number of conditions based on the given probability distribution\n        population = list(self.condition_probabilities.keys())\n        weights = list(self.condition_probabilities.values())\n        num_conditions = random.choices(population, weights=weights, k=1)[0]\n        self.logger.debug(f\"Chosen number of conditions: {num_conditions}\")\n        return num_conditions\n\n\n    ##!\u8fd9\u4e2a\u5730\u65b9\u597d\u50cf\u5199\u7684\u6709\u70b9\u95ee\u9898\uff0c\u611f\u89c9\u90fd\u7528\u4e00\u4e2a\u8fde\u63a5\u8bcd\u8fde\u63a5\u4e86\u554a\n    def generate_condition_expr(self) -&gt; str:\n        \"\"\"\n        Generates an expression consisting of multiple conditions, including logical operators and condition parentheses.\n\n        Returns:\n            str: The generated condition expression, which can either be a single condition or a combination of conditions connected by logical operators.\n        \"\"\"\n        # Choose the number of conditions based on condition_probabilities\n        num_conditions = self.choose_num_conditions()\n\n        # Generate the list of conditions\n        conditions = [self.generate_condition() for _ in range(num_conditions)]\n        self.logger.debug(f\"Generated conditions: {conditions}\")\n\n        # Concatenate the conditions to form the final expression\n        if num_conditions == 1:\n            condition_expr = conditions[0]\n        else:\n            # Combine conditions with randomly chosen logical operators\n            expr_parts = [conditions[0]]\n            for i in range(1, num_conditions):\n                connector = random.choice(self.logical_connectors)  # Pick a different connector for each pair\n                expr_parts.append(connector)\n                expr_parts.append(conditions[i])\n\n                # Randomly decide whether to wrap the last two conditions with parentheses\n                if random.choice([True, False]):\n                    expr_parts[-3:] = [f\"({expr_parts[-3]} {expr_parts[-2]} {expr_parts[-1]})\"]\n\n            condition_expr = \" \".join(expr_parts)\n\n            self.logger.debug(f\"Generated final conditional expression: {condition_expr}\")\n            self.logger.info(f\"Generated final conditional expression: {condition_expr}\")\n            return condition_expr\n</code></pre>"},{"location":"operatorplus/condition_generator/#opulse.operatorplus.condition_generator.ConditionGenerator.__init__","title":"<code>__init__(param_config, logger, operator_manager=None)</code>","text":"<p>Initializes the generator with a list of variable names, unary operators, binary operators,  numeric range for values, and the range for the number of conditions to generate.</p> <p>Parameters:</p> Name Type Description Default <code>param_config</code> <code>ParamConfig</code> <p>Configuration object containing necessary settings.</p> required <code>logger</code> <code>LogConfig</code> <p>Logger configuration object for logging.</p> required <code>operator_manager</code> <code>OperatorManager</code> <p>Operator manager object for accessing operator information.</p> <code>None</code> Source code in <code>opulse/operatorplus/condition_generator.py</code> <pre><code>def __init__(\n    self,\n    param_config: ParamConfig,\n    logger: LogConfig,\n    operator_manager: \"OperatorManager\" = None,\n):\n    \"\"\"\n    Initializes the generator with a list of variable names, unary operators, binary operators, \n    numeric range for values, and the range for the number of conditions to generate.\n\n    Parameters:\n        param_config (ParamConfig): Configuration object containing necessary settings.\n        logger (LogConfig): Logger configuration object for logging.\n        operator_manager (OperatorManager, optional): Operator manager object for accessing operator information.\n    \"\"\"\n    self.param_config = param_config\n    self.logger = logger.get_logger()\n    self.operator_manager = operator_manager\n    self.variables = [self.param_config.atoms[\"left_operand\"], self.param_config.atoms[\"right_operand\"]]\n    self.comparison_ops = self.param_config.get(\"comparison_ops\")\n    self.logical_connectors = self.param_config.get(\"logical_connectors\")\n    self.min_value = self.param_config.get(\"condition_numeric_range\")[\"min_value\"]\n    self.max_value = self.param_config.get(\"condition_numeric_range\")[\"max_value\"]\n    self.condition_probabilities = self.param_config.get('condition_probabilities')\n\n    # Log initial configuration\n    self.logger.debug(f\"ConditionGenerator initialized with variables: {self.variables}\")\n    self.logger.debug(f\"Comparison operators: {self.comparison_ops}\")\n    self.logger.debug(f\"Logical connectors: {self.logical_connectors}\")\n    self.logger.debug(f\"Numeric range: {self.min_value} to {self.max_value}\")\n</code></pre>"},{"location":"operatorplus/condition_generator/#opulse.operatorplus.condition_generator.ConditionGenerator.choose_num_conditions","title":"<code>choose_num_conditions()</code>","text":"<p>Chooses the number of conditions based on the probability distribution in condition_probabilities.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of conditions to generate, selected based on the probability distribution.</p> Source code in <code>opulse/operatorplus/condition_generator.py</code> <pre><code>def choose_num_conditions(self) -&gt; int:\n    \"\"\"\n    Chooses the number of conditions based on the probability distribution in condition_probabilities.\n\n    Returns:\n        int: The number of conditions to generate, selected based on the probability distribution.\n    \"\"\"\n    # Select the number of conditions based on the given probability distribution\n    population = list(self.condition_probabilities.keys())\n    weights = list(self.condition_probabilities.values())\n    num_conditions = random.choices(population, weights=weights, k=1)[0]\n    self.logger.debug(f\"Chosen number of conditions: {num_conditions}\")\n    return num_conditions\n</code></pre>"},{"location":"operatorplus/condition_generator/#opulse.operatorplus.condition_generator.ConditionGenerator.generate_condition","title":"<code>generate_condition()</code>","text":"<p>Generates a condition expression.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The generated condition expression, in the form \"operand comparison_op value\".</p> Source code in <code>opulse/operatorplus/condition_generator.py</code> <pre><code>def generate_condition(self) -&gt; str:\n    \"\"\"\n    Generates a condition expression.\n\n    Returns:\n        str: The generated condition expression, in the form \"operand comparison_op value\".\n    \"\"\"\n    var = random.choice(self.variables)\n    operand = self.generate_operand(var)\n    comp_op = random.choice(self.comparison_ops)\n    mid_value = random.randint(self.min_value, self.max_value)\n    value = random.randint(self.min_value, mid_value)\n    condition = f\"{operand} {comp_op} {value}\"\n    self.logger.debug(f\"Generated condition: {condition}\")\n    return condition\n</code></pre>"},{"location":"operatorplus/condition_generator/#opulse.operatorplus.condition_generator.ConditionGenerator.generate_condition_expr","title":"<code>generate_condition_expr()</code>","text":"<p>Generates an expression consisting of multiple conditions, including logical operators and condition parentheses.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The generated condition expression, which can either be a single condition or a combination of conditions connected by logical operators.</p> Source code in <code>opulse/operatorplus/condition_generator.py</code> <pre><code>def generate_condition_expr(self) -&gt; str:\n    \"\"\"\n    Generates an expression consisting of multiple conditions, including logical operators and condition parentheses.\n\n    Returns:\n        str: The generated condition expression, which can either be a single condition or a combination of conditions connected by logical operators.\n    \"\"\"\n    # Choose the number of conditions based on condition_probabilities\n    num_conditions = self.choose_num_conditions()\n\n    # Generate the list of conditions\n    conditions = [self.generate_condition() for _ in range(num_conditions)]\n    self.logger.debug(f\"Generated conditions: {conditions}\")\n\n    # Concatenate the conditions to form the final expression\n    if num_conditions == 1:\n        condition_expr = conditions[0]\n    else:\n        # Combine conditions with randomly chosen logical operators\n        expr_parts = [conditions[0]]\n        for i in range(1, num_conditions):\n            connector = random.choice(self.logical_connectors)  # Pick a different connector for each pair\n            expr_parts.append(connector)\n            expr_parts.append(conditions[i])\n\n            # Randomly decide whether to wrap the last two conditions with parentheses\n            if random.choice([True, False]):\n                expr_parts[-3:] = [f\"({expr_parts[-3]} {expr_parts[-2]} {expr_parts[-1]})\"]\n\n        condition_expr = \" \".join(expr_parts)\n\n        self.logger.debug(f\"Generated final conditional expression: {condition_expr}\")\n        self.logger.info(f\"Generated final conditional expression: {condition_expr}\")\n        return condition_expr\n</code></pre>"},{"location":"operatorplus/condition_generator/#opulse.operatorplus.condition_generator.ConditionGenerator.generate_operand","title":"<code>generate_operand(var)</code>","text":"<p>Randomly generates an expression with a unary or binary operator, or simply returns a variable.</p> <p>Parameters:</p> Name Type Description Default <code>var</code> <code>str</code> <p>The variable name.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The generated expression, which can be a variable, a unary operator applied to the variable,   or a binary operator with a constant.</p> Source code in <code>opulse/operatorplus/condition_generator.py</code> <pre><code>def generate_operand(self, var: str) -&gt; str:\n    \"\"\"\n    Randomly generates an expression with a unary or binary operator, or simply returns a variable.\n\n    Parameters:\n        var (str): The variable name.\n\n    Returns:\n        str: The generated expression, which can be a variable, a unary operator applied to the variable, \n             or a binary operator with a constant.\n    \"\"\"\n    unary_prefix_ops, unary_postfix_ops, binary_ops = (\n        self.operator_manager.get_unary_and_binary_operators()\n    )\n    # Randomly choose the type of expression to generate: variable, unary operator, or binary operator\n    expr_type = random.choice(\n        [\"variable\", \"unary_prefix\", \"unary_postfix\", \"binary\"]\n    )\n    self.logger.debug(f\"Generating operand for variable '{var}', chosen type: {expr_type}\")\n\n    if expr_type == \"unary_prefix\" and unary_prefix_ops:\n        # Generate unary operator prefix expression\n        unary_op = random.choice(unary_prefix_ops).symbol\n        self.logger.debug(f\"Generated unary prefix operator: {unary_op}\")\n        return f\"{self.param_config.atoms['left_parenthesis']}{unary_op}{var}{self.param_config.atoms['right_parenthesis']}\"\n\n    elif expr_type == \"unary_postfix\" and unary_postfix_ops:\n        # Generate unary operator postfix expression\n        unary_op = random.choice(unary_postfix_ops).symbol\n        self.logger.debug(f\"Generated unary postfix operator: {unary_op}\")\n        return f\"{self.param_config.atoms['left_parenthesis']}{var}{unary_op}{self.param_config.atoms['right_parenthesis']}\"\n\n    elif expr_type == \"binary\" and binary_ops:\n        # Generate binary operator expression\n        binary_op = random.choice(binary_ops).symbol\n        value = random.randint(self.min_value, self.max_value)  # Can adjust the range\n        self.logger.debug(f\"Generated binary operator: {binary_op} with value: {value}\")\n        return f\"{self.param_config.atoms['left_parenthesis']}{var} {binary_op} {value}{self.param_config.atoms['right_parenthesis']}\"\n\n    # Return the variable itself\n    self.logger.debug(f\"Returning variable: {var}\")\n    return var\n</code></pre>"},{"location":"operatorplus/condition_generator/#opulse.operatorplus.condition_generator.ConditionGenerator.set_condition_probabilities","title":"<code>set_condition_probabilities(condition_probs)</code>","text":"<p>Sets the condition probability dictionary. The keys are numbers and the values are probabilities. If an empty dictionary is passed, the default values are restored.</p> <p>Parameters:</p> Name Type Description Default <code>condition_probs</code> <code>Dict[int, float]</code> <p>A dictionary of condition probabilities, where keys are numbers and values are the probabilities.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the values in the probability dictionary are not within the valid range (0, 1).</p> Source code in <code>opulse/operatorplus/condition_generator.py</code> <pre><code>def set_condition_probabilities(self, condition_probs: Dict[int, float]):\n    \"\"\"\n    Sets the condition probability dictionary. The keys are numbers and the values are probabilities.\n    If an empty dictionary is passed, the default values are restored.\n\n    Parameters:\n        condition_probs (Dict[int, float]): A dictionary of condition probabilities, where keys are numbers and values are the probabilities.\n\n    Raises:\n        ValueError: If the values in the probability dictionary are not within the valid range (0, 1).\n    \"\"\"\n    # Check if the values in the dictionary are valid probabilities\n    for key, prob in condition_probs.items():\n        if not (0 &lt;= prob &lt;= 1):  # Ensure the probability is between 0 and 1\n            raise ValueError(f\"Probability for key {key} is out of valid range: {prob}\")\n\n    self.condition_probabilities = condition_probs\n    self.param_config['condition_probabilities'] = condition_probs\n    self.logger.debug(f\"Condition probabilities set to: {self.condition_probabilities}\")\n</code></pre>"},{"location":"operatorplus/condition_generator/#opulse.operatorplus.condition_generator.ConditionGenerator.set_variables","title":"<code>set_variables(new_variables)</code>","text":"<p>Sets new values for the list of variables.</p> <p>Parameters:</p> Name Type Description Default <code>new_variables</code> <code>List[str]</code> <p>A new list of variables, e.g., ['a'] or ['a', 'b'].</p> required Source code in <code>opulse/operatorplus/condition_generator.py</code> <pre><code>def set_variables(self, new_variables: List[str]):\n    \"\"\"\n    Sets new values for the list of variables.\n\n    Parameters:\n        new_variables (List[str]): A new list of variables, e.g., ['a'] or ['a', 'b'].\n    \"\"\"\n    self.variables = new_variables\n    self.logger.debug(f\"Variables set to: {self.variables}\")\n</code></pre>"},{"location":"operatorplus/operator_definition_parser/","title":"OperatorDefinitionParser.md","text":""},{"location":"operatorplus/operator_definition_parser/#opulse.operatorplus.operator_definition_parser.OperatorDefinitionParser","title":"<code>OperatorDefinitionParser</code>","text":"<p>A parser class for dynamically generating and parsing operator definitions.</p> <p>This class constructs a grammar dynamically based on the provided <code>ParamConfig</code> and uses the <code>Lark</code> parser  to parse operator definitions. The class supports parsing expressions that involve various operators, conditions,  and logical structures such as \"if\", \"else\", and logical conditions.</p> <p>Attributes:</p> Name Type Description <code>param_config</code> <code>ParamConfig</code> <p>Configuration object containing atoms like operators, parenthesis, and constants.</p> <code>logger</code> <code>LogConfig</code> <p>Logger configuration to record debugging and information logs.</p> <code>parser</code> <code>Lark</code> <p>The Lark parser instance to parse operator definitions.</p> <code>grammar</code> <code>str</code> <p>The dynamically generated grammar used by the Lark parser.</p> Source code in <code>opulse/operatorplus/operator_definition_parser.py</code> <pre><code>class OperatorDefinitionParser:\n    \"\"\"\n    A parser class for dynamically generating and parsing operator definitions.\n\n    This class constructs a grammar dynamically based on the provided `ParamConfig` and uses the `Lark` parser \n    to parse operator definitions. The class supports parsing expressions that involve various operators, conditions, \n    and logical structures such as \"if\", \"else\", and logical conditions.\n\n    Attributes:\n        param_config (ParamConfig): Configuration object containing atoms like operators, parenthesis, and constants.\n        logger (LogConfig): Logger configuration to record debugging and information logs.\n        parser (Lark): The Lark parser instance to parse operator definitions.\n        grammar (str): The dynamically generated grammar used by the Lark parser.\n    \"\"\"\n\n    def __init__(self, param_config: ParamConfig, logger: LogConfig):\n        \"\"\"\n        Initializes the OperatorDefinitionParser with given configuration and logger.\n\n        Args:\n            param_config (ParamConfig): A configuration object that contains parameter definitions, \n                                         including operators, atomic values, and symbols.\n            logger (LogConfig): A logging configuration object used to log debugging and info messages.\n\n        Initializes the grammar dynamically using the `param_config` and configures the Lark parser.\n        \"\"\"\n\n        # Store the provided param_config and logger\n        self.param_config = param_config\n        self.logger = logger.get_logger()\n\n        # Dynamically construct the grammar using `param_config`\n        self.grammar = f\"\"\"\n        ?start: rule\n        rule: lhs_expr \"{self.param_config.atoms[\"equal\"]}\" \"{{\" rhs_expr \"}}\"\n        lhs_expr: expr\n        rhs_expr: branch (SEMICOLON branch)* \n        ?branch: if_branch\n            | else_branch\n            | unconditional_branch\n        if_branch: expr \",\" \"if\" condition\n        else_branch: expr \",\" \"else\"\n        unconditional_branch: expr\n        ?condition: or_condition\n        ?or_condition: or_condition \"or\" and_condition    -&gt; or_condition\n                    | and_condition\n        ?and_condition: and_condition \"and\" comparison     -&gt; and_condition\n                    | comparison\n        ?comparison: \"not\" comparison                      -&gt; not_condition\n                | expr CONDITION_OPERATOR expr          -&gt; comparison\n                | \"{self.param_config.atoms[\"left_parenthesis\"]}\" condition \"{self.param_config.atoms[\"right_parenthesis\"]}\"   -&gt; grouped_condition \n        ?expr: expr OPERATOR term  -&gt; binary_operation\n            | term\n        ?term: factor\n            | OPERATOR factor      -&gt; unary_operation_prefix\n            | factor OPERATOR      -&gt; unary_operation_postfix\n        ?factor: \"{self.param_config.atoms[\"nan\"]}\"          -&gt; no_solution\n            | VARIABLE      -&gt;variable_conversion\n            | INT           -&gt;int_conversion\n            | \"{self.param_config.atoms[\"left_parenthesis\"]}\" expr \"{self.param_config.atoms[\"right_parenthesis\"]}\"\n        OPERATOR: SYMBOL+\n        SYMBOL: \"+\" | \"-\" | \"*\" | \"/\" | \"%\" | /[\\u2200-\\u22FF\\u2A00-\\u2BFF\\u2190-\\u21FF]+/\n        CONDITION_OPERATOR: \"==\" | \"&gt;\" | \"&lt;\" | \"&gt;=\" | \"&lt;=\"| \"!=\"\n        VARIABLE: /[a-zA-Z]/\n        NO_SOLUTION: \"{self.param_config.atoms[\"nan\"]}\"   \n        SEMICOLON: \";\"\n        %import common.INT\n        %import common.WS\n        %ignore WS\n        \"\"\"\n\n        # Logging the generated grammar for debugging\n        self.logger.debug(f\"Generated grammar: {self.grammar}\")\n\n        # Initialize the Lark parser with the dynamically generated grammar\n        self.parser = Lark(self.grammar, start=\"start\")\n\n        # Log that the parser has been successfully initialized\n        self.logger.info(\"OperatorDefinitionParser initialized successfully.\")\n\n    def parse_definition(self, definition):\n        \"\"\"\n        Parse the given operator definition using the generated grammar.\n\n        Args:\n            definition (str): The operator definition string to be parsed.\n\n        Returns:\n            Lark.Tree: A Lark parsing tree representing the parsed definition.\n\n        Logs the parsing process and any issues during parsing.\n        \"\"\"\n        try:\n            self.logger.info(f\"Attempting to parse definition: {definition}\")\n            parsed_tree = self.parser.parse(definition)\n            self.logger.info(\"Parsing successful.\")\n            return parsed_tree\n        except Exception as e:\n            self.logger.error(f\"Error while parsing definition: {e}\")\n            raise\n\n    def update_definition(self, definition) -&gt; str:\n        \"\"\"\n        Update the operator definition by replacing indexed numeric atoms with their values from `param_config`.\n\n        This method performs a replacement in the expression, replacing placeholders such as '0', '1', etc. \n        with corresponding values from `numeric_atoms`.\n\n        Args:\n            definition (str): The operator definition to be updated.\n\n        Returns:\n            str: The updated operator definition with numeric atoms replaced.\n\n        Logs each replacement performed in the update process for debugging.\n        \"\"\"\n        updated_expr = definition\n\n        self.logger.info(f\"Starting update of definition: {definition}\")\n\n        # Limit to the first 10 numeric atoms for replacement\n        for idx, numeric_atom in enumerate(self.param_config.atoms[\"numeric_atoms\"][:10]):\n            self.logger.debug(f\"Replacing index '{idx}' with numeric atom value '{numeric_atom}'\")\n            updated_expr = updated_expr.replace(f'{idx}', str(numeric_atom))\n\n        self.logger.info(f\"Updated definition: {updated_expr}\")\n        return updated_expr\n</code></pre>"},{"location":"operatorplus/operator_definition_parser/#opulse.operatorplus.operator_definition_parser.OperatorDefinitionParser.__init__","title":"<code>__init__(param_config, logger)</code>","text":"<p>Initializes the OperatorDefinitionParser with given configuration and logger.</p> <p>Parameters:</p> Name Type Description Default <code>param_config</code> <code>ParamConfig</code> <p>A configuration object that contains parameter definitions,                           including operators, atomic values, and symbols.</p> required <code>logger</code> <code>LogConfig</code> <p>A logging configuration object used to log debugging and info messages.</p> required <p>Initializes the grammar dynamically using the <code>param_config</code> and configures the Lark parser.</p> Source code in <code>opulse/operatorplus/operator_definition_parser.py</code> <pre><code>def __init__(self, param_config: ParamConfig, logger: LogConfig):\n    \"\"\"\n    Initializes the OperatorDefinitionParser with given configuration and logger.\n\n    Args:\n        param_config (ParamConfig): A configuration object that contains parameter definitions, \n                                     including operators, atomic values, and symbols.\n        logger (LogConfig): A logging configuration object used to log debugging and info messages.\n\n    Initializes the grammar dynamically using the `param_config` and configures the Lark parser.\n    \"\"\"\n\n    # Store the provided param_config and logger\n    self.param_config = param_config\n    self.logger = logger.get_logger()\n\n    # Dynamically construct the grammar using `param_config`\n    self.grammar = f\"\"\"\n    ?start: rule\n    rule: lhs_expr \"{self.param_config.atoms[\"equal\"]}\" \"{{\" rhs_expr \"}}\"\n    lhs_expr: expr\n    rhs_expr: branch (SEMICOLON branch)* \n    ?branch: if_branch\n        | else_branch\n        | unconditional_branch\n    if_branch: expr \",\" \"if\" condition\n    else_branch: expr \",\" \"else\"\n    unconditional_branch: expr\n    ?condition: or_condition\n    ?or_condition: or_condition \"or\" and_condition    -&gt; or_condition\n                | and_condition\n    ?and_condition: and_condition \"and\" comparison     -&gt; and_condition\n                | comparison\n    ?comparison: \"not\" comparison                      -&gt; not_condition\n            | expr CONDITION_OPERATOR expr          -&gt; comparison\n            | \"{self.param_config.atoms[\"left_parenthesis\"]}\" condition \"{self.param_config.atoms[\"right_parenthesis\"]}\"   -&gt; grouped_condition \n    ?expr: expr OPERATOR term  -&gt; binary_operation\n        | term\n    ?term: factor\n        | OPERATOR factor      -&gt; unary_operation_prefix\n        | factor OPERATOR      -&gt; unary_operation_postfix\n    ?factor: \"{self.param_config.atoms[\"nan\"]}\"          -&gt; no_solution\n        | VARIABLE      -&gt;variable_conversion\n        | INT           -&gt;int_conversion\n        | \"{self.param_config.atoms[\"left_parenthesis\"]}\" expr \"{self.param_config.atoms[\"right_parenthesis\"]}\"\n    OPERATOR: SYMBOL+\n    SYMBOL: \"+\" | \"-\" | \"*\" | \"/\" | \"%\" | /[\\u2200-\\u22FF\\u2A00-\\u2BFF\\u2190-\\u21FF]+/\n    CONDITION_OPERATOR: \"==\" | \"&gt;\" | \"&lt;\" | \"&gt;=\" | \"&lt;=\"| \"!=\"\n    VARIABLE: /[a-zA-Z]/\n    NO_SOLUTION: \"{self.param_config.atoms[\"nan\"]}\"   \n    SEMICOLON: \";\"\n    %import common.INT\n    %import common.WS\n    %ignore WS\n    \"\"\"\n\n    # Logging the generated grammar for debugging\n    self.logger.debug(f\"Generated grammar: {self.grammar}\")\n\n    # Initialize the Lark parser with the dynamically generated grammar\n    self.parser = Lark(self.grammar, start=\"start\")\n\n    # Log that the parser has been successfully initialized\n    self.logger.info(\"OperatorDefinitionParser initialized successfully.\")\n</code></pre>"},{"location":"operatorplus/operator_definition_parser/#opulse.operatorplus.operator_definition_parser.OperatorDefinitionParser.parse_definition","title":"<code>parse_definition(definition)</code>","text":"<p>Parse the given operator definition using the generated grammar.</p> <p>Parameters:</p> Name Type Description Default <code>definition</code> <code>str</code> <p>The operator definition string to be parsed.</p> required <p>Returns:</p> Type Description <p>Lark.Tree: A Lark parsing tree representing the parsed definition.</p> <p>Logs the parsing process and any issues during parsing.</p> Source code in <code>opulse/operatorplus/operator_definition_parser.py</code> <pre><code>def parse_definition(self, definition):\n    \"\"\"\n    Parse the given operator definition using the generated grammar.\n\n    Args:\n        definition (str): The operator definition string to be parsed.\n\n    Returns:\n        Lark.Tree: A Lark parsing tree representing the parsed definition.\n\n    Logs the parsing process and any issues during parsing.\n    \"\"\"\n    try:\n        self.logger.info(f\"Attempting to parse definition: {definition}\")\n        parsed_tree = self.parser.parse(definition)\n        self.logger.info(\"Parsing successful.\")\n        return parsed_tree\n    except Exception as e:\n        self.logger.error(f\"Error while parsing definition: {e}\")\n        raise\n</code></pre>"},{"location":"operatorplus/operator_definition_parser/#opulse.operatorplus.operator_definition_parser.OperatorDefinitionParser.update_definition","title":"<code>update_definition(definition)</code>","text":"<p>Update the operator definition by replacing indexed numeric atoms with their values from <code>param_config</code>.</p> <p>This method performs a replacement in the expression, replacing placeholders such as '0', '1', etc.  with corresponding values from <code>numeric_atoms</code>.</p> <p>Parameters:</p> Name Type Description Default <code>definition</code> <code>str</code> <p>The operator definition to be updated.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The updated operator definition with numeric atoms replaced.</p> <p>Logs each replacement performed in the update process for debugging.</p> Source code in <code>opulse/operatorplus/operator_definition_parser.py</code> <pre><code>def update_definition(self, definition) -&gt; str:\n    \"\"\"\n    Update the operator definition by replacing indexed numeric atoms with their values from `param_config`.\n\n    This method performs a replacement in the expression, replacing placeholders such as '0', '1', etc. \n    with corresponding values from `numeric_atoms`.\n\n    Args:\n        definition (str): The operator definition to be updated.\n\n    Returns:\n        str: The updated operator definition with numeric atoms replaced.\n\n    Logs each replacement performed in the update process for debugging.\n    \"\"\"\n    updated_expr = definition\n\n    self.logger.info(f\"Starting update of definition: {definition}\")\n\n    # Limit to the first 10 numeric atoms for replacement\n    for idx, numeric_atom in enumerate(self.param_config.atoms[\"numeric_atoms\"][:10]):\n        self.logger.debug(f\"Replacing index '{idx}' with numeric atom value '{numeric_atom}'\")\n        updated_expr = updated_expr.replace(f'{idx}', str(numeric_atom))\n\n    self.logger.info(f\"Updated definition: {updated_expr}\")\n    return updated_expr\n</code></pre>"},{"location":"operatorplus/operator_dependency_graph/","title":"OperatorDependencyGraph","text":""},{"location":"operatorplus/operator_dependency_graph/#opulse.operatorplus.operator_dependency_graph.OperatorDependencyGraph","title":"<code>OperatorDependencyGraph</code>","text":"Source code in <code>opulse/operatorplus/operator_dependency_graph.py</code> <pre><code>class OperatorDependencyGraph:\n    def __init__(\n        self,\n        logger: LogConfig,\n        operator_manager: \"OperatorManager\" = None,\n    ):\n        \"\"\"\n        Initializes the OperatorDependencyGraph class.\n\n        Parameters:\n            logger (LogConfig): Logger object for logging operations.\n            operator_manager (OperatorManager, optional): An instance of OperatorManager to manage operators and their dependencies (default: None).\n        \"\"\"\n        self.logger = logger.get_logger()\n        self.operator_manager = operator_manager\n\n    def build_dependency_graph(self):\n        \"\"\"\n        Constructs a directed acyclic graph (DAG) representing the operator dependencies.\n\n        The graph is built based on the operators managed by the OperatorManager, \n        and a topological sorting of the graph is performed.\n\n        Returns: \n            (tuple(dict[int, list[int]], list[int)): A tuple (graph, topo_sorted), where graph is the adjacency list \n                 representation of the DAG and topo_sorted is the topologically sorted list of operators.\n        \"\"\"\n        graph = defaultdict(list)  # Adjacency list to store graph\n        in_degree = defaultdict(int)  # Dictionary to store the in-degree of each node\n\n        self.logger.debug(\"Building the dependency graph.\")\n\n        # Construct the graph\n        for operator_func_id, operator_info in self.operator_manager.operators.items():\n            if operator_info.dependencies:\n                for dep_id in operator_info.dependencies:\n                    graph[dep_id].append(operator_func_id)\n                    in_degree[operator_func_id] += 1\n                    self.logger.debug(f\"Operator {operator_func_id} depends on {dep_id}.\")\n            else:\n                in_degree[operator_id] = 0  # If no dependencies, set in-degree to 0\n                self.logger.debug(f\"Operator {operator_func_id} has no dependencies.\")\n\n        # Perform topological sorting\n        topo_sorted = self.topological_sort(graph, in_degree)\n\n        self.logger.info(\"Dependency graph built successfully.\")\n\n        return graph, topo_sorted\n\n    def topological_sort(self, graph, in_degree):\n        \"\"\"\n        Performs a topological sort on the graph using Kahn's algorithm.\n\n        Parameters:\n            graph (dict[int, list[int]]): The adjacency list representation of the graph.\n            in_degree (dict[int, int]): A dictionary that tracks the in-degree of each node.\n\n        Returns: \n            (list[int]): A topologically sorted list of operators.\n\n        Raises:\n            ValueError: If the graph contains a cycle, making topological sorting impossible.\n        \"\"\"\n        queue = deque([node for node in in_degree if in_degree[node] == 0])\n        sorted_order = []\n\n        self.logger.debug(\"Starting topological sorting.\")\n\n        while queue:\n            node = queue.popleft()\n            sorted_order.append(node)\n            self.logger.debug(f\"Node {node} added to the sorted order.\")\n\n            for neighbor in graph[node]:\n                in_degree[neighbor] -= 1\n                if in_degree[neighbor] == 0:\n                    queue.append(neighbor)\n                    self.logger.debug(f\"Node {neighbor} now has in-degree 0 and is added to the queue.\")\n\n        if len(sorted_order) != len(in_degree):\n            self.logger.error(\"Graph contains a cycle, topological sorting cannot be performed.\")\n            raise ValueError(\"Graph has a cycle, cannot perform topological sorting.\")\n\n        self.logger.info(\"Topological sorting completed successfully.\")\n\n        return sorted_order\n\n    def write_dependency_to_jsonl(self, filename=\"data/dependency/operator_dependencies.jsonl\"):\n        \"\"\"\n        Writes the operator dependency graph to a JSONL file.\n\n        Each line in the file represents a node in the graph, with its primitive operator ID \n        and the list of operators derived from it (i.e., its dependencies).\n\n        Parameters:\n            filename (str): The name of the output JSONL file. Default is 'operator_dependencies.jsonl'.\n        \"\"\"\n        self.logger.info(f\"Writing dependency data to {filename}.\")\n\n        # Get the graph and topological sort\n        graph, topo_sorted = self.build_dependency_graph()\n\n        try:\n            with open(filename, 'w') as f:\n                for node in topo_sorted:\n                    node_info = {\n                        \"primitive_op_id\": node,\n                        \"derived_op_id_list\": graph[node]  # List of dependent operators\n                    }\n                    f.write(json.dumps(node_info) + \"\\n\")\n                    self.logger.debug(f\"Written node {node} to {filename}.\")\n\n            self.logger.info(f\"Dependency data successfully written to {filename}.\")\n\n        except Exception as e:\n            self.logger.error(f\"Error writing to file {filename}: {e}\")\n\n    def visualize_dependency_graph(self):\n        \"\"\"\n        Visualizes the operator dependency graph using pyvis.\n\n        This method generates an interactive graph that can be explored in a web browser.\n        The graph shows the operators and their dependencies, where nodes represent \n        operators and edges represent dependencies between them.\n\n        The graph is saved as an HTML file for viewing.\n        \"\"\"\n        self.logger.info(\"Visualizing the operator dependency graph.\")\n\n        # Create an interactive network graph\n        net = Network(directed=True)\n\n        # Add nodes and edges to the graph\n        for operator_func_id, operator_info in self.operator_manager.operators.items():\n            label = f\"{operator_func_id}:{operator_info.symbol}\"  # Combine operator ID and symbol\n            net.add_node(operator_func_id, label=label)\n            if operator_info.dependencies:\n                for dep_id in operator_info.dependencies:\n                    net.add_edge(dep_id, operator_func_id)\n                    self.logger.debug(f\"Edge added between {dep_id} and {operator_func_id}.\")\n\n        net.force_atlas_2based()  # Enable the ForceAtlas2 layout engine, but disable continuous updates\n        net.physics = False  # Disable physics engine for static layout\n\n        # Save the graph as an HTML file\n        try:\n            net.show(\"operator_dependency_graph.html\", notebook=False)\n            self.logger.info(\"Dependency graph saved as 'operator_dependency_graph.html'.\")\n        except Exception as e:\n            self.logger.error(f\"Error visualizing the dependency graph: {e}\")\n</code></pre>"},{"location":"operatorplus/operator_dependency_graph/#opulse.operatorplus.operator_dependency_graph.OperatorDependencyGraph.__init__","title":"<code>__init__(logger, operator_manager=None)</code>","text":"<p>Initializes the OperatorDependencyGraph class.</p> <p>Parameters:</p> Name Type Description Default <code>logger</code> <code>LogConfig</code> <p>Logger object for logging operations.</p> required <code>operator_manager</code> <code>OperatorManager</code> <p>An instance of OperatorManager to manage operators and their dependencies (default: None).</p> <code>None</code> Source code in <code>opulse/operatorplus/operator_dependency_graph.py</code> <pre><code>def __init__(\n    self,\n    logger: LogConfig,\n    operator_manager: \"OperatorManager\" = None,\n):\n    \"\"\"\n    Initializes the OperatorDependencyGraph class.\n\n    Parameters:\n        logger (LogConfig): Logger object for logging operations.\n        operator_manager (OperatorManager, optional): An instance of OperatorManager to manage operators and their dependencies (default: None).\n    \"\"\"\n    self.logger = logger.get_logger()\n    self.operator_manager = operator_manager\n</code></pre>"},{"location":"operatorplus/operator_dependency_graph/#opulse.operatorplus.operator_dependency_graph.OperatorDependencyGraph.build_dependency_graph","title":"<code>build_dependency_graph()</code>","text":"<p>Constructs a directed acyclic graph (DAG) representing the operator dependencies.</p> <p>The graph is built based on the operators managed by the OperatorManager,  and a topological sorting of the graph is performed.</p> <p>Returns:</p> Type Description <code>tuple(dict[int, list[int]], list[int)</code> <p>A tuple (graph, topo_sorted), where graph is the adjacency list   representation of the DAG and topo_sorted is the topologically sorted list of operators.</p> Source code in <code>opulse/operatorplus/operator_dependency_graph.py</code> <pre><code>def build_dependency_graph(self):\n    \"\"\"\n    Constructs a directed acyclic graph (DAG) representing the operator dependencies.\n\n    The graph is built based on the operators managed by the OperatorManager, \n    and a topological sorting of the graph is performed.\n\n    Returns: \n        (tuple(dict[int, list[int]], list[int)): A tuple (graph, topo_sorted), where graph is the adjacency list \n             representation of the DAG and topo_sorted is the topologically sorted list of operators.\n    \"\"\"\n    graph = defaultdict(list)  # Adjacency list to store graph\n    in_degree = defaultdict(int)  # Dictionary to store the in-degree of each node\n\n    self.logger.debug(\"Building the dependency graph.\")\n\n    # Construct the graph\n    for operator_func_id, operator_info in self.operator_manager.operators.items():\n        if operator_info.dependencies:\n            for dep_id in operator_info.dependencies:\n                graph[dep_id].append(operator_func_id)\n                in_degree[operator_func_id] += 1\n                self.logger.debug(f\"Operator {operator_func_id} depends on {dep_id}.\")\n        else:\n            in_degree[operator_id] = 0  # If no dependencies, set in-degree to 0\n            self.logger.debug(f\"Operator {operator_func_id} has no dependencies.\")\n\n    # Perform topological sorting\n    topo_sorted = self.topological_sort(graph, in_degree)\n\n    self.logger.info(\"Dependency graph built successfully.\")\n\n    return graph, topo_sorted\n</code></pre>"},{"location":"operatorplus/operator_dependency_graph/#opulse.operatorplus.operator_dependency_graph.OperatorDependencyGraph.topological_sort","title":"<code>topological_sort(graph, in_degree)</code>","text":"<p>Performs a topological sort on the graph using Kahn's algorithm.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>dict[int, list[int]]</code> <p>The adjacency list representation of the graph.</p> required <code>in_degree</code> <code>dict[int, int]</code> <p>A dictionary that tracks the in-degree of each node.</p> required <p>Returns:</p> Type Description <code>list[int]</code> <p>A topologically sorted list of operators.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the graph contains a cycle, making topological sorting impossible.</p> Source code in <code>opulse/operatorplus/operator_dependency_graph.py</code> <pre><code>def topological_sort(self, graph, in_degree):\n    \"\"\"\n    Performs a topological sort on the graph using Kahn's algorithm.\n\n    Parameters:\n        graph (dict[int, list[int]]): The adjacency list representation of the graph.\n        in_degree (dict[int, int]): A dictionary that tracks the in-degree of each node.\n\n    Returns: \n        (list[int]): A topologically sorted list of operators.\n\n    Raises:\n        ValueError: If the graph contains a cycle, making topological sorting impossible.\n    \"\"\"\n    queue = deque([node for node in in_degree if in_degree[node] == 0])\n    sorted_order = []\n\n    self.logger.debug(\"Starting topological sorting.\")\n\n    while queue:\n        node = queue.popleft()\n        sorted_order.append(node)\n        self.logger.debug(f\"Node {node} added to the sorted order.\")\n\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n                self.logger.debug(f\"Node {neighbor} now has in-degree 0 and is added to the queue.\")\n\n    if len(sorted_order) != len(in_degree):\n        self.logger.error(\"Graph contains a cycle, topological sorting cannot be performed.\")\n        raise ValueError(\"Graph has a cycle, cannot perform topological sorting.\")\n\n    self.logger.info(\"Topological sorting completed successfully.\")\n\n    return sorted_order\n</code></pre>"},{"location":"operatorplus/operator_dependency_graph/#opulse.operatorplus.operator_dependency_graph.OperatorDependencyGraph.visualize_dependency_graph","title":"<code>visualize_dependency_graph()</code>","text":"<p>Visualizes the operator dependency graph using pyvis.</p> <p>This method generates an interactive graph that can be explored in a web browser. The graph shows the operators and their dependencies, where nodes represent  operators and edges represent dependencies between them.</p> <p>The graph is saved as an HTML file for viewing.</p> Source code in <code>opulse/operatorplus/operator_dependency_graph.py</code> <pre><code>def visualize_dependency_graph(self):\n    \"\"\"\n    Visualizes the operator dependency graph using pyvis.\n\n    This method generates an interactive graph that can be explored in a web browser.\n    The graph shows the operators and their dependencies, where nodes represent \n    operators and edges represent dependencies between them.\n\n    The graph is saved as an HTML file for viewing.\n    \"\"\"\n    self.logger.info(\"Visualizing the operator dependency graph.\")\n\n    # Create an interactive network graph\n    net = Network(directed=True)\n\n    # Add nodes and edges to the graph\n    for operator_func_id, operator_info in self.operator_manager.operators.items():\n        label = f\"{operator_func_id}:{operator_info.symbol}\"  # Combine operator ID and symbol\n        net.add_node(operator_func_id, label=label)\n        if operator_info.dependencies:\n            for dep_id in operator_info.dependencies:\n                net.add_edge(dep_id, operator_func_id)\n                self.logger.debug(f\"Edge added between {dep_id} and {operator_func_id}.\")\n\n    net.force_atlas_2based()  # Enable the ForceAtlas2 layout engine, but disable continuous updates\n    net.physics = False  # Disable physics engine for static layout\n\n    # Save the graph as an HTML file\n    try:\n        net.show(\"operator_dependency_graph.html\", notebook=False)\n        self.logger.info(\"Dependency graph saved as 'operator_dependency_graph.html'.\")\n    except Exception as e:\n        self.logger.error(f\"Error visualizing the dependency graph: {e}\")\n</code></pre>"},{"location":"operatorplus/operator_dependency_graph/#opulse.operatorplus.operator_dependency_graph.OperatorDependencyGraph.write_dependency_to_jsonl","title":"<code>write_dependency_to_jsonl(filename='data/dependency/operator_dependencies.jsonl')</code>","text":"<p>Writes the operator dependency graph to a JSONL file.</p> <p>Each line in the file represents a node in the graph, with its primitive operator ID  and the list of operators derived from it (i.e., its dependencies).</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The name of the output JSONL file. Default is 'operator_dependencies.jsonl'.</p> <code>'data/dependency/operator_dependencies.jsonl'</code> Source code in <code>opulse/operatorplus/operator_dependency_graph.py</code> <pre><code>def write_dependency_to_jsonl(self, filename=\"data/dependency/operator_dependencies.jsonl\"):\n    \"\"\"\n    Writes the operator dependency graph to a JSONL file.\n\n    Each line in the file represents a node in the graph, with its primitive operator ID \n    and the list of operators derived from it (i.e., its dependencies).\n\n    Parameters:\n        filename (str): The name of the output JSONL file. Default is 'operator_dependencies.jsonl'.\n    \"\"\"\n    self.logger.info(f\"Writing dependency data to {filename}.\")\n\n    # Get the graph and topological sort\n    graph, topo_sorted = self.build_dependency_graph()\n\n    try:\n        with open(filename, 'w') as f:\n            for node in topo_sorted:\n                node_info = {\n                    \"primitive_op_id\": node,\n                    \"derived_op_id_list\": graph[node]  # List of dependent operators\n                }\n                f.write(json.dumps(node_info) + \"\\n\")\n                self.logger.debug(f\"Written node {node} to {filename}.\")\n\n        self.logger.info(f\"Dependency data successfully written to {filename}.\")\n\n    except Exception as e:\n        self.logger.error(f\"Error writing to file {filename}: {e}\")\n</code></pre>"},{"location":"operatorplus/operator_generator/","title":"OperatorGenerator.md","text":""},{"location":"operatorplus/operator_generator/#opulse.operatorplus.operator_generator.OperatorGenerator","title":"<code>OperatorGenerator</code>","text":"Source code in <code>opulse/operatorplus/operator_generator.py</code> <pre><code>class OperatorGenerator:\n    def __init__(\n        self,\n        param_config: ParamConfig,\n        logger: LogConfig,\n        condition_generator: ConditionGenerator,\n        expr_generator: ExpressionGenerator,\n        operator_manager: OperatorManager\n    ):\n        \"\"\"\n        Initialize the OperatorGenerator.\n\n        Parameters:\n            param_config (ParamConfig): Configuration object containing parameters like symbols and operator details.\n            logger (LogConfig): Logger configuration to handle logging functionality.\n            condition_generator (ConditionGenerator): A generator responsible for producing conditions.\n            expr_generator (ExpressionGenerator): A generator responsible for producing expressions.\n            operator_manager (OperatorManager): Manages operator-related functionality.\n\n        Attributes:\n            param_config (ParamConfig): Configuration object that holds various parameters.\n            logger (Logger): Logger instance used for logging debug and info messages.\n            standard_symbols (list): A list of standard operator symbols.\n            unicode_symbols (list): A list of Unicode operator symbols.\n            valid_symbols (list): A combined list of valid operator symbols (standard + Unicode).\n            condition_generator (ConditionGenerator): The generator used to generate conditions.\n            expr_generator (ExpressionGenerator): The generator used to generate expressions.\n            operator_manager (OperatorManager): Manages operators for the generator.\n            unary_variables (list): List of variables used in unary operations.\n            binary_variables (list): List of variables used in binary operations.\n            max_base (int): Maximum base value used in the generation process.\n            operator_symbol_min_len (int): Minimum length for operator symbols.\n            operator_symbol_max_len (int): Maximum length for operator symbols.\n            max_if_branches (int): Maximum number of branches in conditional expressions.\n        \"\"\"\n        self.param_config = param_config\n        self.logger = logger.get_logger()  # Get logger instance for logging\n        self.standard_symbols = self.param_config.get(\"basic_operator_symbols\")\n        self.unicode_symbols = self.get_unicode_symbols()\n        self.valid_symbols = self.standard_symbols + self.unicode_symbols\n        self.condition_generator = condition_generator  # Condition generator instance\n        self.expr_generator = expr_generator  # Expression generator instance\n        self.operator_manager = operator_manager  # Operator manager instance\n        self.unary_variables = [self.param_config.atoms[\"left_operand\"]]\n        self.binary_variables = [\n            self.param_config.atoms[\"left_operand\"],\n            self.param_config.atoms[\"right_operand\"],\n        ]\n        self.max_base = self.param_config.get(\"max_base\")\n        self.operator_symbol_min_len = self.param_config.get(\"operator_symbol_min_len\")\n        self.operator_symbol_max_len = self.param_config.get(\"operator_symbol_max_len\")\n        self.max_if_branches = self.param_config.get(\"max_if_branches\")\n\n        # self.expr_parser = expr_parser\n        # self.expr_transformer = expr_transformer\n        # Log initialization details\n        self.logger.info(\n            \"OperatorGenerator initialized with the following configuration:\"\n        )\n        self.logger.debug(f\"Standard symbols: {self.standard_symbols}\")\n        self.logger.debug(f\"Unicode symbols: {self.unicode_symbols}\")\n        self.logger.debug(f\"Valid symbols: {self.valid_symbols}\")\n        self.logger.debug(f\"Unary variables: {self.unary_variables}\")\n        self.logger.debug(f\"Binary variables: {self.binary_variables}\")\n        self.logger.debug(f\"Max base: {self.max_base}\")\n        self.logger.debug(f\"Operator symbol min length: {self.operator_symbol_min_len}\")\n        self.logger.debug(f\"Operator symbol max length: {self.operator_symbol_max_len}\")\n        self.logger.debug(f\"Max if branches: {self.max_if_branches}\")\n\n    def get_unicode_symbols(self) -&gt; list:\n        \"\"\"\n        Collects valid Unicode operator symbols from predefined ranges.\n\n        This method retrieves symbols from several mathematical and arrow ranges in Unicode:\n        - Mathematical Operators (U+2200 to U+22FF)\n        - Supplemental Mathematical Operators (U+2A00 to U+2AFF)\n        - Arrows (U+2190 to U+21FF)\n\n        Returns:\n            list: A list of valid Unicode operator symbols.\n        \"\"\"\n        self.logger.info(\"Collecting Unicode symbols from predefined ranges.\")\n        unicode_ranges = [\n            (0x2200, 0x22FF),  # Mathematical Operators\n            (0x2A00, 0x2AFF),  # Supplemental Mathematical Operators\n            (0x2190, 0x21FF),  # Arrows\n        ]\n\n        symbols = []\n\n        for start, end in unicode_ranges:\n            for codepoint in range(start, end + 1):\n                char = chr(codepoint)\n                symbols.append(char)\n\n        self.logger.debug(f\"Collected {len(symbols)} Unicode symbols.\")\n        return symbols\n\n    def random_operator(self, existing_symbols: List[str]) -&gt; str:\n        \"\"\"\n        Generates a random operator string composed of one or more valid symbols.\n\n        This method generates a random operator string with a length between\n        `operator_symbol_min_len` and `operator_symbol_max_len`, ensuring that\n        the generated operator does not already exist in the list of `existing_symbols`.\n\n        Parameters:\n            existing_symbols (List[str]): A list of currently existing operator symbols.\n                                            The new symbol must not be in this list.\n\n        Returns:\n            str: The generated random operator string that is unique and within the specified length range.\n        \"\"\"\n        self.logger.info(\"Generating a random operator string.\")\n\n        # Loop until a unique operator is generated\n        while True:\n            # Randomly choose a length for the operator within the specified range\n            length = random.randint(\n                self.operator_symbol_min_len, self.operator_symbol_max_len\n            )\n\n            # Generate the new symbol by randomly picking characters from valid symbols\n            new_symbol = \"\".join(\n                random.choice(self.valid_symbols) for _ in range(length)\n            )\n\n            # Check if the generated symbol is unique (not in existing_symbols)\n            if new_symbol not in existing_symbols:\n                self.logger.debug(\n                    f\"Generated new operator symbol: {new_symbol} with length {length}.\"\n                )\n                return new_symbol\n            else:\n                self.logger.debug(\n                    f\"Generated operator {new_symbol} already exists. Retrying...\"\n                )\n\n    def random_operator_type_and_position(self) -&gt; tuple:\n        \"\"\"\n        Generates a random operator type and its position (if applicable).\n\n        This method randomly selects an operator type, either \"unary\" or \"binary\".\n        If the type is \"unary\", it also randomly chooses its position, either \"prefix\" or \"postfix\".\n        For \"binary\" operators, the position is not applicable (set to None).\n\n        Returns:\n            tuple: A tuple containing the operator type and its position.\n                If the operator type is \"unary\", the position is either \"prefix\" or \"postfix\".\n                If the operator type is \"binary\", the position is None.\n        \"\"\"\n        self.logger.info(\"Generating random operator type and position.\")\n\n        # Randomly select the operator type\n        op_type = random.choice([\"unary\", \"binary\"])\n\n        # Initialize unary_position as None\n        unary_position = None\n\n        # If the operator type is \"unary\", randomly choose its position\n        if op_type == \"unary\":\n            unary_position = random.choice([\"prefix\", \"postfix\"])\n\n        # Log the final operator type and position\n        self.logger.info(\n            f\"Operator type: {op_type}, Position: {unary_position if unary_position else 'None'}\"\n        )\n\n        return op_type, unary_position\n\n    def generate_base_operators(self):\n        \"\"\"\n        Generates unary prefix operators for each base from 2 to self.max_base.\n\n        This method creates a unary prefix operator for each base in the range from 2 to `self.max_base`.\n        For each base, a random operator symbol is generated, and the operator is added to the operator manager.\n        The operator is stored with additional properties, such as its base number and the unary position.\n\n        \"\"\"\n        self.logger.info(\n            \"Starting to generate base operators for each base from 2 to max_base.\"\n        )\n\n        # Iterate through the range of bases from 2 to max_base\n        for n in range(2, self.max_base + 1):\n            self.logger.debug(f\"Generating operator for base {n}.\")\n\n            # Get existing operator symbols to avoid duplication\n            existing_symbols = self.operator_manager.get_operator_symbols()\n\n            # Generate a random operator symbol that isn't already used\n            op_symbol = self.random_operator(existing_symbols)\n\n            # Define operator type and position\n            op_type = \"unary\"\n            op_position = \"prefix\"\n            func_id = generate(size=10,alphabet=alphabet)\n            # Construct the operator data\n            operator_data = {\n                \"id\": None,\n                \"func_id\":  func_id,\n                \"symbol\": op_symbol,\n                \"n_ary\": 1,  # Unary operator\n                \"unary_position\": op_position if op_type == \"unary\" else None,\n                \"n_order\": None,\n                \"is_base\": n,  # Base number\n                \"definition\": None,\n                \"definition_type\": None,\n                \"priority\": None,\n                \"associativity_direction\": None,\n                \"op_compute_func\": None,\n                \"op_count_func\": None,\n                \"properties\": None,\n                \"dependencies\": None,\n                \"is_temporary\": False,\n            }\n\n            new_base_operator = OperatorInfo(**operator_data)\n\n            # Add the generated operator to the operator manager\n            self.operator_manager.add_operator(new_base_operator)\n\n            self.logger.info(\n                f\"Base operator for base {n} with symbol '{op_symbol}' added successfully.\"\n            )\n\n        self.logger.info(\"Base operator generation completed.\")\n\n    def generate_lhs(self, op_symbol, op_type, op_position) -&gt;str:\n        \"\"\"\n        Generates the left-hand side (LHS) of an expression based on the operator type and position.\n\n        This method constructs the left-hand side of an expression depending on the type of operator\n        (unary or binary) and its position (prefix or postfix). It uses the operator symbol and operands\n        defined in the configuration.\n\n        Parameters:\n            op_symbol (str): The operator symbol to be used in the expression (e.g., \"+\", \"\u2295\").\n            op_type (str): The type of the operator, either \"unary\" or \"binary\".\n            op_position (str): The position of the operator, either \"prefix\" or \"postfix\" (only for unary operators).\n\n        Returns:\n            str: The generated left-hand side expression as a string.\n\n        Raises:\n            ValueError: If the operator type is neither \"unary\" nor \"binary\".\n        \"\"\"\n\n        self.logger.debug(\n            f\"Generating LHS for operator '{op_symbol}', type '{op_type}', position '{op_position}'.\"\n        )\n\n        # Handle the case for unary operators\n        if op_type == \"unary\":\n            if op_position == \"prefix\":\n                lhs = f\"{op_symbol}{self.param_config.atoms['left_operand']}\"  # e.g., \"-a\"\n            elif op_position == \"postfix\":\n                lhs = f\"{self.param_config.atoms['left_operand']}{op_symbol}\"  # e.g., \"a-\"\n            else:\n                self.logger.error(\n                    f\"Invalid position '{op_position}' for unary operator.\"\n                )\n                raise ValueError(\n                    f\"Invalid position '{op_position}' for unary operator.\"\n                )\n\n        # Handle the case for binary operators\n        elif op_type == \"binary\":\n            lhs = f\"{self.param_config.atoms['left_operand']}{op_symbol}{self.param_config.atoms['right_operand']}\"  # e.g., 'a + b', 'a\u2295b'\n        else:\n            self.logger.error(f\"Invalid operator type '{op_type}' received.\")\n            raise ValueError(f\"Operator type must be either 'unary' or 'binary'.\")\n\n        self.logger.info(f\"LHS generated: {lhs}\")\n        return lhs\n\n    def generate_branches(self, order) -&gt; list:\n        \"\"\"\n        Generates a list of conditional branches for an expression, including 'if' and 'else' branches.\n\n        This method generates a random number of 'if' branches based on the maximum allowed number\n        of branches (`max_if_branches`), each containing a randomly generated expression and a condition.\n        Additionally, an 'else' branch is added with a randomly generated expression.\n\n        The format of each branch is a tuple containing the expression and the corresponding condition.\n\n        Returns:\n            list: A list of tuples, each containing a generated expression and its associated condition.\n            Each tuple is in the form (expression, condition).\n        \"\"\"\n        self.logger.debug(\"Generating branches for conditional expressions.\")\n\n        num_if_branches = random.randint(2, self.max_if_branches)\n        branches = []\n\n        self.logger.info(f\"Generating {num_if_branches} 'if' branches.\")\n\n\n        exprs = self.expr_generator.create_n_expression_str_with_order(\n                max_depth=random.randint(1, self.expr_generator.max_depth),\n                atom_choice=\"variable_and_number\",\n                order=order,\n                branch_num=num_if_branches,\n            )\n\n        for i, expr in enumerate(exprs[:-1]):  \n            condition = self.condition_generator.generate_condition_expr()\n            branches.append((expr, f\"if {condition}\"))\n            self.logger.debug(f\"Generated 'if' branch {i+1}: {expr} with condition {condition}\")\n\n        last_expr = exprs[-1]  \n        branches.append((last_expr, \"else\"))  \n        self.logger.debug(f\"Generated 'else' branch: {last_expr}\")\n\n        self.logger.info(f\"Total branches generated: {len(branches)}.\")\n\n        return branches\n\n    def generate_recursive_call(self, op_symbol, op_type, op_position):\n        \"\"\"\n        Generates recursive expressions for binary and unary operators.\n\n        This function creates recursive calls for both unary and binary operators\n        based on the following rules:\n\n        For binary operators:\n            - If b == 0, generates a basic expression involving a and b.\n            - If b &gt; 0, generates an expression involving a and (b-1), where the expression on the right side must include (b-1).\n            - If b &lt; 0, generates an expression involving a and (b+1), where the expression on the right side must include (b+1).\n\n        For unary operators:\n            - If a == 0, randomly generates a number.\n            - If a &gt; 0, generates an expression solely involving (a-1), with its own symbol, and only related to (a-1).\n            - If a &lt; 0, generates an expression solely involving (a+1), with its own symbol, and only related to (a+1).\n\n        Parameters:\n        op_symbol (str): The operator symbol (e.g., '+', '-', '*', etc.) to be used in the expressions.\n        op_type (str): The type of the operator. Can be either 'unary' or 'binary'.\n        op_position (str): The position of the unary operator. Can be either 'prefix' or 'postfix' (relevant only for unary operators).\n\n        Returns:\n        str: A string representing the recursive expression for the operator, with conditions based on the values of 'a' and 'b'.\n\n        Raises:\n        ValueError: If the provided operator type is neither 'unary' nor 'binary'.\n        \"\"\"\n        if op_type == \"binary\":\n            # The recursive expression for generating binary operators with operands a and b.\n            self.expr_generator.set_variables(\n                [\n                    self.param_config.atoms[\"left_operand\"],\n                    self.param_config.atoms[\"right_operand\"],\n                ]\n            )\n\n            # If b == 0, generate a basic expression with a and b.\n            expr_base = self.expr_generator.create_expression_str(\n                atom_choice=\"variable_and_number\"\n            )\n\n            # If b &gt; 0, generate an expression involving a and (b-1) (note that the expression on the right side must include b-1).\n            recursive_variable = f\"{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['left_operand']}{op_symbol}{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['right_operand']}-1{self.param_config.atoms['right_parenthesis']}{self.param_config.atoms['right_parenthesis']}\"\n            self.expr_generator.set_variables(\n                [\n                    self.param_config.atoms[\"left_operand\"],\n                    self.param_config.atoms[\"right_operand\"],\n                    recursive_variable,\n                ]\n            )\n            recursive_expr_1 = \"\"\n            while recursive_variable not in recursive_expr_1:\n                recursive_expr_1 = self.expr_generator.create_expression_str(\n                    atom_choice=\"variable_and_number\"\n                )\n\n            # If b &lt; 0, generate an expression involving a and (b+1).\n            recursive_variable = f\"{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['left_operand']}{op_symbol}{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['right_operand']}+1{self.param_config.atoms['right_parenthesis']}{self.param_config.atoms['right_parenthesis']}\"\n            self.expr_generator.set_variables(\n                [\n                    self.param_config.atoms[\"left_operand\"],\n                    self.param_config.atoms[\"right_operand\"],\n                    recursive_variable,\n                ]\n            )\n            recursive_expr_2 = \"\"\n            while recursive_variable not in recursive_expr_2:\n                recursive_expr_2 = self.expr_generator.create_expression_str(\n                    atom_choice=\"variable_and_number\"\n                )\n\n            return f\"{expr_base}, if {self.param_config.atoms['right_operand']} == 0 ; {recursive_expr_1}, if {self.param_config.atoms['right_operand']} &gt; 0 ; {recursive_expr_2}, else\"\n\n        elif op_type == \"unary\":\n            # For unary operators, generate a recursive expression with a single parameter.\n            self.expr_generator.set_variables([self.param_config.atoms[\"left_operand\"]])\n\n            # If a == 0, randomly generate a number.\n            expr_base = self.expr_generator.create_expression_str(atom_choice=\"number\")\n\n            # If a &gt; 0, generate an expression solely involving (a-1), with its own symbol, and only related to (a-1).\n            if op_position == \"prefix\":\n                recursive_variable = (\n                    f\"{op_symbol}({self.param_config.atoms['left_operand']}-1)\"\n                )\n            elif op_position == \"postfix\":\n                recursive_variable = (\n                    f\"({self.param_config.atoms['left_operand']}-1){op_symbol}\"\n                )\n            self.expr_generator.set_variables(\n                [self.param_config.atoms[\"left_operand\"], recursive_variable]\n            )\n            recursive_expr_1 = \"\"\n            while recursive_variable not in recursive_expr_1:\n                recursive_expr_1 = self.expr_generator.create_expression_str(\n                    atom_choice=\"variable_and_number\"\n                )\n\n            # If a &lt; 0, generate an expression solely involving (a+1), with its own symbol, and only related to (a+1).\n            if op_position == \"prefix\":\n                recursive_variable = (\n                    f\"{op_symbol}({self.param_config.atoms['left_operand']}+1)\"\n                )\n            elif op_position == \"postfix\":\n                recursive_variable = (\n                    f\"({self.param_config.atoms['left_operand']}+1){op_symbol}\"\n                )\n            self.expr_generator.set_variables(\n                [self.param_config.atoms[\"left_operand\"], recursive_variable]\n            )\n            recursive_expr_2 = \"\"\n            while recursive_variable not in recursive_expr_2:\n                recursive_expr_2 = self.expr_generator.create_expression_str(\n                    atom_choice=\"variable_and_number\"\n                )\n\n            return f\"{expr_base}, if {self.param_config.atoms['left_operand']} == 0 ; {recursive_expr_1}, if {self.param_config.atoms['left_operand']} &gt; 0 ; {recursive_expr_2}, else\"\n\n        else:\n            raise ValueError(\n                \"Unsupported operator type. Only 'unary' and 'binary' are supported.\"\n            )\n\n    def generate_definition(self, op_symbol, op_type, op_position, choice, order) -&gt; str:\n        \"\"\"\n        Generates a complete operator definition rule based on the provided parameters.\n\n        This method constructs the definition of an operator, which can vary depending on the\n        `choice` parameter. It can generate a simple expression, a recursive call, or a branching\n        expression with conditional logic.\n\n        The definition can be generated in three different forms:\n            1. **Simple Definition**: A basic operator definition without any conditional branching.\n            2. **Recursive Definition**: A definition where the operator is recursively applied, based on the operator type (unary or binary).\n            3. **Branch Definition**: A definition with multiple branches, using conditional logic (if-else statements) to determine the behavior.\n\n        Parameters:\n            op_symbol (str): The symbol representing the operator (e.g., '+', '-', '*', etc.).\n            op_type (str): The type of the operator, either 'unary' (one operand) or 'binary' (two operands).\n            op_position (str): The position of the unary operator, either 'prefix' or 'postfix'.\n            choice (str): A string that determines the type of operator definition to generate:\n                        - \"simple_definition\": generates a simple expression without branching.\n                        - \"recursive_definition\": generates an expression with a recursive call.\n                        - \"branch_definition\": generates an expression with branching logic (if-else).\n\n        Returns:\n            str: A string representing the operator definition. The content of the string depends on the `choice` parameter:\n                - For \"simple_definition\", a simple expression is returned.\n                - For \"recursive_definition\", a recursive call expression is returned.\n                - For \"branch_definition\", an expression with conditional branches is returned.\n\n        Raises:\n            ValueError: If the `choice` parameter is not one of the recognized options (\"simple_definition\", \"recursive_definition\", \"branch_definition\").\n        \"\"\"\n        self.logger.debug(\n            f\"Generating definition for operator: {op_symbol}, Type: {op_type}, Position: {op_position}, Choice: {choice}\"\n        )\n\n        # Generate the left-hand side of the operator definition\n        lhs = self.generate_lhs(op_symbol, op_type, op_position)\n\n        if choice == \"simple_definition\":\n            # Simple expression, no branches\n            # expr = self.expr_generator.create_expression_str(\n            #     max_depth=random.randint(1, self.expr_generator.max_depth),\n            #     atom_choice=\"variable_and_number\",\n            # )\n            expr = self.expr_generator.create_n_expression_str_with_order(\n                max_depth=random.randint(1, self.expr_generator.max_depth),\n                atom_choice=\"variable_and_number\",\n                order=order,\n                branch_num=1,\n            )\n            self.logger.info(\n                f\"Simple definition generated: {lhs} {self.param_config.atoms['equal']} {{ {expr[0]} }}\"\n            )\n            return f\"{lhs} {self.param_config.atoms['equal']} {{ {expr[0]} }}\"\n\n        elif choice == \"recursive_definition\":\n            recursive_call = self.generate_recursive_call(\n                op_symbol, op_type, op_position\n            )\n            return f\"{lhs} = {{ {recursive_call} }}\"\n\n        elif choice == \"branch_definition\":\n            # Generate branches with conditions\n            branches = self.generate_branches(order)\n\n            # Build the branch strings\n            branch_strings = []\n            for expr, condition in branches:\n                if condition.startswith(\"if\"):\n                    branch_strings.append(f\"{expr} , {condition}\")\n                elif condition == \"else\":\n                    branch_strings.append(f\"{expr}, else\")\n\n            # Join branches with semicolons\n            rhs = \" ; \".join(branch_strings)\n            definition = f\"{lhs} {self.param_config.atoms['equal']} {{ {rhs} }}\"\n            self.logger.info(f\"Branch definition generated: {definition}\")\n            return definition\n\n        else:\n            self.logger.warning(f\"Unknown choice: {choice}. Returning None.\")\n            return None\n\n    def generate_operator_data_by_definition(self, choice, order) -&gt; dict:\n        \"\"\"\n        Generates operator data based on a specified operator definition type.\n\n        This method generates an operator symbol, determines its type (unary or binary), and sets\n        its position (prefix or postfix). Then, it creates an operator definition based on the given\n        `choice` parameter, which determines whether the operator definition is simple or involves\n        conditional branching. The generated operator data includes the operator's symbol, type,\n        position, and its corresponding definition.\n\n        Parameters:\n            choice (str): The type of operator definition to generate.\n                        Can be one of the following:\n                        - \"simple_definition\": Generates a basic operator expression without branching.\n                        - \"branch_definition\": Generates an operator definition with conditional branching (if-else).\n                        - \"recursive_definition\": generates an expression with a recursive call.\n\n        Returns:\n            dict: A dictionary containing the generated operator data.\n        \"\"\"\n        self.logger.debug(\n            f\"Generating operator data by definition with choice: {choice}\"\n        )\n\n        # Generate a random operator symbol that doesn't already exist in the operator manager\n        existing_symbols = self.operator_manager.get_operator_symbols()\n        op_symbol = self.random_operator(existing_symbols)\n        self.logger.debug(f\"Generated operator symbol: {op_symbol}\")\n\n        # Determine the type (unary or binary) and position (prefix or postfix) of the operator\n        op_type, op_position = self.random_operator_type_and_position()\n        self.logger.debug(f\"Operator type: {op_type}, Operator position: {op_position}\")\n\n        # Choose the appropriate variables based on the operator type\n        variables = (\n            self.unary_variables if op_type == \"unary\" else self.binary_variables\n        )\n        self.condition_generator.set_variables(variables)\n        self.expr_generator.set_variables(variables)\n        self.logger.debug(f\"Operator variables set to: {variables}\")\n\n        # Generate the operator definition based on the choice (simple or branch definition)\n        definition = self.generate_definition(op_symbol, op_type, op_position, choice, order)\n        self.logger.debug(f\"Generated operator definition: {definition}\")\n\n        func_id = generate(size=10,alphabet=alphabet)\n        # Construct the operator data dictionary\n        operator_data = {\n            \"id\": None,  \n            \"func_id\": func_id,\n            \"symbol\": op_symbol,\n            \"n_ary\": (\n                1 if op_type == \"unary\" else 2\n            ),  # Unary operators have 1 operand, binary have 2\n            \"unary_position\": op_position if op_type == \"unary\" else None,\n            \"n_order\": None,\n            \"is_base\": None,  # Not a base operator for now\n            \"definition\": definition,\n            \"definition_type\": choice,  # The type of definition generated (simple or branch)\n            \"priority\": None,  # Priority is not assigned for now\n            \"associativity_direction\": None,  # Not assigned for now\n            \"op_compute_func\": None,  # Compute function will be defined by the parser\n            \"op_count_func\": None,  # Count function will be defined by the parser\n            \"properties\": None,  # Properties are not assigned for now\n            \"dependencies\": None,  # Dependencies are not yet defined\n            \"is_temporary\": True,  # Indicates that this operator is temporary\n        }\n\n        self.logger.info(f\"Generated operator data: {operator_data}\")\n        return operator_data\n\n    def get_random_recursive_call_operator(self, order) -&gt; OperatorInfo:\n        \"\"\"\n        Selects a random operator that supports recursion from the operator manager.\n\n        This method filters the operators managed by the `operator_manager` to find those\n        that have recursion enabled (i.e., `is_recursion_enabled` is True). It then selects\n        a random operator from the filtered list and returns the corresponding `OperatorInfo` object.\n\n        Raises:\n            ValueError: If no operators are available in the operator manager.\n            ValueError: If no operators with recursion enabled are available.\n\n        Returns:\n            OperatorInfo: The selected operator's `OperatorInfo` object, including its ID, symbol, and other properties.\n        \"\"\"\n        self.logger.debug(\"Attempting to get a random recursive call operator.\")\n\n        # Check if there are any operators available in the operator manager\n        if not self.operator_manager.operators:\n            self.logger.error(\"No operators available in the operator manager.\")\n            raise ValueError(\"No operators available.\")\n\n        # Filter operators that have recursion enabled\n        recursive_operators = [\n            (operator_id, operator_info)\n            for operator_id, operator_info in self.operator_manager.operators.items()\n            if operator_info.n_order==order-1\n        ]\n\n        self.logger.debug(\n            f\"Filtered operators with recursion enabled: {recursive_operators}\"\n        )\n\n        # If no operators with recursion are available, raise an exception\n        if not recursive_operators:\n            self.logger.error(\"No operators with recursion enabled.\")\n            raise ValueError(\"No operators with recursion enabled.\")\n\n        # Randomly select one operator from the filtered list\n        _, operator_info = random.choice(recursive_operators)\n        self.logger.debug(f\"Selected operator: {operator_info}\")\n\n        # Return the `OperatorInfo` instance instead of a tuple\n        self.logger.info(f\"Random recursive call operator selected: {operator_info}\")\n        return operator_info  # Returning an instance of OperatorInfo\n\n    def generate_recursive_operator_data_by_loop(self, order) -&gt; Optional[dict]:\n        \"\"\"\n        Generates recursive operator data, including both unary and binary operators,\n        and defines recursive computation functions for the operators. The recursion\n        involves calling other operators within the defined computation functions.\n\n        This method constructs recursive operator definitions and the corresponding\n        computation functions for both unary and binary operators based on the\n        random operator type, position, and symbols. It checks recursion validity\n        and ensures that recursion will not lead to infinite loops.\n\n        The generated operator data includes:\n        - The operator's symbol\n        - Its type (unary or binary)\n        - A computation function\n        - A count function\n        - A definition for the operator's behavior\n\n        Returns:\n            dict: A dictionary containing the operator data, including the operator's\n                  symbol, definition, and computation functions.\n            None: If the recursion validity check fails, returns None.\n        \"\"\"\n\n        self.logger.debug(\"Fetching existing operator symbols to avoid duplication.\")\n        existing_symbols = self.operator_manager.get_operator_symbols()\n\n        # Randomly select a new operator symbol\n        op_symbol = self.random_operator(existing_symbols)\n\n        self.logger.debug(f\"Selected operator symbol: {op_symbol}\")\n\n        # Randomly choose operator type (unary or binary) and position\n        # op_type, op_position = self.random_operator_type_and_position()\n        op_type, op_position = \"binary\", None\n        # Set the variables for condition and expression generators\n        variables = (\n            self.unary_variables if op_type == \"unary\" else self.binary_variables\n        )\n        self.condition_generator.set_variables(variables)\n        self.expr_generator.set_variables(variables)\n\n        # Generate the operator ID\n        func_id = generate(size=10,alphabet=alphabet)\n\n        self.logger.debug(f\"Generated operator Func ID: {func_id}\")\n\n        # Fetch a random recursive operator to be called in the recursion\n        called_operator_info = self.get_random_recursive_call_operator(order)\n        called_id = called_operator_info.func_id\n        called_symbol = called_operator_info.symbol\n        # called_operator_info.is_recursion_enabled=False#\u8bbe\u7f6e\u4e3a\u4e0d\u53ef\u4ee5\u88ab\u9012\u5f52\u8c03\u7528\u4e86\n\n        self.logger.debug(\n            f\"Chosen operator for recursion: {called_symbol} (ID: {called_id})\"\n        )\n\n        # Generate the left-hand side expression\n        lhs = self.generate_lhs(op_symbol, op_type, op_position)\n\n        indent = \"    \"\n\n        #Generate a basic expr here to use as the initial value of the result\n        choices = [self.param_config.atoms[\"left_operand\"], self.param_config.atoms[\"right_operand\"], int(random.uniform(-100, 100))]  \n        expr_str = f\"{random.choice(choices)}\"\n\n        #The range of the loop variable is restricted here.\n        if order == 3:\n            loop_thres=int(1e6)\n        elif order == 4:\n            loop_thres=int(1e3)\n        elif order == 5:\n            loop_thres=int(1e2)\n        else:\n            loop_thres=int(thres)\n\n        # Handle binary operator recursion\n        if op_type == \"binary\":\n            loop_variable = random.choice([self.param_config.atoms[\"left_operand\"], self.param_config.atoms[\"right_operand\"]])\n            thres_check = f\" or (abs({loop_variable}) &gt; {loop_thres})\" if order&gt;=3 else \"\"\n\n\n            self.logger.debug(\"Generating recursive binary operator.\")\n\n            if called_operator_info.n_ary == 2:\n                # Randomly select the parameter order for recursion\n                param_order = random.choice(\n                    [\n                        (\"result\", \"result\"),\n                        (\"result\", self.param_config.atoms[\"left_operand\"]),\n                        (\"result\", self.param_config.atoms[\"right_operand\"]),\n                        (self.param_config.atoms[\"left_operand\"], \"result\"),\n                        (self.param_config.atoms[\"right_operand\"], \"result\"),\n                    ]\n                )\n                param1, param2 = param_order\n\n                self.logger.debug(\n                    f\"Selected parameter order for recursion: {param_order}\"\n                )\n\n                # # Check recursion validity\n                # if not self.check_and_set_recursion_validity(\n                #     called_operator_info, op_type, param_order\n                # ):\n                #     self.logger.warning(\"Recursion validity check failed.\")\n                #     return None\n\n                # Generate the recursive computation function for binary operator\n                op_compute_fun = f\"\"\"def op_{func_id}(a, b):\n{indent}special_values = [float('inf'), float('-inf')]\n{indent}if ({loop_variable} != {loop_variable}) or ({loop_variable} in special_values){thres_check}:\n{indent*2}return float('nan')\n{indent}result = {expr_str}\n{indent}for _ in range(abs({loop_variable})):\n{indent*2}temp_result = op_{called_id}({param1}, {param2})\n{indent*2}if abs(temp_result) &gt; thres:\n{indent*3}temp_result = float(\"inf\")\n{indent*2}result = temp_result if {loop_variable} &gt; 0 else -temp_result\n{indent}return result\n\"\"\"\n\n\n                op_count_fun = f\"\"\"def op_count_{func_id}(a, b):\n{indent}special_values = [float('inf'), float('-inf')]\n{indent}if ({loop_variable} != {loop_variable}) or ({loop_variable} in special_values){thres_check}:\n{indent*2}return 1\n{indent}result = {expr_str}\n{indent}count = 0 \n{indent}for _ in range(abs({loop_variable})):\n{indent*2}temp_result = op_{called_id}({param1}, {param2})\n{indent*2}count += op_count_{called_id}({param1}, {param2})\n{indent*2}if abs(temp_result) &gt; thres:\n{indent*3}temp_result = float(\"inf\")\n{indent*2}result = temp_result if {loop_variable} &gt; 0 else -temp_result\n{indent}return count if count &gt; 0 else 1\n\"\"\"\n                if loop_variable==self.param_config.atoms['left_operand']:\n                    variable_a_str_1 = f\"{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['left_operand']}-1{self.param_config.atoms['right_parenthesis']}\"\n                    variable_a_str_2 = f\"{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['left_operand']}+1{self.param_config.atoms['right_parenthesis']}\"\n                    variable_b_str_1 = self.param_config.atoms['right_operand']\n                    variable_b_str_2 = self.param_config.atoms['right_operand']\n                else:\n                    variable_a_str_1 = self.param_config.atoms['left_operand']\n                    variable_a_str_2 = self.param_config.atoms['left_operand']\n                    variable_b_str_1 = f\"{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['right_operand']}-1{self.param_config.atoms['right_parenthesis']}\"\n                    variable_b_str_2 = f\"{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['right_operand']}+1{self.param_config.atoms['right_parenthesis']}\"\n\n                # Generate the right-hand side expressions for the recursive function\n                if param1 == \"result\":\n                    param1_str_1 = f\"{variable_a_str_1}{op_symbol}{variable_b_str_1}\"\n                    param1_str_2 = f\"{variable_a_str_2}{op_symbol}{variable_b_str_2}\"\n                else:\n                    param1_str_1 = param1\n                    param1_str_2 = param1\n\n                if param2 == \"result\":\n                    param2_str_1 = f\"{variable_a_str_1}{op_symbol}{variable_b_str_1}\"\n                    param2_str_2 = f\"{variable_a_str_2}{op_symbol}{variable_b_str_2}\"\n                else:\n                    param2_str_1 = param2\n                    param2_str_2 = param2\n\n                rhs_1 = f\"{self.param_config.atoms['left_parenthesis']}{param1_str_1}{self.param_config.atoms['right_parenthesis']}{called_symbol}{self.param_config.atoms['left_parenthesis']}{param2_str_1}{self.param_config.atoms['right_parenthesis']}\"\n                rhs_2 = f\"{self.param_config.atoms['left_parenthesis']}{param1_str_2}{self.param_config.atoms['right_parenthesis']}{called_symbol}{self.param_config.atoms['left_parenthesis']}{param2_str_2}{self.param_config.atoms['right_parenthesis']}\"\n\n                if order &gt;= 3:\n                    definition = f\"{lhs} = {{{expr_str}, if {loop_variable} == 0; {rhs_1}, if {loop_variable} &gt; 0 and abs({loop_variable}) &lt; {loop_thres}; -{rhs_2}, if {loop_variable} &lt; 0 and abs({loop_variable}) &lt; {loop_thres}; {self.param_config.atoms['nan']}, else}}\"\n                else:\n                    definition = f\"{lhs} = {{{expr_str}, if {loop_variable} == 0; {rhs_1}, if {loop_variable} &gt; 0; -{rhs_2}, else}}\"\n                self.logger.debug(f\"Binary operator definition generated: {definition}\")\n\n            elif called_operator_info.n_ary == 1:\n                # # Check recursion validity for unary call within binary operator\n                # if not self.check_and_set_recursion_validity(\n                #     called_operator_info, op_type, None\n                # ):\n                #     self.logger.warning(\"Recursion validity check failed.\")\n                #     return None\n\n                op_compute_fun = f\"\"\"def op_{func_id}(a, b):\n{indent}special_values = [float('inf'), float('-inf')]\n{indent}if ({loop_variable} != {loop_variable}) or ({loop_variable} in special_values){thres_check}:\n{indent*2}return float('nan')\n{indent}result = {expr_str}\n{indent}for _ in range(abs({loop_variable})):\n{indent*2}temp_result = op_{called_id}(result)\n{indent*2}if abs(temp_result) &gt; thres:\n{indent*3}temp_result = float(\"inf\")\n{indent*2}result = temp_result if {loop_variable} &gt; 0 else -temp_result\n{indent}return result\n\"\"\"\n\n                op_count_fun = f\"\"\"def op_count_{func_id}(a, b):\n{indent}special_values = [float('inf'), float('-inf')]\n{indent}if ({loop_variable} != {loop_variable}) or ({loop_variable} in special_values){thres_check}:\n{indent*2}return 1\n{indent}result = {expr_str}\n{indent}count = 0 \n{indent}for _ in range(abs({loop_variable})):\n{indent*2}temp_result = op_{called_id}(result)\n{indent*2}count += op_count_{called_id}(result)\n{indent*2}if abs(temp_result) &gt; thres:\n{indent*3}temp_result = float(\"inf\")\n{indent*2}result = temp_result if {loop_variable} &gt; 0 else -temp_result\n{indent}return count if count &gt; 0 else 1\n\"\"\"\n\n                if loop_variable==self.param_config.atoms['left_operand']:\n                    variable_a_str_1 = f\"{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['left_operand']}-1{self.param_config.atoms['right_parenthesis']}\"\n                    variable_a_str_2 = f\"{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['left_operand']}+1{self.param_config.atoms['right_parenthesis']}\"\n                    variable_b_str_1 = self.param_config.atoms['right_operand']\n                    variable_b_str_2 = self.param_config.atoms['right_operand']\n                else:\n                    variable_a_str_1 = self.param_config.atoms['left_operand']\n                    variable_a_str_2 = self.param_config.atoms['left_operand']\n                    variable_b_str_1 = f\"{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['right_operand']}-1{self.param_config.atoms['right_parenthesis']}\"\n                    variable_b_str_2 = f\"{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['right_operand']}+1{self.param_config.atoms['right_parenthesis']}\"\n\n                param_str_1 = f\"{variable_a_str_1}{op_symbol}{variable_b_str_1}\"\n                param_str_2 = f\"{variable_a_str_2}{op_symbol}{variable_b_str_2}\"\n\n                if called_operator_info.unary_position == \"prefix\":\n                    rhs_1 = f\"{called_symbol}{self.param_config.atoms['left_parenthesis']}{param_str_1}{self.param_config.atoms['right_parenthesis']}\"\n                    rhs_2 = f\"{called_symbol}{self.param_config.atoms['left_parenthesis']}{param_str_2}{self.param_config.atoms['right_parenthesis']}\"\n                elif called_operator_info.unary_position == \"postfix\":\n                    rhs_1 = f\"{self.param_config.atoms['left_parenthesis']}{param_str_1}{self.param_config.atoms['right_parenthesis']}{called_symbol}\"\n                    rhs_2 = f\"{self.param_config.atoms['left_parenthesis']}{param_str_2}{self.param_config.atoms['right_parenthesis']}{called_symbol}\"\n\n                if order &gt;= 3:\n                    definition = f\"{lhs} = {{{expr_str}, if {loop_variable} == 0; {rhs_1}, if {loop_variable} &gt; 0 and abs({loop_variable}) &lt; {loop_thres}; -{rhs_2}, if {loop_variable} &lt; 0 and abs({loop_variable}) &lt; {loop_thres}; {self.param_config.atoms['nan']}, else}}\"\n                else:\n                    definition = f\"{lhs} = {{{expr_str}, if {loop_variable} == 0; {rhs_1}, if {loop_variable} &gt; 0; -{rhs_2}, else}}\"\n\n                self.logger.debug(\n                    f\"Unary operator within binary operator definition generated: {definition}\"\n                )\n\n        # Handle unary operator recursion\n        elif op_type == \"unary\":\n            loop_variable = self.param_config.atoms[\"left_operand\"]\n            thres_check = f\" or (abs(a) &gt; {loop_thres})\" if order&gt;=3 else \"\"\n\n            self.logger.debug(\"Generating recursive unary operator.\")\n\n            if called_operator_info.n_ary == 2:\n                param_order = random.choice(\n                    [\n                        (\"result\", \"result\"),\n                        (\"result\", self.param_config.atoms[\"left_operand\"]),\n                        (self.param_config.atoms[\"left_operand\"], \"result\"),\n                    ]\n                )\n                param1, param2 = param_order\n\n                self.logger.debug(\n                    f\"Selected parameter order for recursion: {param_order}\"\n                )\n\n                # if not self.check_and_set_recursion_validity(\n                #     called_operator_info, op_type, param_order\n                # ):\n                #     self.logger.warning(\"Recursion validity check failed.\")\n                #     return None\n\n                op_compute_fun = f\"\"\"def op_{func_id}(a):\n{indent}special_values = [float('inf'), float('-inf')]\n{indent}if (a != a) or (a in special_values){thres_check}:\n{indent*2}return float('nan')\n{indent}result = {expr_str}\n{indent}for _ in range(abs(a)):\n{indent*2}temp_result = op_{called_id}({param1}, {param2})\n{indent*2}if abs(temp_result) &gt; thres:\n{indent*3}temp_result = float(\"inf\")\n{indent*2}result = temp_result if a &gt; 0 else -temp_result\n{indent}return result\n\"\"\"\n\n                op_count_fun = f\"\"\"def op_count_{func_id}(a):\n{indent}special_values = [float('inf'), float('-inf')]\n{indent}if (a != a) or (a in special_values){thres_check}:\n{indent*2}return 1\n{indent}result = {expr_str}\n{indent}count = 0 \n{indent}for _ in range(abs(a)):\n{indent*2}temp_result = op_{called_id}({param1}, {param2})\n{indent*2}count += op_count_{called_id}({param1}, {param2})\n{indent*2}if abs(temp_result) &gt; thres:\n{indent*3}temp_result = float(\"inf\")\n{indent*2}result = temp_result if a &gt; 0 else -temp_result\n{indent}return count if count &gt; 0 else 1\n\"\"\"\n\n\n                if param1 == \"result\":\n                    if op_position == \"prefix\":\n                        param1_str_1 = f\"{op_symbol}{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['left_operand']}-1{self.param_config.atoms['right_parenthesis']}\"\n                        param1_str_2 = f\"{op_symbol}{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['left_operand']}+1{self.param_config.atoms['right_parenthesis']}\"\n                    elif op_position == \"postfix\":\n                        param1_str_1 = f\"{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['left_operand']}-1{self.param_config.atoms['right_parenthesis']}{op_symbol}\"\n                        param1_str_2 = f\"{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['left_operand']}+1{self.param_config.atoms['right_parenthesis']}{op_symbol}\"\n                else:\n                    param1_str_1 = param1\n                    param1_str_2 = param1\n\n                if param2 == \"result\":\n                    if op_position == \"prefix\":\n                        param2_str_1 = f\"{op_symbol}{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['left_operand']}-1{self.param_config.atoms['right_parenthesis']}\"\n                        param2_str_2 = f\"{op_symbol}{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['left_operand']}+1{self.param_config.atoms['right_parenthesis']}\"\n                    elif op_position == \"postfix\":\n                        param2_str_1 = f\"{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['left_operand']}-1{self.param_config.atoms['right_parenthesis']}{op_symbol}\"\n                        param2_str_2 = f\"{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['left_operand']}+1{self.param_config.atoms['right_parenthesis']}{op_symbol}\"\n                else:\n                    param2_str_1 = param1\n                    param2_str_2 = param1\n\n                rhs_1 = f\"{self.param_config.atoms['left_parenthesis']}{param1_str_1}{self.param_config.atoms['right_parenthesis']}{called_symbol}{self.param_config.atoms['left_parenthesis']}{param2_str_1}{self.param_config.atoms['right_parenthesis']}\"\n                rhs_2 = f\"{self.param_config.atoms['left_parenthesis']}{param1_str_2}{self.param_config.atoms['right_parenthesis']}{called_symbol}{self.param_config.atoms['left_parenthesis']}{param2_str_2}{self.param_config.atoms['right_parenthesis']}\"\n\n                if order &gt;= 3:\n                    definition = f\"{lhs} = {{{expr_str}, if {loop_variable} == 0; {rhs_1}, if {loop_variable} &gt; 0 and abs({loop_variable}) &lt; {loop_thres}; -{rhs_2}, if {loop_variable} &lt; 0 and abs({loop_variable}) &lt; {loop_thres}; {self.param_config.atoms['nan']}, else}}\"\n                else:\n                    definition = f\"{lhs} = {{{expr_str}, if {loop_variable} == 0; {rhs_1}, if {loop_variable} &gt; 0; -{rhs_2}, else}}\"\n\n                self.logger.debug(\n                    f\"Unary operator recursive definition generated: {definition}\"\n                )\n\n            elif called_operator_info.n_ary == 1:\n                # Check recursion validity for unary operator\n                # if not self.check_and_set_recursion_validity(\n                #     called_operator_info, op_type, None\n                # ):\n                #     self.logger.warning(\"Recursion validity check failed.\")\n                #     return None\n\n                op_compute_fun = f\"\"\"def op_{func_id}(a):\n{indent}special_values = [float('inf'), float('-inf')]\n{indent}if (a != a) or (a in special_values){thres_check}:\n{indent*2}return float('nan')\n{indent}result = {expr_str}\n{indent}for _ in range(abs(a)):\n{indent*2}temp_result = op_{called_id}(result)\n{indent*2}if abs(temp_result) &gt; thres:\n{indent*3}temp_result = float(\"inf\")\n{indent*2}result = temp_result if a &gt; 0 else -temp_result\n{indent}return result\n\"\"\"\n\n                op_count_fun = f\"\"\"def op_count_{func_id}(a):\n{indent}special_values = [float('inf'), float('-inf')]\n{indent}if (a != a) or (a in special_values){thres_check}:\n{indent*2}return 1\n{indent}result = {expr_str}\n{indent}count = 0 \n{indent}for _ in range(abs(a)):\n{indent*2}temp_result = op_{called_id}(result)\n{indent*2}count += op_count_{called_id}(result)\n{indent*2}if abs(temp_result) &gt; thres:\n{indent*3}temp_result = float(\"inf\")\n{indent*2}result = temp_result if a &gt; 0 else -temp_result\n{indent}return count if count &gt; 0 else 1\n\"\"\"\n\n                if op_position == \"prefix\":\n                    param_str_1 = f\"{op_symbol}{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['left_operand']}-1{self.param_config.atoms['right_parenthesis']}\"\n                    param_str_2 = f\"{op_symbol}{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['left_operand']}+1{self.param_config.atoms['right_parenthesis']}\"\n                elif op_position == \"postfix\":\n                    param_str_1 = f\"{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['left_operand']}-1{self.param_config.atoms['right_parenthesis']}{op_symbol}\"\n                    param_str_2 = f\"{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['left_operand']}+1{self.param_config.atoms['right_parenthesis']}{op_symbol}\"\n\n                if called_operator_info.unary_position == \"prefix\":\n                    rhs_1 = f\"{called_symbol}{self.param_config.atoms['left_parenthesis']}{param_str_1}{self.param_config.atoms['right_parenthesis']}\"\n                    rhs_2 = f\"{called_symbol}{self.param_config.atoms['left_parenthesis']}{param_str_2}{self.param_config.atoms['right_parenthesis']}\"\n                elif called_operator_info.unary_position == \"postfix\":\n                    rhs_1 = f\"{self.param_config.atoms['left_parenthesis']}{param_str_1}{self.param_config.atoms['right_parenthesis']}{called_symbol}\"\n                    rhs_2 = f\"{self.param_config.atoms['left_parenthesis']}{param_str_2}{self.param_config.atoms['right_parenthesis']}{called_symbol}\"\n\n                if order &gt;= 3:\n                    definition = f\"{lhs} = {{{expr_str}, if {loop_variable} == 0; {rhs_1}, if {loop_variable} &gt; 0 and abs({loop_variable}) &lt; {loop_thres}; -{rhs_2}, if {loop_variable} &lt; 0 and abs({loop_variable}) &lt; {loop_thres}; {self.param_config.atoms['nan']}, else}}\"\n                else:\n                    definition = f\"{lhs} = {{{expr_str}, if {loop_variable} == 0; {rhs_1}, if {loop_variable} &gt; 0; -{rhs_2}, else}}\"\n\n                self.logger.debug(f\"Unary operator definition generated: {definition}\")\n        else:\n            raise ValueError(\n                \"Unsupported operator type. Only 'unary' and 'binary' are supported.\"\n            )\n\n        operator_data = {\n            \"id\": None,  # Unique identifier for the operator.\n            \"func_id\": func_id,\n            \"symbol\": op_symbol,  # The symbol representing the operator (e.g., \"+\", \"-\", \"*\").\n            \"n_ary\": (\n                1 if op_type == \"unary\" else 2\n            ),  # Arity of the operator (1 for unary, 2 for binary).\n            \"unary_position\": (\n                op_position if op_type == \"unary\" else None\n            ),  # Position of the unary operator, None for binary.\n            \"n_order\": order,  # Computation order, managed by OperatorManager.\n            \"is_base\": None,  # Initially no base operator flag.\n            \"definition\": definition,  # Recursive definition of the operator.\n            \"definition_type\": \"recursive_definition\",  # Type of the definition (\"recursive_definition\").\n            \"priority\": None,  # Operator priority, not assigned yet.\n            \"associativity_direction\": None,  # Operator associativity, not assigned yet.\n            \"op_compute_func\": op_compute_fun,  # Function to compute the operator.\n            \"op_count_func\": op_count_fun,  # Function to count operations or recursive calls.\n            \"properties\": None,  # Additional properties of the operator, None initially.\n            \"dependencies\": None,  # Dependencies of the operator, None initially.\n            \"is_temporary\": True,  # Flag indicating the operator is temporarily generated.\n        }\n\n        # Log the generated operator data for tracking purposes.\n        self.logger.info(f\"Generated operator data: {operator_data}\")\n\n        return operator_data\n\n    def create_operator_info(self, choice: str, order: str) -&gt; Dict[str, Any]:\n        \"\"\"\n        Generate an OperatorInfo object.\n        \"\"\"\n        if choice == \"recursive_definition\":\n            operator_data = self.generate_recursive_operator_data_by_loop(order)\n        else:\n            operator_data = self.generate_operator_data_by_definition(choice, order)\n        return operator_data\n</code></pre>"},{"location":"operatorplus/operator_generator/#opulse.operatorplus.operator_generator.OperatorGenerator.__init__","title":"<code>__init__(param_config, logger, condition_generator, expr_generator, operator_manager)</code>","text":"<p>Initialize the OperatorGenerator.</p> <p>Parameters:</p> Name Type Description Default <code>param_config</code> <code>ParamConfig</code> <p>Configuration object containing parameters like symbols and operator details.</p> required <code>logger</code> <code>LogConfig</code> <p>Logger configuration to handle logging functionality.</p> required <code>condition_generator</code> <code>ConditionGenerator</code> <p>A generator responsible for producing conditions.</p> required <code>expr_generator</code> <code>ExpressionGenerator</code> <p>A generator responsible for producing expressions.</p> required <code>operator_manager</code> <code>OperatorManager</code> <p>Manages operator-related functionality.</p> required <p>Attributes:</p> Name Type Description <code>param_config</code> <code>ParamConfig</code> <p>Configuration object that holds various parameters.</p> <code>logger</code> <code>Logger</code> <p>Logger instance used for logging debug and info messages.</p> <code>standard_symbols</code> <code>list</code> <p>A list of standard operator symbols.</p> <code>unicode_symbols</code> <code>list</code> <p>A list of Unicode operator symbols.</p> <code>valid_symbols</code> <code>list</code> <p>A combined list of valid operator symbols (standard + Unicode).</p> <code>condition_generator</code> <code>ConditionGenerator</code> <p>The generator used to generate conditions.</p> <code>expr_generator</code> <code>ExpressionGenerator</code> <p>The generator used to generate expressions.</p> <code>operator_manager</code> <code>OperatorManager</code> <p>Manages operators for the generator.</p> <code>unary_variables</code> <code>list</code> <p>List of variables used in unary operations.</p> <code>binary_variables</code> <code>list</code> <p>List of variables used in binary operations.</p> <code>max_base</code> <code>int</code> <p>Maximum base value used in the generation process.</p> <code>operator_symbol_min_len</code> <code>int</code> <p>Minimum length for operator symbols.</p> <code>operator_symbol_max_len</code> <code>int</code> <p>Maximum length for operator symbols.</p> <code>max_if_branches</code> <code>int</code> <p>Maximum number of branches in conditional expressions.</p> Source code in <code>opulse/operatorplus/operator_generator.py</code> <pre><code>def __init__(\n    self,\n    param_config: ParamConfig,\n    logger: LogConfig,\n    condition_generator: ConditionGenerator,\n    expr_generator: ExpressionGenerator,\n    operator_manager: OperatorManager\n):\n    \"\"\"\n    Initialize the OperatorGenerator.\n\n    Parameters:\n        param_config (ParamConfig): Configuration object containing parameters like symbols and operator details.\n        logger (LogConfig): Logger configuration to handle logging functionality.\n        condition_generator (ConditionGenerator): A generator responsible for producing conditions.\n        expr_generator (ExpressionGenerator): A generator responsible for producing expressions.\n        operator_manager (OperatorManager): Manages operator-related functionality.\n\n    Attributes:\n        param_config (ParamConfig): Configuration object that holds various parameters.\n        logger (Logger): Logger instance used for logging debug and info messages.\n        standard_symbols (list): A list of standard operator symbols.\n        unicode_symbols (list): A list of Unicode operator symbols.\n        valid_symbols (list): A combined list of valid operator symbols (standard + Unicode).\n        condition_generator (ConditionGenerator): The generator used to generate conditions.\n        expr_generator (ExpressionGenerator): The generator used to generate expressions.\n        operator_manager (OperatorManager): Manages operators for the generator.\n        unary_variables (list): List of variables used in unary operations.\n        binary_variables (list): List of variables used in binary operations.\n        max_base (int): Maximum base value used in the generation process.\n        operator_symbol_min_len (int): Minimum length for operator symbols.\n        operator_symbol_max_len (int): Maximum length for operator symbols.\n        max_if_branches (int): Maximum number of branches in conditional expressions.\n    \"\"\"\n    self.param_config = param_config\n    self.logger = logger.get_logger()  # Get logger instance for logging\n    self.standard_symbols = self.param_config.get(\"basic_operator_symbols\")\n    self.unicode_symbols = self.get_unicode_symbols()\n    self.valid_symbols = self.standard_symbols + self.unicode_symbols\n    self.condition_generator = condition_generator  # Condition generator instance\n    self.expr_generator = expr_generator  # Expression generator instance\n    self.operator_manager = operator_manager  # Operator manager instance\n    self.unary_variables = [self.param_config.atoms[\"left_operand\"]]\n    self.binary_variables = [\n        self.param_config.atoms[\"left_operand\"],\n        self.param_config.atoms[\"right_operand\"],\n    ]\n    self.max_base = self.param_config.get(\"max_base\")\n    self.operator_symbol_min_len = self.param_config.get(\"operator_symbol_min_len\")\n    self.operator_symbol_max_len = self.param_config.get(\"operator_symbol_max_len\")\n    self.max_if_branches = self.param_config.get(\"max_if_branches\")\n\n    # self.expr_parser = expr_parser\n    # self.expr_transformer = expr_transformer\n    # Log initialization details\n    self.logger.info(\n        \"OperatorGenerator initialized with the following configuration:\"\n    )\n    self.logger.debug(f\"Standard symbols: {self.standard_symbols}\")\n    self.logger.debug(f\"Unicode symbols: {self.unicode_symbols}\")\n    self.logger.debug(f\"Valid symbols: {self.valid_symbols}\")\n    self.logger.debug(f\"Unary variables: {self.unary_variables}\")\n    self.logger.debug(f\"Binary variables: {self.binary_variables}\")\n    self.logger.debug(f\"Max base: {self.max_base}\")\n    self.logger.debug(f\"Operator symbol min length: {self.operator_symbol_min_len}\")\n    self.logger.debug(f\"Operator symbol max length: {self.operator_symbol_max_len}\")\n    self.logger.debug(f\"Max if branches: {self.max_if_branches}\")\n</code></pre>"},{"location":"operatorplus/operator_generator/#opulse.operatorplus.operator_generator.OperatorGenerator.create_operator_info","title":"<code>create_operator_info(choice, order)</code>","text":"<p>Generate an OperatorInfo object.</p> Source code in <code>opulse/operatorplus/operator_generator.py</code> <pre><code>def create_operator_info(self, choice: str, order: str) -&gt; Dict[str, Any]:\n    \"\"\"\n    Generate an OperatorInfo object.\n    \"\"\"\n    if choice == \"recursive_definition\":\n        operator_data = self.generate_recursive_operator_data_by_loop(order)\n    else:\n        operator_data = self.generate_operator_data_by_definition(choice, order)\n    return operator_data\n</code></pre>"},{"location":"operatorplus/operator_generator/#opulse.operatorplus.operator_generator.OperatorGenerator.generate_base_operators","title":"<code>generate_base_operators()</code>","text":"<p>Generates unary prefix operators for each base from 2 to self.max_base.</p> <p>This method creates a unary prefix operator for each base in the range from 2 to <code>self.max_base</code>. For each base, a random operator symbol is generated, and the operator is added to the operator manager. The operator is stored with additional properties, such as its base number and the unary position.</p> Source code in <code>opulse/operatorplus/operator_generator.py</code> <pre><code>def generate_base_operators(self):\n    \"\"\"\n    Generates unary prefix operators for each base from 2 to self.max_base.\n\n    This method creates a unary prefix operator for each base in the range from 2 to `self.max_base`.\n    For each base, a random operator symbol is generated, and the operator is added to the operator manager.\n    The operator is stored with additional properties, such as its base number and the unary position.\n\n    \"\"\"\n    self.logger.info(\n        \"Starting to generate base operators for each base from 2 to max_base.\"\n    )\n\n    # Iterate through the range of bases from 2 to max_base\n    for n in range(2, self.max_base + 1):\n        self.logger.debug(f\"Generating operator for base {n}.\")\n\n        # Get existing operator symbols to avoid duplication\n        existing_symbols = self.operator_manager.get_operator_symbols()\n\n        # Generate a random operator symbol that isn't already used\n        op_symbol = self.random_operator(existing_symbols)\n\n        # Define operator type and position\n        op_type = \"unary\"\n        op_position = \"prefix\"\n        func_id = generate(size=10,alphabet=alphabet)\n        # Construct the operator data\n        operator_data = {\n            \"id\": None,\n            \"func_id\":  func_id,\n            \"symbol\": op_symbol,\n            \"n_ary\": 1,  # Unary operator\n            \"unary_position\": op_position if op_type == \"unary\" else None,\n            \"n_order\": None,\n            \"is_base\": n,  # Base number\n            \"definition\": None,\n            \"definition_type\": None,\n            \"priority\": None,\n            \"associativity_direction\": None,\n            \"op_compute_func\": None,\n            \"op_count_func\": None,\n            \"properties\": None,\n            \"dependencies\": None,\n            \"is_temporary\": False,\n        }\n\n        new_base_operator = OperatorInfo(**operator_data)\n\n        # Add the generated operator to the operator manager\n        self.operator_manager.add_operator(new_base_operator)\n\n        self.logger.info(\n            f\"Base operator for base {n} with symbol '{op_symbol}' added successfully.\"\n        )\n\n    self.logger.info(\"Base operator generation completed.\")\n</code></pre>"},{"location":"operatorplus/operator_generator/#opulse.operatorplus.operator_generator.OperatorGenerator.generate_branches","title":"<code>generate_branches(order)</code>","text":"<p>Generates a list of conditional branches for an expression, including 'if' and 'else' branches.</p> <p>This method generates a random number of 'if' branches based on the maximum allowed number of branches (<code>max_if_branches</code>), each containing a randomly generated expression and a condition. Additionally, an 'else' branch is added with a randomly generated expression.</p> <p>The format of each branch is a tuple containing the expression and the corresponding condition.</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of tuples, each containing a generated expression and its associated condition.</p> <code>list</code> <p>Each tuple is in the form (expression, condition).</p> Source code in <code>opulse/operatorplus/operator_generator.py</code> <pre><code>def generate_branches(self, order) -&gt; list:\n    \"\"\"\n    Generates a list of conditional branches for an expression, including 'if' and 'else' branches.\n\n    This method generates a random number of 'if' branches based on the maximum allowed number\n    of branches (`max_if_branches`), each containing a randomly generated expression and a condition.\n    Additionally, an 'else' branch is added with a randomly generated expression.\n\n    The format of each branch is a tuple containing the expression and the corresponding condition.\n\n    Returns:\n        list: A list of tuples, each containing a generated expression and its associated condition.\n        Each tuple is in the form (expression, condition).\n    \"\"\"\n    self.logger.debug(\"Generating branches for conditional expressions.\")\n\n    num_if_branches = random.randint(2, self.max_if_branches)\n    branches = []\n\n    self.logger.info(f\"Generating {num_if_branches} 'if' branches.\")\n\n\n    exprs = self.expr_generator.create_n_expression_str_with_order(\n            max_depth=random.randint(1, self.expr_generator.max_depth),\n            atom_choice=\"variable_and_number\",\n            order=order,\n            branch_num=num_if_branches,\n        )\n\n    for i, expr in enumerate(exprs[:-1]):  \n        condition = self.condition_generator.generate_condition_expr()\n        branches.append((expr, f\"if {condition}\"))\n        self.logger.debug(f\"Generated 'if' branch {i+1}: {expr} with condition {condition}\")\n\n    last_expr = exprs[-1]  \n    branches.append((last_expr, \"else\"))  \n    self.logger.debug(f\"Generated 'else' branch: {last_expr}\")\n\n    self.logger.info(f\"Total branches generated: {len(branches)}.\")\n\n    return branches\n</code></pre>"},{"location":"operatorplus/operator_generator/#opulse.operatorplus.operator_generator.OperatorGenerator.generate_definition","title":"<code>generate_definition(op_symbol, op_type, op_position, choice, order)</code>","text":"<p>Generates a complete operator definition rule based on the provided parameters.</p> <p>This method constructs the definition of an operator, which can vary depending on the <code>choice</code> parameter. It can generate a simple expression, a recursive call, or a branching expression with conditional logic.</p> The definition can be generated in three different forms <ol> <li>Simple Definition: A basic operator definition without any conditional branching.</li> <li>Recursive Definition: A definition where the operator is recursively applied, based on the operator type (unary or binary).</li> <li>Branch Definition: A definition with multiple branches, using conditional logic (if-else statements) to determine the behavior.</li> </ol> <p>Parameters:</p> Name Type Description Default <code>op_symbol</code> <code>str</code> <p>The symbol representing the operator (e.g., '+', '-', '*', etc.).</p> required <code>op_type</code> <code>str</code> <p>The type of the operator, either 'unary' (one operand) or 'binary' (two operands).</p> required <code>op_position</code> <code>str</code> <p>The position of the unary operator, either 'prefix' or 'postfix'.</p> required <code>choice</code> <code>str</code> <p>A string that determines the type of operator definition to generate:         - \"simple_definition\": generates a simple expression without branching.         - \"recursive_definition\": generates an expression with a recursive call.         - \"branch_definition\": generates an expression with branching logic (if-else).</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A string representing the operator definition. The content of the string depends on the <code>choice</code> parameter: - For \"simple_definition\", a simple expression is returned. - For \"recursive_definition\", a recursive call expression is returned. - For \"branch_definition\", an expression with conditional branches is returned.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the <code>choice</code> parameter is not one of the recognized options (\"simple_definition\", \"recursive_definition\", \"branch_definition\").</p> Source code in <code>opulse/operatorplus/operator_generator.py</code> <pre><code>def generate_definition(self, op_symbol, op_type, op_position, choice, order) -&gt; str:\n    \"\"\"\n    Generates a complete operator definition rule based on the provided parameters.\n\n    This method constructs the definition of an operator, which can vary depending on the\n    `choice` parameter. It can generate a simple expression, a recursive call, or a branching\n    expression with conditional logic.\n\n    The definition can be generated in three different forms:\n        1. **Simple Definition**: A basic operator definition without any conditional branching.\n        2. **Recursive Definition**: A definition where the operator is recursively applied, based on the operator type (unary or binary).\n        3. **Branch Definition**: A definition with multiple branches, using conditional logic (if-else statements) to determine the behavior.\n\n    Parameters:\n        op_symbol (str): The symbol representing the operator (e.g., '+', '-', '*', etc.).\n        op_type (str): The type of the operator, either 'unary' (one operand) or 'binary' (two operands).\n        op_position (str): The position of the unary operator, either 'prefix' or 'postfix'.\n        choice (str): A string that determines the type of operator definition to generate:\n                    - \"simple_definition\": generates a simple expression without branching.\n                    - \"recursive_definition\": generates an expression with a recursive call.\n                    - \"branch_definition\": generates an expression with branching logic (if-else).\n\n    Returns:\n        str: A string representing the operator definition. The content of the string depends on the `choice` parameter:\n            - For \"simple_definition\", a simple expression is returned.\n            - For \"recursive_definition\", a recursive call expression is returned.\n            - For \"branch_definition\", an expression with conditional branches is returned.\n\n    Raises:\n        ValueError: If the `choice` parameter is not one of the recognized options (\"simple_definition\", \"recursive_definition\", \"branch_definition\").\n    \"\"\"\n    self.logger.debug(\n        f\"Generating definition for operator: {op_symbol}, Type: {op_type}, Position: {op_position}, Choice: {choice}\"\n    )\n\n    # Generate the left-hand side of the operator definition\n    lhs = self.generate_lhs(op_symbol, op_type, op_position)\n\n    if choice == \"simple_definition\":\n        # Simple expression, no branches\n        # expr = self.expr_generator.create_expression_str(\n        #     max_depth=random.randint(1, self.expr_generator.max_depth),\n        #     atom_choice=\"variable_and_number\",\n        # )\n        expr = self.expr_generator.create_n_expression_str_with_order(\n            max_depth=random.randint(1, self.expr_generator.max_depth),\n            atom_choice=\"variable_and_number\",\n            order=order,\n            branch_num=1,\n        )\n        self.logger.info(\n            f\"Simple definition generated: {lhs} {self.param_config.atoms['equal']} {{ {expr[0]} }}\"\n        )\n        return f\"{lhs} {self.param_config.atoms['equal']} {{ {expr[0]} }}\"\n\n    elif choice == \"recursive_definition\":\n        recursive_call = self.generate_recursive_call(\n            op_symbol, op_type, op_position\n        )\n        return f\"{lhs} = {{ {recursive_call} }}\"\n\n    elif choice == \"branch_definition\":\n        # Generate branches with conditions\n        branches = self.generate_branches(order)\n\n        # Build the branch strings\n        branch_strings = []\n        for expr, condition in branches:\n            if condition.startswith(\"if\"):\n                branch_strings.append(f\"{expr} , {condition}\")\n            elif condition == \"else\":\n                branch_strings.append(f\"{expr}, else\")\n\n        # Join branches with semicolons\n        rhs = \" ; \".join(branch_strings)\n        definition = f\"{lhs} {self.param_config.atoms['equal']} {{ {rhs} }}\"\n        self.logger.info(f\"Branch definition generated: {definition}\")\n        return definition\n\n    else:\n        self.logger.warning(f\"Unknown choice: {choice}. Returning None.\")\n        return None\n</code></pre>"},{"location":"operatorplus/operator_generator/#opulse.operatorplus.operator_generator.OperatorGenerator.generate_lhs","title":"<code>generate_lhs(op_symbol, op_type, op_position)</code>","text":"<p>Generates the left-hand side (LHS) of an expression based on the operator type and position.</p> <p>This method constructs the left-hand side of an expression depending on the type of operator (unary or binary) and its position (prefix or postfix). It uses the operator symbol and operands defined in the configuration.</p> <p>Parameters:</p> Name Type Description Default <code>op_symbol</code> <code>str</code> <p>The operator symbol to be used in the expression (e.g., \"+\", \"\u2295\").</p> required <code>op_type</code> <code>str</code> <p>The type of the operator, either \"unary\" or \"binary\".</p> required <code>op_position</code> <code>str</code> <p>The position of the operator, either \"prefix\" or \"postfix\" (only for unary operators).</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The generated left-hand side expression as a string.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the operator type is neither \"unary\" nor \"binary\".</p> Source code in <code>opulse/operatorplus/operator_generator.py</code> <pre><code>def generate_lhs(self, op_symbol, op_type, op_position) -&gt;str:\n    \"\"\"\n    Generates the left-hand side (LHS) of an expression based on the operator type and position.\n\n    This method constructs the left-hand side of an expression depending on the type of operator\n    (unary or binary) and its position (prefix or postfix). It uses the operator symbol and operands\n    defined in the configuration.\n\n    Parameters:\n        op_symbol (str): The operator symbol to be used in the expression (e.g., \"+\", \"\u2295\").\n        op_type (str): The type of the operator, either \"unary\" or \"binary\".\n        op_position (str): The position of the operator, either \"prefix\" or \"postfix\" (only for unary operators).\n\n    Returns:\n        str: The generated left-hand side expression as a string.\n\n    Raises:\n        ValueError: If the operator type is neither \"unary\" nor \"binary\".\n    \"\"\"\n\n    self.logger.debug(\n        f\"Generating LHS for operator '{op_symbol}', type '{op_type}', position '{op_position}'.\"\n    )\n\n    # Handle the case for unary operators\n    if op_type == \"unary\":\n        if op_position == \"prefix\":\n            lhs = f\"{op_symbol}{self.param_config.atoms['left_operand']}\"  # e.g., \"-a\"\n        elif op_position == \"postfix\":\n            lhs = f\"{self.param_config.atoms['left_operand']}{op_symbol}\"  # e.g., \"a-\"\n        else:\n            self.logger.error(\n                f\"Invalid position '{op_position}' for unary operator.\"\n            )\n            raise ValueError(\n                f\"Invalid position '{op_position}' for unary operator.\"\n            )\n\n    # Handle the case for binary operators\n    elif op_type == \"binary\":\n        lhs = f\"{self.param_config.atoms['left_operand']}{op_symbol}{self.param_config.atoms['right_operand']}\"  # e.g., 'a + b', 'a\u2295b'\n    else:\n        self.logger.error(f\"Invalid operator type '{op_type}' received.\")\n        raise ValueError(f\"Operator type must be either 'unary' or 'binary'.\")\n\n    self.logger.info(f\"LHS generated: {lhs}\")\n    return lhs\n</code></pre>"},{"location":"operatorplus/operator_generator/#opulse.operatorplus.operator_generator.OperatorGenerator.generate_operator_data_by_definition","title":"<code>generate_operator_data_by_definition(choice, order)</code>","text":"<p>Generates operator data based on a specified operator definition type.</p> <p>This method generates an operator symbol, determines its type (unary or binary), and sets its position (prefix or postfix). Then, it creates an operator definition based on the given <code>choice</code> parameter, which determines whether the operator definition is simple or involves conditional branching. The generated operator data includes the operator's symbol, type, position, and its corresponding definition.</p> <p>Parameters:</p> Name Type Description Default <code>choice</code> <code>str</code> <p>The type of operator definition to generate.         Can be one of the following:         - \"simple_definition\": Generates a basic operator expression without branching.         - \"branch_definition\": Generates an operator definition with conditional branching (if-else).         - \"recursive_definition\": generates an expression with a recursive call.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the generated operator data.</p> Source code in <code>opulse/operatorplus/operator_generator.py</code> <pre><code>def generate_operator_data_by_definition(self, choice, order) -&gt; dict:\n    \"\"\"\n    Generates operator data based on a specified operator definition type.\n\n    This method generates an operator symbol, determines its type (unary or binary), and sets\n    its position (prefix or postfix). Then, it creates an operator definition based on the given\n    `choice` parameter, which determines whether the operator definition is simple or involves\n    conditional branching. The generated operator data includes the operator's symbol, type,\n    position, and its corresponding definition.\n\n    Parameters:\n        choice (str): The type of operator definition to generate.\n                    Can be one of the following:\n                    - \"simple_definition\": Generates a basic operator expression without branching.\n                    - \"branch_definition\": Generates an operator definition with conditional branching (if-else).\n                    - \"recursive_definition\": generates an expression with a recursive call.\n\n    Returns:\n        dict: A dictionary containing the generated operator data.\n    \"\"\"\n    self.logger.debug(\n        f\"Generating operator data by definition with choice: {choice}\"\n    )\n\n    # Generate a random operator symbol that doesn't already exist in the operator manager\n    existing_symbols = self.operator_manager.get_operator_symbols()\n    op_symbol = self.random_operator(existing_symbols)\n    self.logger.debug(f\"Generated operator symbol: {op_symbol}\")\n\n    # Determine the type (unary or binary) and position (prefix or postfix) of the operator\n    op_type, op_position = self.random_operator_type_and_position()\n    self.logger.debug(f\"Operator type: {op_type}, Operator position: {op_position}\")\n\n    # Choose the appropriate variables based on the operator type\n    variables = (\n        self.unary_variables if op_type == \"unary\" else self.binary_variables\n    )\n    self.condition_generator.set_variables(variables)\n    self.expr_generator.set_variables(variables)\n    self.logger.debug(f\"Operator variables set to: {variables}\")\n\n    # Generate the operator definition based on the choice (simple or branch definition)\n    definition = self.generate_definition(op_symbol, op_type, op_position, choice, order)\n    self.logger.debug(f\"Generated operator definition: {definition}\")\n\n    func_id = generate(size=10,alphabet=alphabet)\n    # Construct the operator data dictionary\n    operator_data = {\n        \"id\": None,  \n        \"func_id\": func_id,\n        \"symbol\": op_symbol,\n        \"n_ary\": (\n            1 if op_type == \"unary\" else 2\n        ),  # Unary operators have 1 operand, binary have 2\n        \"unary_position\": op_position if op_type == \"unary\" else None,\n        \"n_order\": None,\n        \"is_base\": None,  # Not a base operator for now\n        \"definition\": definition,\n        \"definition_type\": choice,  # The type of definition generated (simple or branch)\n        \"priority\": None,  # Priority is not assigned for now\n        \"associativity_direction\": None,  # Not assigned for now\n        \"op_compute_func\": None,  # Compute function will be defined by the parser\n        \"op_count_func\": None,  # Count function will be defined by the parser\n        \"properties\": None,  # Properties are not assigned for now\n        \"dependencies\": None,  # Dependencies are not yet defined\n        \"is_temporary\": True,  # Indicates that this operator is temporary\n    }\n\n    self.logger.info(f\"Generated operator data: {operator_data}\")\n    return operator_data\n</code></pre>"},{"location":"operatorplus/operator_generator/#opulse.operatorplus.operator_generator.OperatorGenerator.generate_recursive_call","title":"<code>generate_recursive_call(op_symbol, op_type, op_position)</code>","text":"<p>Generates recursive expressions for binary and unary operators.</p> <p>This function creates recursive calls for both unary and binary operators based on the following rules:</p> For binary operators <ul> <li>If b == 0, generates a basic expression involving a and b.</li> <li>If b &gt; 0, generates an expression involving a and (b-1), where the expression on the right side must include (b-1).</li> <li>If b &lt; 0, generates an expression involving a and (b+1), where the expression on the right side must include (b+1).</li> </ul> For unary operators <ul> <li>If a == 0, randomly generates a number.</li> <li>If a &gt; 0, generates an expression solely involving (a-1), with its own symbol, and only related to (a-1).</li> <li>If a &lt; 0, generates an expression solely involving (a+1), with its own symbol, and only related to (a+1).</li> </ul> <p>Parameters: op_symbol (str): The operator symbol (e.g., '+', '-', '*', etc.) to be used in the expressions. op_type (str): The type of the operator. Can be either 'unary' or 'binary'. op_position (str): The position of the unary operator. Can be either 'prefix' or 'postfix' (relevant only for unary operators).</p> <p>Returns: str: A string representing the recursive expression for the operator, with conditions based on the values of 'a' and 'b'.</p> <p>Raises: ValueError: If the provided operator type is neither 'unary' nor 'binary'.</p> Source code in <code>opulse/operatorplus/operator_generator.py</code> <pre><code>def generate_recursive_call(self, op_symbol, op_type, op_position):\n    \"\"\"\n    Generates recursive expressions for binary and unary operators.\n\n    This function creates recursive calls for both unary and binary operators\n    based on the following rules:\n\n    For binary operators:\n        - If b == 0, generates a basic expression involving a and b.\n        - If b &gt; 0, generates an expression involving a and (b-1), where the expression on the right side must include (b-1).\n        - If b &lt; 0, generates an expression involving a and (b+1), where the expression on the right side must include (b+1).\n\n    For unary operators:\n        - If a == 0, randomly generates a number.\n        - If a &gt; 0, generates an expression solely involving (a-1), with its own symbol, and only related to (a-1).\n        - If a &lt; 0, generates an expression solely involving (a+1), with its own symbol, and only related to (a+1).\n\n    Parameters:\n    op_symbol (str): The operator symbol (e.g., '+', '-', '*', etc.) to be used in the expressions.\n    op_type (str): The type of the operator. Can be either 'unary' or 'binary'.\n    op_position (str): The position of the unary operator. Can be either 'prefix' or 'postfix' (relevant only for unary operators).\n\n    Returns:\n    str: A string representing the recursive expression for the operator, with conditions based on the values of 'a' and 'b'.\n\n    Raises:\n    ValueError: If the provided operator type is neither 'unary' nor 'binary'.\n    \"\"\"\n    if op_type == \"binary\":\n        # The recursive expression for generating binary operators with operands a and b.\n        self.expr_generator.set_variables(\n            [\n                self.param_config.atoms[\"left_operand\"],\n                self.param_config.atoms[\"right_operand\"],\n            ]\n        )\n\n        # If b == 0, generate a basic expression with a and b.\n        expr_base = self.expr_generator.create_expression_str(\n            atom_choice=\"variable_and_number\"\n        )\n\n        # If b &gt; 0, generate an expression involving a and (b-1) (note that the expression on the right side must include b-1).\n        recursive_variable = f\"{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['left_operand']}{op_symbol}{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['right_operand']}-1{self.param_config.atoms['right_parenthesis']}{self.param_config.atoms['right_parenthesis']}\"\n        self.expr_generator.set_variables(\n            [\n                self.param_config.atoms[\"left_operand\"],\n                self.param_config.atoms[\"right_operand\"],\n                recursive_variable,\n            ]\n        )\n        recursive_expr_1 = \"\"\n        while recursive_variable not in recursive_expr_1:\n            recursive_expr_1 = self.expr_generator.create_expression_str(\n                atom_choice=\"variable_and_number\"\n            )\n\n        # If b &lt; 0, generate an expression involving a and (b+1).\n        recursive_variable = f\"{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['left_operand']}{op_symbol}{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['right_operand']}+1{self.param_config.atoms['right_parenthesis']}{self.param_config.atoms['right_parenthesis']}\"\n        self.expr_generator.set_variables(\n            [\n                self.param_config.atoms[\"left_operand\"],\n                self.param_config.atoms[\"right_operand\"],\n                recursive_variable,\n            ]\n        )\n        recursive_expr_2 = \"\"\n        while recursive_variable not in recursive_expr_2:\n            recursive_expr_2 = self.expr_generator.create_expression_str(\n                atom_choice=\"variable_and_number\"\n            )\n\n        return f\"{expr_base}, if {self.param_config.atoms['right_operand']} == 0 ; {recursive_expr_1}, if {self.param_config.atoms['right_operand']} &gt; 0 ; {recursive_expr_2}, else\"\n\n    elif op_type == \"unary\":\n        # For unary operators, generate a recursive expression with a single parameter.\n        self.expr_generator.set_variables([self.param_config.atoms[\"left_operand\"]])\n\n        # If a == 0, randomly generate a number.\n        expr_base = self.expr_generator.create_expression_str(atom_choice=\"number\")\n\n        # If a &gt; 0, generate an expression solely involving (a-1), with its own symbol, and only related to (a-1).\n        if op_position == \"prefix\":\n            recursive_variable = (\n                f\"{op_symbol}({self.param_config.atoms['left_operand']}-1)\"\n            )\n        elif op_position == \"postfix\":\n            recursive_variable = (\n                f\"({self.param_config.atoms['left_operand']}-1){op_symbol}\"\n            )\n        self.expr_generator.set_variables(\n            [self.param_config.atoms[\"left_operand\"], recursive_variable]\n        )\n        recursive_expr_1 = \"\"\n        while recursive_variable not in recursive_expr_1:\n            recursive_expr_1 = self.expr_generator.create_expression_str(\n                atom_choice=\"variable_and_number\"\n            )\n\n        # If a &lt; 0, generate an expression solely involving (a+1), with its own symbol, and only related to (a+1).\n        if op_position == \"prefix\":\n            recursive_variable = (\n                f\"{op_symbol}({self.param_config.atoms['left_operand']}+1)\"\n            )\n        elif op_position == \"postfix\":\n            recursive_variable = (\n                f\"({self.param_config.atoms['left_operand']}+1){op_symbol}\"\n            )\n        self.expr_generator.set_variables(\n            [self.param_config.atoms[\"left_operand\"], recursive_variable]\n        )\n        recursive_expr_2 = \"\"\n        while recursive_variable not in recursive_expr_2:\n            recursive_expr_2 = self.expr_generator.create_expression_str(\n                atom_choice=\"variable_and_number\"\n            )\n\n        return f\"{expr_base}, if {self.param_config.atoms['left_operand']} == 0 ; {recursive_expr_1}, if {self.param_config.atoms['left_operand']} &gt; 0 ; {recursive_expr_2}, else\"\n\n    else:\n        raise ValueError(\n            \"Unsupported operator type. Only 'unary' and 'binary' are supported.\"\n        )\n</code></pre>"},{"location":"operatorplus/operator_generator/#opulse.operatorplus.operator_generator.OperatorGenerator.generate_recursive_operator_data_by_loop","title":"<code>generate_recursive_operator_data_by_loop(order)</code>","text":"<p>Generates recursive operator data, including both unary and binary operators, and defines recursive computation functions for the operators. The recursion involves calling other operators within the defined computation functions.</p> <p>This method constructs recursive operator definitions and the corresponding computation functions for both unary and binary operators based on the random operator type, position, and symbols. It checks recursion validity and ensures that recursion will not lead to infinite loops.</p> <p>The generated operator data includes: - The operator's symbol - Its type (unary or binary) - A computation function - A count function - A definition for the operator's behavior</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>Optional[dict]</code> <p>A dictionary containing the operator data, including the operator's   symbol, definition, and computation functions.</p> <code>None</code> <code>Optional[dict]</code> <p>If the recursion validity check fails, returns None.</p> Source code in <code>opulse/operatorplus/operator_generator.py</code> <pre><code>    def generate_recursive_operator_data_by_loop(self, order) -&gt; Optional[dict]:\n        \"\"\"\n        Generates recursive operator data, including both unary and binary operators,\n        and defines recursive computation functions for the operators. The recursion\n        involves calling other operators within the defined computation functions.\n\n        This method constructs recursive operator definitions and the corresponding\n        computation functions for both unary and binary operators based on the\n        random operator type, position, and symbols. It checks recursion validity\n        and ensures that recursion will not lead to infinite loops.\n\n        The generated operator data includes:\n        - The operator's symbol\n        - Its type (unary or binary)\n        - A computation function\n        - A count function\n        - A definition for the operator's behavior\n\n        Returns:\n            dict: A dictionary containing the operator data, including the operator's\n                  symbol, definition, and computation functions.\n            None: If the recursion validity check fails, returns None.\n        \"\"\"\n\n        self.logger.debug(\"Fetching existing operator symbols to avoid duplication.\")\n        existing_symbols = self.operator_manager.get_operator_symbols()\n\n        # Randomly select a new operator symbol\n        op_symbol = self.random_operator(existing_symbols)\n\n        self.logger.debug(f\"Selected operator symbol: {op_symbol}\")\n\n        # Randomly choose operator type (unary or binary) and position\n        # op_type, op_position = self.random_operator_type_and_position()\n        op_type, op_position = \"binary\", None\n        # Set the variables for condition and expression generators\n        variables = (\n            self.unary_variables if op_type == \"unary\" else self.binary_variables\n        )\n        self.condition_generator.set_variables(variables)\n        self.expr_generator.set_variables(variables)\n\n        # Generate the operator ID\n        func_id = generate(size=10,alphabet=alphabet)\n\n        self.logger.debug(f\"Generated operator Func ID: {func_id}\")\n\n        # Fetch a random recursive operator to be called in the recursion\n        called_operator_info = self.get_random_recursive_call_operator(order)\n        called_id = called_operator_info.func_id\n        called_symbol = called_operator_info.symbol\n        # called_operator_info.is_recursion_enabled=False#\u8bbe\u7f6e\u4e3a\u4e0d\u53ef\u4ee5\u88ab\u9012\u5f52\u8c03\u7528\u4e86\n\n        self.logger.debug(\n            f\"Chosen operator for recursion: {called_symbol} (ID: {called_id})\"\n        )\n\n        # Generate the left-hand side expression\n        lhs = self.generate_lhs(op_symbol, op_type, op_position)\n\n        indent = \"    \"\n\n        #Generate a basic expr here to use as the initial value of the result\n        choices = [self.param_config.atoms[\"left_operand\"], self.param_config.atoms[\"right_operand\"], int(random.uniform(-100, 100))]  \n        expr_str = f\"{random.choice(choices)}\"\n\n        #The range of the loop variable is restricted here.\n        if order == 3:\n            loop_thres=int(1e6)\n        elif order == 4:\n            loop_thres=int(1e3)\n        elif order == 5:\n            loop_thres=int(1e2)\n        else:\n            loop_thres=int(thres)\n\n        # Handle binary operator recursion\n        if op_type == \"binary\":\n            loop_variable = random.choice([self.param_config.atoms[\"left_operand\"], self.param_config.atoms[\"right_operand\"]])\n            thres_check = f\" or (abs({loop_variable}) &gt; {loop_thres})\" if order&gt;=3 else \"\"\n\n\n            self.logger.debug(\"Generating recursive binary operator.\")\n\n            if called_operator_info.n_ary == 2:\n                # Randomly select the parameter order for recursion\n                param_order = random.choice(\n                    [\n                        (\"result\", \"result\"),\n                        (\"result\", self.param_config.atoms[\"left_operand\"]),\n                        (\"result\", self.param_config.atoms[\"right_operand\"]),\n                        (self.param_config.atoms[\"left_operand\"], \"result\"),\n                        (self.param_config.atoms[\"right_operand\"], \"result\"),\n                    ]\n                )\n                param1, param2 = param_order\n\n                self.logger.debug(\n                    f\"Selected parameter order for recursion: {param_order}\"\n                )\n\n                # # Check recursion validity\n                # if not self.check_and_set_recursion_validity(\n                #     called_operator_info, op_type, param_order\n                # ):\n                #     self.logger.warning(\"Recursion validity check failed.\")\n                #     return None\n\n                # Generate the recursive computation function for binary operator\n                op_compute_fun = f\"\"\"def op_{func_id}(a, b):\n{indent}special_values = [float('inf'), float('-inf')]\n{indent}if ({loop_variable} != {loop_variable}) or ({loop_variable} in special_values){thres_check}:\n{indent*2}return float('nan')\n{indent}result = {expr_str}\n{indent}for _ in range(abs({loop_variable})):\n{indent*2}temp_result = op_{called_id}({param1}, {param2})\n{indent*2}if abs(temp_result) &gt; thres:\n{indent*3}temp_result = float(\"inf\")\n{indent*2}result = temp_result if {loop_variable} &gt; 0 else -temp_result\n{indent}return result\n\"\"\"\n\n\n                op_count_fun = f\"\"\"def op_count_{func_id}(a, b):\n{indent}special_values = [float('inf'), float('-inf')]\n{indent}if ({loop_variable} != {loop_variable}) or ({loop_variable} in special_values){thres_check}:\n{indent*2}return 1\n{indent}result = {expr_str}\n{indent}count = 0 \n{indent}for _ in range(abs({loop_variable})):\n{indent*2}temp_result = op_{called_id}({param1}, {param2})\n{indent*2}count += op_count_{called_id}({param1}, {param2})\n{indent*2}if abs(temp_result) &gt; thres:\n{indent*3}temp_result = float(\"inf\")\n{indent*2}result = temp_result if {loop_variable} &gt; 0 else -temp_result\n{indent}return count if count &gt; 0 else 1\n\"\"\"\n                if loop_variable==self.param_config.atoms['left_operand']:\n                    variable_a_str_1 = f\"{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['left_operand']}-1{self.param_config.atoms['right_parenthesis']}\"\n                    variable_a_str_2 = f\"{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['left_operand']}+1{self.param_config.atoms['right_parenthesis']}\"\n                    variable_b_str_1 = self.param_config.atoms['right_operand']\n                    variable_b_str_2 = self.param_config.atoms['right_operand']\n                else:\n                    variable_a_str_1 = self.param_config.atoms['left_operand']\n                    variable_a_str_2 = self.param_config.atoms['left_operand']\n                    variable_b_str_1 = f\"{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['right_operand']}-1{self.param_config.atoms['right_parenthesis']}\"\n                    variable_b_str_2 = f\"{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['right_operand']}+1{self.param_config.atoms['right_parenthesis']}\"\n\n                # Generate the right-hand side expressions for the recursive function\n                if param1 == \"result\":\n                    param1_str_1 = f\"{variable_a_str_1}{op_symbol}{variable_b_str_1}\"\n                    param1_str_2 = f\"{variable_a_str_2}{op_symbol}{variable_b_str_2}\"\n                else:\n                    param1_str_1 = param1\n                    param1_str_2 = param1\n\n                if param2 == \"result\":\n                    param2_str_1 = f\"{variable_a_str_1}{op_symbol}{variable_b_str_1}\"\n                    param2_str_2 = f\"{variable_a_str_2}{op_symbol}{variable_b_str_2}\"\n                else:\n                    param2_str_1 = param2\n                    param2_str_2 = param2\n\n                rhs_1 = f\"{self.param_config.atoms['left_parenthesis']}{param1_str_1}{self.param_config.atoms['right_parenthesis']}{called_symbol}{self.param_config.atoms['left_parenthesis']}{param2_str_1}{self.param_config.atoms['right_parenthesis']}\"\n                rhs_2 = f\"{self.param_config.atoms['left_parenthesis']}{param1_str_2}{self.param_config.atoms['right_parenthesis']}{called_symbol}{self.param_config.atoms['left_parenthesis']}{param2_str_2}{self.param_config.atoms['right_parenthesis']}\"\n\n                if order &gt;= 3:\n                    definition = f\"{lhs} = {{{expr_str}, if {loop_variable} == 0; {rhs_1}, if {loop_variable} &gt; 0 and abs({loop_variable}) &lt; {loop_thres}; -{rhs_2}, if {loop_variable} &lt; 0 and abs({loop_variable}) &lt; {loop_thres}; {self.param_config.atoms['nan']}, else}}\"\n                else:\n                    definition = f\"{lhs} = {{{expr_str}, if {loop_variable} == 0; {rhs_1}, if {loop_variable} &gt; 0; -{rhs_2}, else}}\"\n                self.logger.debug(f\"Binary operator definition generated: {definition}\")\n\n            elif called_operator_info.n_ary == 1:\n                # # Check recursion validity for unary call within binary operator\n                # if not self.check_and_set_recursion_validity(\n                #     called_operator_info, op_type, None\n                # ):\n                #     self.logger.warning(\"Recursion validity check failed.\")\n                #     return None\n\n                op_compute_fun = f\"\"\"def op_{func_id}(a, b):\n{indent}special_values = [float('inf'), float('-inf')]\n{indent}if ({loop_variable} != {loop_variable}) or ({loop_variable} in special_values){thres_check}:\n{indent*2}return float('nan')\n{indent}result = {expr_str}\n{indent}for _ in range(abs({loop_variable})):\n{indent*2}temp_result = op_{called_id}(result)\n{indent*2}if abs(temp_result) &gt; thres:\n{indent*3}temp_result = float(\"inf\")\n{indent*2}result = temp_result if {loop_variable} &gt; 0 else -temp_result\n{indent}return result\n\"\"\"\n\n                op_count_fun = f\"\"\"def op_count_{func_id}(a, b):\n{indent}special_values = [float('inf'), float('-inf')]\n{indent}if ({loop_variable} != {loop_variable}) or ({loop_variable} in special_values){thres_check}:\n{indent*2}return 1\n{indent}result = {expr_str}\n{indent}count = 0 \n{indent}for _ in range(abs({loop_variable})):\n{indent*2}temp_result = op_{called_id}(result)\n{indent*2}count += op_count_{called_id}(result)\n{indent*2}if abs(temp_result) &gt; thres:\n{indent*3}temp_result = float(\"inf\")\n{indent*2}result = temp_result if {loop_variable} &gt; 0 else -temp_result\n{indent}return count if count &gt; 0 else 1\n\"\"\"\n\n                if loop_variable==self.param_config.atoms['left_operand']:\n                    variable_a_str_1 = f\"{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['left_operand']}-1{self.param_config.atoms['right_parenthesis']}\"\n                    variable_a_str_2 = f\"{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['left_operand']}+1{self.param_config.atoms['right_parenthesis']}\"\n                    variable_b_str_1 = self.param_config.atoms['right_operand']\n                    variable_b_str_2 = self.param_config.atoms['right_operand']\n                else:\n                    variable_a_str_1 = self.param_config.atoms['left_operand']\n                    variable_a_str_2 = self.param_config.atoms['left_operand']\n                    variable_b_str_1 = f\"{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['right_operand']}-1{self.param_config.atoms['right_parenthesis']}\"\n                    variable_b_str_2 = f\"{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['right_operand']}+1{self.param_config.atoms['right_parenthesis']}\"\n\n                param_str_1 = f\"{variable_a_str_1}{op_symbol}{variable_b_str_1}\"\n                param_str_2 = f\"{variable_a_str_2}{op_symbol}{variable_b_str_2}\"\n\n                if called_operator_info.unary_position == \"prefix\":\n                    rhs_1 = f\"{called_symbol}{self.param_config.atoms['left_parenthesis']}{param_str_1}{self.param_config.atoms['right_parenthesis']}\"\n                    rhs_2 = f\"{called_symbol}{self.param_config.atoms['left_parenthesis']}{param_str_2}{self.param_config.atoms['right_parenthesis']}\"\n                elif called_operator_info.unary_position == \"postfix\":\n                    rhs_1 = f\"{self.param_config.atoms['left_parenthesis']}{param_str_1}{self.param_config.atoms['right_parenthesis']}{called_symbol}\"\n                    rhs_2 = f\"{self.param_config.atoms['left_parenthesis']}{param_str_2}{self.param_config.atoms['right_parenthesis']}{called_symbol}\"\n\n                if order &gt;= 3:\n                    definition = f\"{lhs} = {{{expr_str}, if {loop_variable} == 0; {rhs_1}, if {loop_variable} &gt; 0 and abs({loop_variable}) &lt; {loop_thres}; -{rhs_2}, if {loop_variable} &lt; 0 and abs({loop_variable}) &lt; {loop_thres}; {self.param_config.atoms['nan']}, else}}\"\n                else:\n                    definition = f\"{lhs} = {{{expr_str}, if {loop_variable} == 0; {rhs_1}, if {loop_variable} &gt; 0; -{rhs_2}, else}}\"\n\n                self.logger.debug(\n                    f\"Unary operator within binary operator definition generated: {definition}\"\n                )\n\n        # Handle unary operator recursion\n        elif op_type == \"unary\":\n            loop_variable = self.param_config.atoms[\"left_operand\"]\n            thres_check = f\" or (abs(a) &gt; {loop_thres})\" if order&gt;=3 else \"\"\n\n            self.logger.debug(\"Generating recursive unary operator.\")\n\n            if called_operator_info.n_ary == 2:\n                param_order = random.choice(\n                    [\n                        (\"result\", \"result\"),\n                        (\"result\", self.param_config.atoms[\"left_operand\"]),\n                        (self.param_config.atoms[\"left_operand\"], \"result\"),\n                    ]\n                )\n                param1, param2 = param_order\n\n                self.logger.debug(\n                    f\"Selected parameter order for recursion: {param_order}\"\n                )\n\n                # if not self.check_and_set_recursion_validity(\n                #     called_operator_info, op_type, param_order\n                # ):\n                #     self.logger.warning(\"Recursion validity check failed.\")\n                #     return None\n\n                op_compute_fun = f\"\"\"def op_{func_id}(a):\n{indent}special_values = [float('inf'), float('-inf')]\n{indent}if (a != a) or (a in special_values){thres_check}:\n{indent*2}return float('nan')\n{indent}result = {expr_str}\n{indent}for _ in range(abs(a)):\n{indent*2}temp_result = op_{called_id}({param1}, {param2})\n{indent*2}if abs(temp_result) &gt; thres:\n{indent*3}temp_result = float(\"inf\")\n{indent*2}result = temp_result if a &gt; 0 else -temp_result\n{indent}return result\n\"\"\"\n\n                op_count_fun = f\"\"\"def op_count_{func_id}(a):\n{indent}special_values = [float('inf'), float('-inf')]\n{indent}if (a != a) or (a in special_values){thres_check}:\n{indent*2}return 1\n{indent}result = {expr_str}\n{indent}count = 0 \n{indent}for _ in range(abs(a)):\n{indent*2}temp_result = op_{called_id}({param1}, {param2})\n{indent*2}count += op_count_{called_id}({param1}, {param2})\n{indent*2}if abs(temp_result) &gt; thres:\n{indent*3}temp_result = float(\"inf\")\n{indent*2}result = temp_result if a &gt; 0 else -temp_result\n{indent}return count if count &gt; 0 else 1\n\"\"\"\n\n\n                if param1 == \"result\":\n                    if op_position == \"prefix\":\n                        param1_str_1 = f\"{op_symbol}{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['left_operand']}-1{self.param_config.atoms['right_parenthesis']}\"\n                        param1_str_2 = f\"{op_symbol}{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['left_operand']}+1{self.param_config.atoms['right_parenthesis']}\"\n                    elif op_position == \"postfix\":\n                        param1_str_1 = f\"{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['left_operand']}-1{self.param_config.atoms['right_parenthesis']}{op_symbol}\"\n                        param1_str_2 = f\"{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['left_operand']}+1{self.param_config.atoms['right_parenthesis']}{op_symbol}\"\n                else:\n                    param1_str_1 = param1\n                    param1_str_2 = param1\n\n                if param2 == \"result\":\n                    if op_position == \"prefix\":\n                        param2_str_1 = f\"{op_symbol}{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['left_operand']}-1{self.param_config.atoms['right_parenthesis']}\"\n                        param2_str_2 = f\"{op_symbol}{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['left_operand']}+1{self.param_config.atoms['right_parenthesis']}\"\n                    elif op_position == \"postfix\":\n                        param2_str_1 = f\"{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['left_operand']}-1{self.param_config.atoms['right_parenthesis']}{op_symbol}\"\n                        param2_str_2 = f\"{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['left_operand']}+1{self.param_config.atoms['right_parenthesis']}{op_symbol}\"\n                else:\n                    param2_str_1 = param1\n                    param2_str_2 = param1\n\n                rhs_1 = f\"{self.param_config.atoms['left_parenthesis']}{param1_str_1}{self.param_config.atoms['right_parenthesis']}{called_symbol}{self.param_config.atoms['left_parenthesis']}{param2_str_1}{self.param_config.atoms['right_parenthesis']}\"\n                rhs_2 = f\"{self.param_config.atoms['left_parenthesis']}{param1_str_2}{self.param_config.atoms['right_parenthesis']}{called_symbol}{self.param_config.atoms['left_parenthesis']}{param2_str_2}{self.param_config.atoms['right_parenthesis']}\"\n\n                if order &gt;= 3:\n                    definition = f\"{lhs} = {{{expr_str}, if {loop_variable} == 0; {rhs_1}, if {loop_variable} &gt; 0 and abs({loop_variable}) &lt; {loop_thres}; -{rhs_2}, if {loop_variable} &lt; 0 and abs({loop_variable}) &lt; {loop_thres}; {self.param_config.atoms['nan']}, else}}\"\n                else:\n                    definition = f\"{lhs} = {{{expr_str}, if {loop_variable} == 0; {rhs_1}, if {loop_variable} &gt; 0; -{rhs_2}, else}}\"\n\n                self.logger.debug(\n                    f\"Unary operator recursive definition generated: {definition}\"\n                )\n\n            elif called_operator_info.n_ary == 1:\n                # Check recursion validity for unary operator\n                # if not self.check_and_set_recursion_validity(\n                #     called_operator_info, op_type, None\n                # ):\n                #     self.logger.warning(\"Recursion validity check failed.\")\n                #     return None\n\n                op_compute_fun = f\"\"\"def op_{func_id}(a):\n{indent}special_values = [float('inf'), float('-inf')]\n{indent}if (a != a) or (a in special_values){thres_check}:\n{indent*2}return float('nan')\n{indent}result = {expr_str}\n{indent}for _ in range(abs(a)):\n{indent*2}temp_result = op_{called_id}(result)\n{indent*2}if abs(temp_result) &gt; thres:\n{indent*3}temp_result = float(\"inf\")\n{indent*2}result = temp_result if a &gt; 0 else -temp_result\n{indent}return result\n\"\"\"\n\n                op_count_fun = f\"\"\"def op_count_{func_id}(a):\n{indent}special_values = [float('inf'), float('-inf')]\n{indent}if (a != a) or (a in special_values){thres_check}:\n{indent*2}return 1\n{indent}result = {expr_str}\n{indent}count = 0 \n{indent}for _ in range(abs(a)):\n{indent*2}temp_result = op_{called_id}(result)\n{indent*2}count += op_count_{called_id}(result)\n{indent*2}if abs(temp_result) &gt; thres:\n{indent*3}temp_result = float(\"inf\")\n{indent*2}result = temp_result if a &gt; 0 else -temp_result\n{indent}return count if count &gt; 0 else 1\n\"\"\"\n\n                if op_position == \"prefix\":\n                    param_str_1 = f\"{op_symbol}{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['left_operand']}-1{self.param_config.atoms['right_parenthesis']}\"\n                    param_str_2 = f\"{op_symbol}{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['left_operand']}+1{self.param_config.atoms['right_parenthesis']}\"\n                elif op_position == \"postfix\":\n                    param_str_1 = f\"{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['left_operand']}-1{self.param_config.atoms['right_parenthesis']}{op_symbol}\"\n                    param_str_2 = f\"{self.param_config.atoms['left_parenthesis']}{self.param_config.atoms['left_operand']}+1{self.param_config.atoms['right_parenthesis']}{op_symbol}\"\n\n                if called_operator_info.unary_position == \"prefix\":\n                    rhs_1 = f\"{called_symbol}{self.param_config.atoms['left_parenthesis']}{param_str_1}{self.param_config.atoms['right_parenthesis']}\"\n                    rhs_2 = f\"{called_symbol}{self.param_config.atoms['left_parenthesis']}{param_str_2}{self.param_config.atoms['right_parenthesis']}\"\n                elif called_operator_info.unary_position == \"postfix\":\n                    rhs_1 = f\"{self.param_config.atoms['left_parenthesis']}{param_str_1}{self.param_config.atoms['right_parenthesis']}{called_symbol}\"\n                    rhs_2 = f\"{self.param_config.atoms['left_parenthesis']}{param_str_2}{self.param_config.atoms['right_parenthesis']}{called_symbol}\"\n\n                if order &gt;= 3:\n                    definition = f\"{lhs} = {{{expr_str}, if {loop_variable} == 0; {rhs_1}, if {loop_variable} &gt; 0 and abs({loop_variable}) &lt; {loop_thres}; -{rhs_2}, if {loop_variable} &lt; 0 and abs({loop_variable}) &lt; {loop_thres}; {self.param_config.atoms['nan']}, else}}\"\n                else:\n                    definition = f\"{lhs} = {{{expr_str}, if {loop_variable} == 0; {rhs_1}, if {loop_variable} &gt; 0; -{rhs_2}, else}}\"\n\n                self.logger.debug(f\"Unary operator definition generated: {definition}\")\n        else:\n            raise ValueError(\n                \"Unsupported operator type. Only 'unary' and 'binary' are supported.\"\n            )\n\n        operator_data = {\n            \"id\": None,  # Unique identifier for the operator.\n            \"func_id\": func_id,\n            \"symbol\": op_symbol,  # The symbol representing the operator (e.g., \"+\", \"-\", \"*\").\n            \"n_ary\": (\n                1 if op_type == \"unary\" else 2\n            ),  # Arity of the operator (1 for unary, 2 for binary).\n            \"unary_position\": (\n                op_position if op_type == \"unary\" else None\n            ),  # Position of the unary operator, None for binary.\n            \"n_order\": order,  # Computation order, managed by OperatorManager.\n            \"is_base\": None,  # Initially no base operator flag.\n            \"definition\": definition,  # Recursive definition of the operator.\n            \"definition_type\": \"recursive_definition\",  # Type of the definition (\"recursive_definition\").\n            \"priority\": None,  # Operator priority, not assigned yet.\n            \"associativity_direction\": None,  # Operator associativity, not assigned yet.\n            \"op_compute_func\": op_compute_fun,  # Function to compute the operator.\n            \"op_count_func\": op_count_fun,  # Function to count operations or recursive calls.\n            \"properties\": None,  # Additional properties of the operator, None initially.\n            \"dependencies\": None,  # Dependencies of the operator, None initially.\n            \"is_temporary\": True,  # Flag indicating the operator is temporarily generated.\n        }\n\n        # Log the generated operator data for tracking purposes.\n        self.logger.info(f\"Generated operator data: {operator_data}\")\n\n        return operator_data\n</code></pre>"},{"location":"operatorplus/operator_generator/#opulse.operatorplus.operator_generator.OperatorGenerator.get_random_recursive_call_operator","title":"<code>get_random_recursive_call_operator(order)</code>","text":"<p>Selects a random operator that supports recursion from the operator manager.</p> <p>This method filters the operators managed by the <code>operator_manager</code> to find those that have recursion enabled (i.e., <code>is_recursion_enabled</code> is True). It then selects a random operator from the filtered list and returns the corresponding <code>OperatorInfo</code> object.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no operators are available in the operator manager.</p> <code>ValueError</code> <p>If no operators with recursion enabled are available.</p> <p>Returns:</p> Name Type Description <code>OperatorInfo</code> <code>OperatorInfo</code> <p>The selected operator's <code>OperatorInfo</code> object, including its ID, symbol, and other properties.</p> Source code in <code>opulse/operatorplus/operator_generator.py</code> <pre><code>def get_random_recursive_call_operator(self, order) -&gt; OperatorInfo:\n    \"\"\"\n    Selects a random operator that supports recursion from the operator manager.\n\n    This method filters the operators managed by the `operator_manager` to find those\n    that have recursion enabled (i.e., `is_recursion_enabled` is True). It then selects\n    a random operator from the filtered list and returns the corresponding `OperatorInfo` object.\n\n    Raises:\n        ValueError: If no operators are available in the operator manager.\n        ValueError: If no operators with recursion enabled are available.\n\n    Returns:\n        OperatorInfo: The selected operator's `OperatorInfo` object, including its ID, symbol, and other properties.\n    \"\"\"\n    self.logger.debug(\"Attempting to get a random recursive call operator.\")\n\n    # Check if there are any operators available in the operator manager\n    if not self.operator_manager.operators:\n        self.logger.error(\"No operators available in the operator manager.\")\n        raise ValueError(\"No operators available.\")\n\n    # Filter operators that have recursion enabled\n    recursive_operators = [\n        (operator_id, operator_info)\n        for operator_id, operator_info in self.operator_manager.operators.items()\n        if operator_info.n_order==order-1\n    ]\n\n    self.logger.debug(\n        f\"Filtered operators with recursion enabled: {recursive_operators}\"\n    )\n\n    # If no operators with recursion are available, raise an exception\n    if not recursive_operators:\n        self.logger.error(\"No operators with recursion enabled.\")\n        raise ValueError(\"No operators with recursion enabled.\")\n\n    # Randomly select one operator from the filtered list\n    _, operator_info = random.choice(recursive_operators)\n    self.logger.debug(f\"Selected operator: {operator_info}\")\n\n    # Return the `OperatorInfo` instance instead of a tuple\n    self.logger.info(f\"Random recursive call operator selected: {operator_info}\")\n    return operator_info  # Returning an instance of OperatorInfo\n</code></pre>"},{"location":"operatorplus/operator_generator/#opulse.operatorplus.operator_generator.OperatorGenerator.get_unicode_symbols","title":"<code>get_unicode_symbols()</code>","text":"<p>Collects valid Unicode operator symbols from predefined ranges.</p> <p>This method retrieves symbols from several mathematical and arrow ranges in Unicode: - Mathematical Operators (U+2200 to U+22FF) - Supplemental Mathematical Operators (U+2A00 to U+2AFF) - Arrows (U+2190 to U+21FF)</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of valid Unicode operator symbols.</p> Source code in <code>opulse/operatorplus/operator_generator.py</code> <pre><code>def get_unicode_symbols(self) -&gt; list:\n    \"\"\"\n    Collects valid Unicode operator symbols from predefined ranges.\n\n    This method retrieves symbols from several mathematical and arrow ranges in Unicode:\n    - Mathematical Operators (U+2200 to U+22FF)\n    - Supplemental Mathematical Operators (U+2A00 to U+2AFF)\n    - Arrows (U+2190 to U+21FF)\n\n    Returns:\n        list: A list of valid Unicode operator symbols.\n    \"\"\"\n    self.logger.info(\"Collecting Unicode symbols from predefined ranges.\")\n    unicode_ranges = [\n        (0x2200, 0x22FF),  # Mathematical Operators\n        (0x2A00, 0x2AFF),  # Supplemental Mathematical Operators\n        (0x2190, 0x21FF),  # Arrows\n    ]\n\n    symbols = []\n\n    for start, end in unicode_ranges:\n        for codepoint in range(start, end + 1):\n            char = chr(codepoint)\n            symbols.append(char)\n\n    self.logger.debug(f\"Collected {len(symbols)} Unicode symbols.\")\n    return symbols\n</code></pre>"},{"location":"operatorplus/operator_generator/#opulse.operatorplus.operator_generator.OperatorGenerator.random_operator","title":"<code>random_operator(existing_symbols)</code>","text":"<p>Generates a random operator string composed of one or more valid symbols.</p> <p>This method generates a random operator string with a length between <code>operator_symbol_min_len</code> and <code>operator_symbol_max_len</code>, ensuring that the generated operator does not already exist in the list of <code>existing_symbols</code>.</p> <p>Parameters:</p> Name Type Description Default <code>existing_symbols</code> <code>List[str]</code> <p>A list of currently existing operator symbols.                             The new symbol must not be in this list.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The generated random operator string that is unique and within the specified length range.</p> Source code in <code>opulse/operatorplus/operator_generator.py</code> <pre><code>def random_operator(self, existing_symbols: List[str]) -&gt; str:\n    \"\"\"\n    Generates a random operator string composed of one or more valid symbols.\n\n    This method generates a random operator string with a length between\n    `operator_symbol_min_len` and `operator_symbol_max_len`, ensuring that\n    the generated operator does not already exist in the list of `existing_symbols`.\n\n    Parameters:\n        existing_symbols (List[str]): A list of currently existing operator symbols.\n                                        The new symbol must not be in this list.\n\n    Returns:\n        str: The generated random operator string that is unique and within the specified length range.\n    \"\"\"\n    self.logger.info(\"Generating a random operator string.\")\n\n    # Loop until a unique operator is generated\n    while True:\n        # Randomly choose a length for the operator within the specified range\n        length = random.randint(\n            self.operator_symbol_min_len, self.operator_symbol_max_len\n        )\n\n        # Generate the new symbol by randomly picking characters from valid symbols\n        new_symbol = \"\".join(\n            random.choice(self.valid_symbols) for _ in range(length)\n        )\n\n        # Check if the generated symbol is unique (not in existing_symbols)\n        if new_symbol not in existing_symbols:\n            self.logger.debug(\n                f\"Generated new operator symbol: {new_symbol} with length {length}.\"\n            )\n            return new_symbol\n        else:\n            self.logger.debug(\n                f\"Generated operator {new_symbol} already exists. Retrying...\"\n            )\n</code></pre>"},{"location":"operatorplus/operator_generator/#opulse.operatorplus.operator_generator.OperatorGenerator.random_operator_type_and_position","title":"<code>random_operator_type_and_position()</code>","text":"<p>Generates a random operator type and its position (if applicable).</p> <p>This method randomly selects an operator type, either \"unary\" or \"binary\". If the type is \"unary\", it also randomly chooses its position, either \"prefix\" or \"postfix\". For \"binary\" operators, the position is not applicable (set to None).</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple</code> <p>A tuple containing the operator type and its position. If the operator type is \"unary\", the position is either \"prefix\" or \"postfix\". If the operator type is \"binary\", the position is None.</p> Source code in <code>opulse/operatorplus/operator_generator.py</code> <pre><code>def random_operator_type_and_position(self) -&gt; tuple:\n    \"\"\"\n    Generates a random operator type and its position (if applicable).\n\n    This method randomly selects an operator type, either \"unary\" or \"binary\".\n    If the type is \"unary\", it also randomly chooses its position, either \"prefix\" or \"postfix\".\n    For \"binary\" operators, the position is not applicable (set to None).\n\n    Returns:\n        tuple: A tuple containing the operator type and its position.\n            If the operator type is \"unary\", the position is either \"prefix\" or \"postfix\".\n            If the operator type is \"binary\", the position is None.\n    \"\"\"\n    self.logger.info(\"Generating random operator type and position.\")\n\n    # Randomly select the operator type\n    op_type = random.choice([\"unary\", \"binary\"])\n\n    # Initialize unary_position as None\n    unary_position = None\n\n    # If the operator type is \"unary\", randomly choose its position\n    if op_type == \"unary\":\n        unary_position = random.choice([\"prefix\", \"postfix\"])\n\n    # Log the final operator type and position\n    self.logger.info(\n        f\"Operator type: {op_type}, Position: {unary_position if unary_position else 'None'}\"\n    )\n\n    return op_type, unary_position\n</code></pre>"},{"location":"operatorplus/operator_info/","title":"OperatorInfo","text":""},{"location":"operatorplus/operator_info/#opulse.operatorplus.operator_info.OperatorInfo","title":"<code>OperatorInfo</code>","text":"Source code in <code>opulse/operatorplus/operator_info.py</code> <pre><code>class OperatorInfo:\n    def __init__(\n        self,\n        id: int,\n        func_id: str,\n        symbol: str,\n        n_ary: int,  # 1 for unary, 2 for binary\n        unary_position: Optional[str],  # 'prefix', 'postfix', or None\n        n_order: int,  # Order, used to measure complexity, particularly for recursive definitions\n        is_base: Optional[\n            int\n        ],  # Used to identify the base type, e.g., 2 for binary, 10 for decimal, 16 for hexadecimal\n        definition: Optional[str],\n        definition_type: Optional[\n            str\n        ],  # Types: simple_definition, recursive_definition, branch_definition\n        priority: int,  # Priority for operations with the same level, higher values represent higher priority\n        associativity_direction: Optional[str],  # 'left', 'right', or None\n\n        op_compute_func: Optional[\n            str\n        ],  # Function code for the operator, e.g., \"def op_11(a, b): ...\"\n        op_count_func: Optional[\n            str\n        ],  # Function code to calculate the count, e.g., base = 0\n        z3_compute_func: Optional[\n            str\n        ] = None,  ##TODO:Still in the process of realising, Used for constraint solving\n        properties: Optional[\n            Dict[str, bool]\n        ] = None,  # Other properties such as \"commutative\", \"associative\", \"idempotent\", etc.\n        weight: Optional[float] = 1,  # Probability of being selected\n        dependencies: Optional[\n            List[int]\n        ] = None,  # Record dependencies on other operators\n        is_temporary: bool = False,  # Whether the operator is temporary (for incomplete information)\n        recursive_used_cases: int = 0b00000000,  # Record used recursive cases\n        is_recursion_enabled: bool = True,  # Whether recursion can still be enabled based on the recursive type\n        module: Optional[ctypes.CDLL] = None\n    ):\n        \"\"\"\n        Initializes the OperatorInfo object with various parameters describing the operator's properties.\n\n        Parameters:\n            id (int): Unique identifier for the operator.\n            func_id (str): Function identifier for the operator.\n            symbol (str): Symbol representing the operator.\n            n_ary (int): Arity of the operator, either 1 for unary or 2 for binary.\n            unary_position (Optional[str]): Position for unary operators ('prefix', 'postfix', or None).\n            n_order (int): Order to measure complexity, especially for recursive operators.\n            is_base (Optional[int]): Base type identifier (e.g., 2 for binary, 10 for decimal, 16 for hexadecimal).\n            definition (Optional[str]): Definition of the operator (could be a string representation of the definition).\n            definition_type (Optional[str]): Type of definition ('simple_definition', 'recursive_definition', or 'branch_definition').\n            priority (int): Priority of the operator, higher means higher priority.\n            associativity_direction (Optional[str]): Direction of associativity ('left', 'right', or None).\n            op_compute_func (Optional[str]): Code string for computing the operator's result.\n            op_count_func (Optional[str]): Code string for counting the operations.\n            z3_compute_func (Optional[str]): Function code for constraint solving (still under development).\n            properties (Optional[Dict[str, bool]]): Additional properties of the operator (e.g., commutative, associative, etc.).\n            weight (Optional[float]): Probability of the operator being selected.\n            dependencies (Optional[List[int]]): List of dependencies on other operators.\n            is_temporary (bool): Whether the operator is temporary, typically used when its information is incomplete.\n            recursive_used_cases (int): Record of the recursive cases used.\n            is_recursion_enabled (bool): Whether recursion is still allowed for this operator.\n            module (Optional[ctypes.CDLL]): Compiled module containing the operator's functions.\n        \"\"\"\n        self.id = id\n        self.func_id = func_id\n        self.symbol = symbol\n        self.n_ary = n_ary\n        self.unary_position = unary_position\n        self.n_order = n_order\n        self.is_base = is_base\n        self.definition = definition\n        self.definition_type = definition_type\n        self.priority = priority\n        self.associativity_direction = associativity_direction\n\n        self.op_compute_func = op_compute_func\n        self.op_count_func = op_count_func\n        self.z3_compute_func = z3_compute_func\n        self.properties = properties\n        self.weight = weight\n        self.dependencies = dependencies\n        self.is_temporary = is_temporary\n        self.recursive_used_cases = recursive_used_cases\n        self.is_recursion_enabled = is_recursion_enabled\n        self.module = module\n\n    def __repr__(self) -&gt; str:\n        \"\"\"\n        Provides a string representation of the operator information object.\n\n        Returns:\n            str: A string representation of the OperatorInfo object.\n        \"\"\"\n        return (\n            f\"OperatorInfo(id={self.id}, func_id={self.func_id}, symbol='{self.symbol}', n_ary={self.n_ary}, \"\n            f\"unary_position={self.unary_position!r}, is_base={self.is_base}, \"\n            f\"definition={self.definition!r}, definition_type={self.definition_type!r}, \"\n            f\"priority={self.priority}, \"\n            f\"associativity_direction={self.associativity_direction!r}, n_order={self.n_order}, \"\n            f\"op_compute_func={self.op_compute_func!r}, op_count_func={self.op_count_func!r}, \"\n            # f\"properties={self.properties!r}, \"\n            f\"dependencies={self.dependencies!r}, \"\n            f\"compiled_functions={'{}' if not self.compiled_functions else f'{{...}}'})\"\n        )\n\n    def to_json(self) -&gt; str:\n        \"\"\"\n        Converts the operator information object to a JSON string, excluding temporary and compiled function data.\n\n        Returns:\n            str: A JSON string representing the OperatorInfo object.\n        \"\"\"\n        serializable_dict = self.__dict__.copy()\n        # Remove attributes that should not be serialized\n        for key in [\n            \"properties\",\n            \"weight\",\n            \"z3_compute_func\",\n            \"is_temporary\",\n            \"recursive_used_cases\",\n            \"is_recursion_enabled\",\n            \"module\",\n        ]:\n            serializable_dict.pop(key, None)\n        return json.dumps(serializable_dict, ensure_ascii=False)\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"\n        Converts the operator information object to a dictionary, excluding temporary and compiled function data.\n\n        Returns:\n            dict: A dictionary representing the OperatorInfo object.\n        \"\"\"\n        serializable_dict = self.__dict__.copy()\n        # Remove attributes that should not be included in the dictionary\n        for key in [\n            \"properties\",\n            \"weight\",\n            \"z3_compute_func\",\n            \"is_temporary\",\n            \"recursive_used_cases\",\n            \"is_recursion_enabled\",\n            \"module\",\n        ]:\n            serializable_dict.pop(key, None)\n        return serializable_dict\n\n\n    @staticmethod\n    def from_json(json_str: str) -&gt; \"OperatorInfo\":\n        \"\"\"\n        Creates an OperatorInfo object from a JSON string.\n\n        Args:\n            json_str (str): A JSON string representing an OperatorInfo object.\n\n        Returns:\n            OperatorInfo: An instance of the OperatorInfo class initialized from the JSON data.\n        \"\"\"\n        data = json.loads(json_str)\n        return OperatorInfo(**data)\n\n    def get_compute_function(\n        self\n    ) -&gt; Optional[Any]:\n        \"\"\"\n        Retrieves the compute function for the operator from the compiled module.\n\n        Returns:\n            Optional[Any]: The compute function object or None if the module or function is unavailable.\n        \"\"\"\n        if self.module != None:\n            func = getattr(self.module, f\"op_{self.func_id}\", None)\n            return func\n        return None\n\n    def get_count_function(\n        self\n    ) -&gt; Optional[Any]:\n        \"\"\"\n        Retrieves the count function for the operator from the compiled module.\n\n        Returns:\n            Optional[Any]: The count function object or None if the module or function is unavailable.\n        \"\"\"\n        if self.module != None:\n            func = getattr(self.module, f\"op_{self.func_id}\", None)\n            return func\n        return None\n</code></pre>"},{"location":"operatorplus/operator_info/#opulse.operatorplus.operator_info.OperatorInfo.__init__","title":"<code>__init__(id, func_id, symbol, n_ary, unary_position, n_order, is_base, definition, definition_type, priority, associativity_direction, op_compute_func, op_count_func, z3_compute_func=None, properties=None, weight=1, dependencies=None, is_temporary=False, recursive_used_cases=0, is_recursion_enabled=True, module=None)</code>","text":"<p>Initializes the OperatorInfo object with various parameters describing the operator's properties.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>Unique identifier for the operator.</p> required <code>func_id</code> <code>str</code> <p>Function identifier for the operator.</p> required <code>symbol</code> <code>str</code> <p>Symbol representing the operator.</p> required <code>n_ary</code> <code>int</code> <p>Arity of the operator, either 1 for unary or 2 for binary.</p> required <code>unary_position</code> <code>Optional[str]</code> <p>Position for unary operators ('prefix', 'postfix', or None).</p> required <code>n_order</code> <code>int</code> <p>Order to measure complexity, especially for recursive operators.</p> required <code>is_base</code> <code>Optional[int]</code> <p>Base type identifier (e.g., 2 for binary, 10 for decimal, 16 for hexadecimal).</p> required <code>definition</code> <code>Optional[str]</code> <p>Definition of the operator (could be a string representation of the definition).</p> required <code>definition_type</code> <code>Optional[str]</code> <p>Type of definition ('simple_definition', 'recursive_definition', or 'branch_definition').</p> required <code>priority</code> <code>int</code> <p>Priority of the operator, higher means higher priority.</p> required <code>associativity_direction</code> <code>Optional[str]</code> <p>Direction of associativity ('left', 'right', or None).</p> required <code>op_compute_func</code> <code>Optional[str]</code> <p>Code string for computing the operator's result.</p> required <code>op_count_func</code> <code>Optional[str]</code> <p>Code string for counting the operations.</p> required <code>z3_compute_func</code> <code>Optional[str]</code> <p>Function code for constraint solving (still under development).</p> <code>None</code> <code>properties</code> <code>Optional[Dict[str, bool]]</code> <p>Additional properties of the operator (e.g., commutative, associative, etc.).</p> <code>None</code> <code>weight</code> <code>Optional[float]</code> <p>Probability of the operator being selected.</p> <code>1</code> <code>dependencies</code> <code>Optional[List[int]]</code> <p>List of dependencies on other operators.</p> <code>None</code> <code>is_temporary</code> <code>bool</code> <p>Whether the operator is temporary, typically used when its information is incomplete.</p> <code>False</code> <code>recursive_used_cases</code> <code>int</code> <p>Record of the recursive cases used.</p> <code>0</code> <code>is_recursion_enabled</code> <code>bool</code> <p>Whether recursion is still allowed for this operator.</p> <code>True</code> <code>module</code> <code>Optional[CDLL]</code> <p>Compiled module containing the operator's functions.</p> <code>None</code> Source code in <code>opulse/operatorplus/operator_info.py</code> <pre><code>def __init__(\n    self,\n    id: int,\n    func_id: str,\n    symbol: str,\n    n_ary: int,  # 1 for unary, 2 for binary\n    unary_position: Optional[str],  # 'prefix', 'postfix', or None\n    n_order: int,  # Order, used to measure complexity, particularly for recursive definitions\n    is_base: Optional[\n        int\n    ],  # Used to identify the base type, e.g., 2 for binary, 10 for decimal, 16 for hexadecimal\n    definition: Optional[str],\n    definition_type: Optional[\n        str\n    ],  # Types: simple_definition, recursive_definition, branch_definition\n    priority: int,  # Priority for operations with the same level, higher values represent higher priority\n    associativity_direction: Optional[str],  # 'left', 'right', or None\n\n    op_compute_func: Optional[\n        str\n    ],  # Function code for the operator, e.g., \"def op_11(a, b): ...\"\n    op_count_func: Optional[\n        str\n    ],  # Function code to calculate the count, e.g., base = 0\n    z3_compute_func: Optional[\n        str\n    ] = None,  ##TODO:Still in the process of realising, Used for constraint solving\n    properties: Optional[\n        Dict[str, bool]\n    ] = None,  # Other properties such as \"commutative\", \"associative\", \"idempotent\", etc.\n    weight: Optional[float] = 1,  # Probability of being selected\n    dependencies: Optional[\n        List[int]\n    ] = None,  # Record dependencies on other operators\n    is_temporary: bool = False,  # Whether the operator is temporary (for incomplete information)\n    recursive_used_cases: int = 0b00000000,  # Record used recursive cases\n    is_recursion_enabled: bool = True,  # Whether recursion can still be enabled based on the recursive type\n    module: Optional[ctypes.CDLL] = None\n):\n    \"\"\"\n    Initializes the OperatorInfo object with various parameters describing the operator's properties.\n\n    Parameters:\n        id (int): Unique identifier for the operator.\n        func_id (str): Function identifier for the operator.\n        symbol (str): Symbol representing the operator.\n        n_ary (int): Arity of the operator, either 1 for unary or 2 for binary.\n        unary_position (Optional[str]): Position for unary operators ('prefix', 'postfix', or None).\n        n_order (int): Order to measure complexity, especially for recursive operators.\n        is_base (Optional[int]): Base type identifier (e.g., 2 for binary, 10 for decimal, 16 for hexadecimal).\n        definition (Optional[str]): Definition of the operator (could be a string representation of the definition).\n        definition_type (Optional[str]): Type of definition ('simple_definition', 'recursive_definition', or 'branch_definition').\n        priority (int): Priority of the operator, higher means higher priority.\n        associativity_direction (Optional[str]): Direction of associativity ('left', 'right', or None).\n        op_compute_func (Optional[str]): Code string for computing the operator's result.\n        op_count_func (Optional[str]): Code string for counting the operations.\n        z3_compute_func (Optional[str]): Function code for constraint solving (still under development).\n        properties (Optional[Dict[str, bool]]): Additional properties of the operator (e.g., commutative, associative, etc.).\n        weight (Optional[float]): Probability of the operator being selected.\n        dependencies (Optional[List[int]]): List of dependencies on other operators.\n        is_temporary (bool): Whether the operator is temporary, typically used when its information is incomplete.\n        recursive_used_cases (int): Record of the recursive cases used.\n        is_recursion_enabled (bool): Whether recursion is still allowed for this operator.\n        module (Optional[ctypes.CDLL]): Compiled module containing the operator's functions.\n    \"\"\"\n    self.id = id\n    self.func_id = func_id\n    self.symbol = symbol\n    self.n_ary = n_ary\n    self.unary_position = unary_position\n    self.n_order = n_order\n    self.is_base = is_base\n    self.definition = definition\n    self.definition_type = definition_type\n    self.priority = priority\n    self.associativity_direction = associativity_direction\n\n    self.op_compute_func = op_compute_func\n    self.op_count_func = op_count_func\n    self.z3_compute_func = z3_compute_func\n    self.properties = properties\n    self.weight = weight\n    self.dependencies = dependencies\n    self.is_temporary = is_temporary\n    self.recursive_used_cases = recursive_used_cases\n    self.is_recursion_enabled = is_recursion_enabled\n    self.module = module\n</code></pre>"},{"location":"operatorplus/operator_info/#opulse.operatorplus.operator_info.OperatorInfo.__repr__","title":"<code>__repr__()</code>","text":"<p>Provides a string representation of the operator information object.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A string representation of the OperatorInfo object.</p> Source code in <code>opulse/operatorplus/operator_info.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"\n    Provides a string representation of the operator information object.\n\n    Returns:\n        str: A string representation of the OperatorInfo object.\n    \"\"\"\n    return (\n        f\"OperatorInfo(id={self.id}, func_id={self.func_id}, symbol='{self.symbol}', n_ary={self.n_ary}, \"\n        f\"unary_position={self.unary_position!r}, is_base={self.is_base}, \"\n        f\"definition={self.definition!r}, definition_type={self.definition_type!r}, \"\n        f\"priority={self.priority}, \"\n        f\"associativity_direction={self.associativity_direction!r}, n_order={self.n_order}, \"\n        f\"op_compute_func={self.op_compute_func!r}, op_count_func={self.op_count_func!r}, \"\n        # f\"properties={self.properties!r}, \"\n        f\"dependencies={self.dependencies!r}, \"\n        f\"compiled_functions={'{}' if not self.compiled_functions else f'{{...}}'})\"\n    )\n</code></pre>"},{"location":"operatorplus/operator_info/#opulse.operatorplus.operator_info.OperatorInfo.from_json","title":"<code>from_json(json_str)</code>  <code>staticmethod</code>","text":"<p>Creates an OperatorInfo object from a JSON string.</p> <p>Parameters:</p> Name Type Description Default <code>json_str</code> <code>str</code> <p>A JSON string representing an OperatorInfo object.</p> required <p>Returns:</p> Name Type Description <code>OperatorInfo</code> <code>OperatorInfo</code> <p>An instance of the OperatorInfo class initialized from the JSON data.</p> Source code in <code>opulse/operatorplus/operator_info.py</code> <pre><code>@staticmethod\ndef from_json(json_str: str) -&gt; \"OperatorInfo\":\n    \"\"\"\n    Creates an OperatorInfo object from a JSON string.\n\n    Args:\n        json_str (str): A JSON string representing an OperatorInfo object.\n\n    Returns:\n        OperatorInfo: An instance of the OperatorInfo class initialized from the JSON data.\n    \"\"\"\n    data = json.loads(json_str)\n    return OperatorInfo(**data)\n</code></pre>"},{"location":"operatorplus/operator_info/#opulse.operatorplus.operator_info.OperatorInfo.get_compute_function","title":"<code>get_compute_function()</code>","text":"<p>Retrieves the compute function for the operator from the compiled module.</p> <p>Returns:</p> Type Description <code>Optional[Any]</code> <p>Optional[Any]: The compute function object or None if the module or function is unavailable.</p> Source code in <code>opulse/operatorplus/operator_info.py</code> <pre><code>def get_compute_function(\n    self\n) -&gt; Optional[Any]:\n    \"\"\"\n    Retrieves the compute function for the operator from the compiled module.\n\n    Returns:\n        Optional[Any]: The compute function object or None if the module or function is unavailable.\n    \"\"\"\n    if self.module != None:\n        func = getattr(self.module, f\"op_{self.func_id}\", None)\n        return func\n    return None\n</code></pre>"},{"location":"operatorplus/operator_info/#opulse.operatorplus.operator_info.OperatorInfo.get_count_function","title":"<code>get_count_function()</code>","text":"<p>Retrieves the count function for the operator from the compiled module.</p> <p>Returns:</p> Type Description <code>Optional[Any]</code> <p>Optional[Any]: The count function object or None if the module or function is unavailable.</p> Source code in <code>opulse/operatorplus/operator_info.py</code> <pre><code>def get_count_function(\n    self\n) -&gt; Optional[Any]:\n    \"\"\"\n    Retrieves the count function for the operator from the compiled module.\n\n    Returns:\n        Optional[Any]: The count function object or None if the module or function is unavailable.\n    \"\"\"\n    if self.module != None:\n        func = getattr(self.module, f\"op_{self.func_id}\", None)\n        return func\n    return None\n</code></pre>"},{"location":"operatorplus/operator_info/#opulse.operatorplus.operator_info.OperatorInfo.to_dict","title":"<code>to_dict()</code>","text":"<p>Converts the operator information object to a dictionary, excluding temporary and compiled function data.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary representing the OperatorInfo object.</p> Source code in <code>opulse/operatorplus/operator_info.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"\n    Converts the operator information object to a dictionary, excluding temporary and compiled function data.\n\n    Returns:\n        dict: A dictionary representing the OperatorInfo object.\n    \"\"\"\n    serializable_dict = self.__dict__.copy()\n    # Remove attributes that should not be included in the dictionary\n    for key in [\n        \"properties\",\n        \"weight\",\n        \"z3_compute_func\",\n        \"is_temporary\",\n        \"recursive_used_cases\",\n        \"is_recursion_enabled\",\n        \"module\",\n    ]:\n        serializable_dict.pop(key, None)\n    return serializable_dict\n</code></pre>"},{"location":"operatorplus/operator_info/#opulse.operatorplus.operator_info.OperatorInfo.to_json","title":"<code>to_json()</code>","text":"<p>Converts the operator information object to a JSON string, excluding temporary and compiled function data.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A JSON string representing the OperatorInfo object.</p> Source code in <code>opulse/operatorplus/operator_info.py</code> <pre><code>def to_json(self) -&gt; str:\n    \"\"\"\n    Converts the operator information object to a JSON string, excluding temporary and compiled function data.\n\n    Returns:\n        str: A JSON string representing the OperatorInfo object.\n    \"\"\"\n    serializable_dict = self.__dict__.copy()\n    # Remove attributes that should not be serialized\n    for key in [\n        \"properties\",\n        \"weight\",\n        \"z3_compute_func\",\n        \"is_temporary\",\n        \"recursive_used_cases\",\n        \"is_recursion_enabled\",\n        \"module\",\n    ]:\n        serializable_dict.pop(key, None)\n    return json.dumps(serializable_dict, ensure_ascii=False)\n</code></pre>"},{"location":"operatorplus/operator_manager/","title":"OperatorManager.md","text":""},{"location":"operatorplus/operator_manager/#opulse.operatorplus.operator_manager.OperatorManager","title":"<code>OperatorManager</code>","text":"Source code in <code>opulse/operatorplus/operator_manager.py</code> <pre><code>class OperatorManager:\n    def __init__(self, config_file: str, param_config: ParamConfig, logger: LogConfig, cython_cache_dir: str, compiler: CythonCompiler, load_compile: True):\n        \"\"\"\n        Initializes the OperatorManager with configuration details and sets up internal data structures.\n\n        Parameters:\n            config_file (str): Path to the JSONL file containing operator definitions.\n            param_config (ParamConfig): Configuration object containing necessary settings.\n            logger (LogConfig): Logger configuration object for logging.\n            cython_cache_dir (str): Directory to store compiled Cython modules.\n            compiler (CythonCompiler): Compiler object for compiling operator functions.\n            load_compile (bool): Whether to compile operators during loading.\n        \"\"\"\n\n        self.config_file = config_file\n        self.param_config = param_config\n        self.logger = logger.get_logger()\n        self.compiler = compiler\n        self.operators: Dict[str, OperatorInfo] = (\n            {}\n        )  # key: operator id, value: OperatorInfo\n        self.symbol_to_operators: Dict[str, List[OperatorInfo]] = defaultdict(\n            list\n        )  # key: operator symbol, value: list of OperatorInfo\n        self.base_operators: Dict[int, List[OperatorInfo]] = defaultdict(list)\n        # key: is_base, value: list of OperatorInfo\n\n        # self.available_funcs: Dict[str, Any] = {}  # to store available functions\n        # self.available_funcs_str = f\"thres = {2**31 - 1}\\n\\n\"\n        # self.max_workers = max_workers\n        self.load_compile = load_compile\n        self.cython_cache_dir = cython_cache_dir\n        self.load_operators()\n\n    def load_operators(self):\n        \"\"\"\n        Loads operator definitions from a JSONL file.\n\n        This method reads the configuration file line by line, parses each line into an\n        `OperatorInfo` object, and stores the operators in various structures:\n        - `self.operators`: A dictionary with operator ID as the key and `OperatorInfo` as the value.\n        - `self.symbol_to_operators`: A dictionary with operator symbol as the key and a list of `OperatorInfo` as the value.\n        - `self.base_operators`: A dictionary to store base operators based on their base status.\n\n        Additionally, it updates the available functions for computation and counting based on the loaded operators.\n\n        Logs relevant information about the loading process for monitoring and debugging purposes.\n        \"\"\"\n        self.logger.info(\n            f\"Loading operators from configuration file: {self.config_file}\"\n        )\n\n        with open(self.config_file, \"r\", encoding=\"utf-8\") as f:\n            line_count = 0\n            for line in f:\n                line_count += 1\n                if not line.strip():\n                    self.logger.debug(f\"Skipping empty line {line_count}.\")\n                    continue  # Skip empty lines\n                try:\n                    operator = OperatorInfo.from_json(line)\n                    if self.load_compile:\n                        so_file = f\"module_{operator.func_id}.cpython-310-x86_64-linux-gnu.so\"\n                        full_path = os.path.join(self.cython_cache_dir, so_file)\n                        if os.path.exists(full_path):\n                            operator.module = self.compiler.import_module_from_path(f\"module_{operator.func_id}\")\n                        else:    \n                            func_code_str = f\"thres = {2**31 - 1}\\n\\n\"#Add the value and limit of the thres variable.\n                            func_code_str += f\"# Operator Func ID: {operator.func_id} - op_compute_func\\n\"\n                            func_code_str += f\"{operator.op_compute_func}\\n\\n\"\n                            func_code_str += f\"# Operator Func ID: {operator.func_id} - op_count_func\\n\"\n                            func_code_str += f\"{operator.op_count_func}\\n\\n\"\n                            self.compiler.compile_function(func_code_str, operator.func_id, deps = None) \n                            operator.module = self.compiler.import_module_from_path(f\"module_{operator.func_id}\")\n\n                    self.operators[operator.func_id] = operator\n                    self.symbol_to_operators[operator.symbol].append(operator)\n\n                    # Update available functions for the operator\n                    if operator.is_base:\n                        self.base_operators[operator.is_base].append(operator)\n\n                    # self._update_available_funcs(operator)\n                    self.logger.info(\n                        f\"Loaded operator {operator.id} ({operator.symbol}) from line {line_count}.\"\n                    )\n\n                except Exception as e:\n                    self.logger.warning(\n                        f\"Failed to parse operator from line {line_count}: {e}\"\n                    )\n        # self.save_op_funcs_to_file()   \n        self.logger.info(\n            f\"Successfully loaded {len(self.operators)} operators from the configuration file.\"\n        )\n\n    def save_op_funcs_to_file(self, file_path:str):\n        \"\"\"\n        Saves all operator functions to a `.pyx` file for compilation.\n\n        This method writes the compute and count functions of all operators to a `.pyx` file,\n        ensuring that they can be compiled later.\n        \"\"\"\n        with open(file_path, \"w\") as file:\n            # Write the necessary imports and initializations at the start of the file\n            file.write(f\"thres = {2**31 - 1}\\n\\n\")\n\n            # Now, write the operator functions\n            for op_func_id, operator_info in self.operators.items():\n                # Ensure both op_compute_func and op_count_func exist\n                if hasattr(operator_info, 'op_compute_func') and hasattr(operator_info, 'op_count_func'):\n                    # Write the op_compute_func (as string)\n                    op_compute_func_str = operator_info.op_compute_func\n                    file.write(f\"# Operator ID: {op_func_id} - op_compute_func\\n\")\n                    file.write(f\"{op_compute_func_str}\\n\\n\")\n\n                    # Write the op_count_func (as string)\n                    op_count_func_str = operator_info.op_count_func\n                    file.write(f\"# Operator ID: {op_func_id} - op_count_func\\n\")\n                    file.write(f\"{op_count_func_str}\\n\\n\")\n                else:\n                    self.logger.warning(f\"Operator ID {op_func_id} does not have a valid op_compute_func or op_count_func.\")\n\n    def save_operators_to_jsonl(self, file_path: str):\n        \"\"\"\n        Saves all operators to a JSONL file.\n\n        This method serializes each operator in `self.operators` and writes it to the specified file path in JSONL format.\n\n        Parameters:\n            file_path (str): The path to the file where the operators should be saved.\n\n        Logs the process of saving operators to the file.\n        \"\"\"\n        self.logger.info(f\"Saving operators to {file_path}.\")\n\n        with open(file_path, \"w\", encoding=\"utf-8\") as file:\n            for operator in self.operators.values():\n                json_line = operator.to_json()\n                file.write(json_line + \"\\n\")\n                file.flush()  \n                self.logger.debug(\n                    f\"Saved operator {operator.id} ({operator.symbol}) to {file_path}.\"\n                )\n\n        self.logger.info(f\"Successfully saved all operators to {file_path}.\")\n\n\n    def get_operator_by_func_id(self, op_func_id: str) -&gt; OperatorInfo:\n        \"\"\"\n        Retrieves an operator by its function ID.\n\n        Parameters:\n            op_func_id (str): The function ID of the operator.\n\n        Returns:\n            OperatorInfo: The operator corresponding to the given function ID.\n\n        Raises:\n            ValueError: If no operator with the given function ID exists.\n        \"\"\"\n        self.logger.debug(f\"Fetching operator with func ID {op_func_id}.\")\n\n        if op_func_id not in self.operators:\n            self.logger.error(f\"Operator ID {op_func_id} does not exist.\")\n            raise ValueError(f\"Operator ID {op_func_id} does not exist.\")\n\n        self.logger.debug(f\"Operator ID {op_func_id} found.\")\n        return self.operators[op_func_id]\n\n    def get_operators_by_symbol(self, symbol: str) -&gt; List[OperatorInfo]:\n        \"\"\"\n        Retrieves all operators corresponding to a given symbol.\n\n        Args:\n            symbol (str): The operator symbol.\n\n        Returns:\n            List[OperatorInfo]: A list of operators corresponding to the symbol.\n        \"\"\"\n        self.logger.debug(f\"Fetching operators with symbol '{symbol}'.\")\n\n        operators = self.symbol_to_operators.get(symbol, [])\n\n        self.logger.debug(f\"Found {len(operators)} operators for symbol '{symbol}'.\")\n        return operators\n\n    def get_operator_symbols(self) -&gt; List[str]:\n        \"\"\"\n        Retrieves a list of all operator symbols.\n\n        Returns:\n            List[str]: A list of operator symbols.\n        \"\"\"\n        self.logger.debug(\"Fetching all operator symbols.\")\n\n        symbols = list(self.symbol_to_operators.keys())\n\n        self.logger.debug(f\"Found {len(symbols)} operator symbols.\")\n        return symbols\n\n    def get_operator_function_id(\n        self, operator_symbol: str, is_unary: bool, unary_position: str\n    ) -&gt; Optional[tuple[int, bool]]:\n        \"\"\"\n        Retrieves the function ID and temporary status of an operator based on its symbol and type (unary or binary).\n\n        Args:\n            operator_symbol (str): The operator symbol.\n            is_unary (bool): A boolean indicating whether the operator is unary (True) or binary (False).\n\n        Returns:\n            Optional[tuple[int, bool]]: A tuple containing the operator's function ID and its temporary status.\n                                        If no matching operator is found, returns (None, False).\n        \"\"\"\n        self.logger.debug(\n            f\"Fetching function ID for operator symbol '{operator_symbol}' and type {'unary' if is_unary else 'binary'}.\"\n        )\n\n        for operator in self.symbol_to_operators.get(operator_symbol, []):\n            if (is_unary and operator.n_ary == 1 and operator.unary_position == unary_position) or (\n                not is_unary and operator.n_ary == 2\n            ):\n                self.logger.debug(\n                    f\"Found operator {operator.id} ({operator.symbol}) matching the criteria.\"\n                )\n                return operator.func_id, operator.is_temporary\n\n        self.logger.debug(\n            f\"No matching operator found for symbol '{operator_symbol}' and type {'unary' if is_unary else 'binary'}.\"\n        )\n        return None, False\n\n    def get_operator_by_base(self, base: int) -&gt; OperatorInfo:\n        \"\"\"\n        Retrieves an operator based on the given base (number system).\n\n        Args:\n            base (int): The base (e.g., 2 for binary, 10 for decimal, etc.).\n\n        Returns:\n            OperatorInfo: The operator corresponding to the given base.\n\n        Raises:\n            ValueError: If no operators are available for the given base.\n        \"\"\"\n        self.logger.debug(f\"Fetching operator for base {base}.\")\n\n        if base not in self.base_operators:\n            self.logger.error(f\"Base type {base} does not exist.\")\n            raise ValueError(f\"Base type {base} does not exist.\")\n\n        self.logger.debug(f\"Found operator(s) for base {base}.\")\n        return self.base_operators[base]\n\n    def get_unary_and_binary_operators(\n        self,\n    ) -&gt; Tuple[List[OperatorInfo], List[OperatorInfo], List[OperatorInfo]]:\n        \"\"\"\n        Retrieves the lists of unary prefix operators, unary postfix operators, and binary operators.\n\n        This method categorizes the operators into three types:\n        - Unary prefix operators: Operators that appear before their operands.\n        - Unary postfix operators: Operators that appear after their operands.\n        - Binary operators: Operators that take two operands.\n\n        Returns:\n            Tuple[List[OperatorInfo], List[OperatorInfo], List[OperatorInfo]]:\n            A tuple containing three lists:\n            1. List of unary prefix operators\n            2. List of unary postfix operators\n            3. List of binary operators\n        \"\"\"\n        self.logger.debug(\"Fetching unary and binary operators.\")\n\n        # Get unary prefix operators\n        unary_prefix_ops = [\n            op\n            for op in self.operators.values()\n            if op.n_ary == 1 and op.unary_position == \"prefix\"\n        ]\n\n        self.logger.debug(f\"Found {len(unary_prefix_ops)} unary prefix operators.\")\n\n        # Get unary postfix operators\n        unary_postfix_ops = [\n            op\n            for op in self.operators.values()\n            if op.n_ary == 1 and op.unary_position == \"postfix\"\n        ]\n\n        self.logger.debug(f\"Found {len(unary_postfix_ops)} unary postfix operators.\")\n\n        # Get binary operators\n        binary_ops = [op for op in self.operators.values() if op.n_ary == 2]\n\n        self.logger.debug(f\"Found {len(binary_ops)} binary operators.\")\n\n        return unary_prefix_ops, unary_postfix_ops, binary_ops\n\n    def get_operators_by_priority(self) -&gt; List[OperatorInfo]:\n        \"\"\"\n        Sorts and returns operators based on their priority.\n\n        This method sorts all operators by their priority, where operators with lower priority come first.\n\n        Returns:\n            List[OperatorInfo]: A list of operators sorted by priority.\n        \"\"\"\n        self.logger.debug(\"Sorting operators by priority.\")\n\n        # Sort operators by priority in ascending order (lower priority first)\n        sorted_operators = sorted(\n            self.operators.values(), key=lambda op: op.priority, reverse=False\n        )\n\n        self.logger.debug(f\"Sorted {len(sorted_operators)} operators by priority.\")\n\n        return sorted_operators\n\n    def extract_op_dependencies(self, operator:OperatorInfo):\n        \"\"\"\n        Extracts dependencies of a given operator by analyzing its compute function.\n\n        This method uses a regular expression to match operator IDs in the `op_compute_func`\n        field of the operator and identifies any dependencies (operators that the current\n        operator relies on).\n\n        Parameters:\n            operator (OperatorInfo): The operator whose dependencies need to be extracted.\n\n        Updates:\n            - The `dependencies` attribute of the operator is updated to a list of dependent operator IDs.\n        \"\"\"\n        # Regular expression pattern to match operator dependencies (e.g., op_1, op_2, etc.)\n        op_pattern = r\"op_(\\w+)\\(\"\n\n        # Use re.findall to extract all matching operator IDs from the function\n        op_strs = re.findall(op_pattern, operator.op_compute_func)\n\n        # Convert matched strings and remove duplicates\n        op_strs = list(set(op_strs)) \n\n        # If the operator itself is in the list of dependencies, remove it\n        if operator.func_id in op_strs:\n            op_strs.remove(operator.func_id)\n\n        # Update operator dependencies\n        operator.dependencies = op_strs\n\n    def calculate_order(self, operator:OperatorInfo):\n        \"\"\"\n        Calculates the order (n_order) of a specific operator based on its dependencies.\n\n        Parameters:\n            operator (OperatorInfo): The operator whose order needs to be calculated.\n\n        Updates:\n            - The `n_order` attribute of the operator is updated based on its dependencies.\n        \"\"\"\n        # If the operator has dependencies, calculate its order based on them\n        if operator.dependencies:\n            # Get the n_order values of all dependencies\n            dependency_orders = [\n                self.operators[dep_id].n_order for dep_id in operator.dependencies\n            ]\n            self.logger.debug(\n                f\"Dependency orders for operator {operator.func_id}: {dependency_orders}.\"\n            )\n\n            if operator.definition_type == \"recursive_definition\":\n                # For recursive definitions, the order is the max order of dependencies + 1\n                operator.n_order = max(dependency_orders) + 1\n                self.logger.debug(\n                    f\"Operator {operator.func_id} is recursive; setting n_order to {operator.n_order}.\"\n                )\n            else:\n                # For non-recursive definitions, the order is the max order of dependencies\n                operator.n_order = max(dependency_orders)\n                self.logger.debug(\n                    f\"Operator {operator.func_id} is non-recursive; setting n_order to {operator.n_order}.\"\n                )\n        else:\n            # If the operator has no dependencies, set its order to 1\n            operator.n_order = 1\n            self.logger.debug(\n                f\"Operator {operator.func_id} has no dependencies; setting n_order to 1.\"\n            )\n        # operator_info.weight = exponential_decay(operator_info.n_order)\n        # Log the final n_order value for the operator\n        self.logger.info(\n            f\"Operator {operator.symbol} (ID: {operator.func_id}) has n_order: {operator.n_order}.\"\n        )\n\n    def update_operator_temporary_status(\n        self, op_func_id: str, new_status: bool\n    ) -&gt; bool:\n        \"\"\"\n        Updates the 'is_temporary' status of the specified operator.\n\n        This function looks for an operator by its ID and sets its 'is_temporary' status\n        to the provided new status.\n\n        Parameters:\n            op_func_id (int): The ID of the operator to update.\n            new_status (bool): The new 'is_temporary' status to set for the operator.\n\n        Returns:\n            bool: Returns True if the update was successful, otherwise returns False if the operator was not found.\n        \"\"\"\n        self.logger.debug(\n            f\"Attempting to update 'is_temporary' status for operator ID {op_func_id} to {new_status}.\"\n        )\n\n        # Loop through all operators to find the one with the specified ID\n        for operators in self.symbol_to_operators.values():\n            for operator in operators:\n                if operator.func_id == op_func_id:\n                    # Found the operator, updating its is_temporary status\n                    operator.is_temporary = new_status\n                    self.logger.info(\n                        f\"Operator {op_func_id}: 'is_temporary' status successfully updated to {new_status}.\"\n                    )\n                    return True  # Update successful\n\n        # If the operator ID was not found, log an error and return False\n        self.logger.error(f\"Operator with ID {op_func_id} not found. Update failed.\")\n        return False  # Operator not found\n\n    def add_operator(self, operator: OperatorInfo):\n        \"\"\"\n        Dynamically adds a new operator to the system.\n\n        Parameters:\n            operator (OperatorInfo): The operator to be added.\n\n        Raises:\n            ValueError: If an operator with the same function ID already exists.\n        \"\"\"\n\n        if operator.func_id in self.operators:\n            self.logger.error(f\"Operator ID {operator.func_id} already exists.\")\n            raise ValueError(f\"Operator ID {operator.func_id} already exists.\")\n\n\n        # Add the operator to the operators dictionary\n        self.operators[operator.func_id] = operator\n\n        # Map the operator to its symbol in the symbol_to_operators dictionary\n        if operator.symbol not in self.symbol_to_operators:\n            self.symbol_to_operators[operator.symbol] = []\n        self.symbol_to_operators[operator.symbol].append(operator)\n        self.logger.debug(\n            f\"Operator {operator.symbol} (ID: {operator.func_id}) added to symbol_to_operators.\"\n        )\n\n        # Add the operator to the base_operators dictionary based on its base type\n        if operator.is_base is not None:\n            if operator.is_base not in self.base_operators:\n                self.base_operators[operator.is_base] = []\n            self.base_operators[operator.is_base].append(operator)\n            self.logger.debug(\n                f\"Operator {operator.symbol} (ID: {operator.func_id}) added to base_operators.\"\n            )\n\n\n    def remove_operator(self, op_func_id: str):\n        \"\"\"\n        Dynamically removes an operator from the system.\n\n        This method removes an operator by its ID, updating the internal storage\n        (both `self.operators` and `self.symbol_to_operators`) accordingly.\n\n        Parameters:\n            op_func_id (int): The ID of the operator to be removed.\n\n        Raises:\n            ValueError: If the operator ID does not exist in the system.\n        \"\"\"\n        self.logger.debug(\"Attempting to remove operator with ID: %s\", op_func_id)\n\n        if op_func_id not in self.operators:\n            self.logger.error(f\"Operator ID {op_func_id} does not exist.\")\n            raise ValueError(f\"Operator ID {op_func_id} does not exist.\")\n\n        # Retrieve and remove the operator from the operators dictionary\n        operator = self.operators.pop(op_func_id)\n        self.logger.info(f\"Removed operator {operator.symbol} (ID: {op_func_id}).\")\n\n        # Remove the operator from the symbol_to_operators mapping\n        if operator.symbol in self.symbol_to_operators:\n            self.symbol_to_operators[operator.symbol].remove(operator)\n            self.logger.debug(\n                f\"Operator {operator.symbol} (ID: {op_func_id}) removed from symbol_to_operators.\"\n            )\n\n    def update_operator(self, op_func_id: str, updated_data: Dict[str, Any]):\n        \"\"\"\n        Dynamically updates an existing operator in the system.\n\n        This method replaces the operator with the given ID (`op_id`) using the data\n        in `updated_data`. It performs the necessary checks and ensures that all required fields\n        are provided before updating the operator in the internal storage.\n\n        Parameters:\n            op_func_id (int): The ID of the operator to be updated.\n            updated_data (dict): A dictionary containing the updated data for the operator.\n\n        Raises:\n            ValueError: If the operator ID does not exist or required fields are missing.\n        \"\"\"\n        self.logger.debug(\"Attempting to update operator with ID: %s\", op_func_id)\n\n        # Check if the operator exists\n        if op_func_id not in self.operators:\n            self.logger.error(f\"Operator ID {op_func_id} does not exist.\")\n            raise ValueError(f\"Operator ID {op_func_id} does not exist.\")\n\n        # Ensure the 'id' in updated_data matches the op_id\n        updated_data[\"func_id\"] = op_func_id\n\n        # Ensure 'compute_func' is provided in the updated data\n        if \"compute_func\" not in updated_data or not updated_data[\"compute_func\"]:\n            self.logger.error(\"compute_func must be provided.\")\n            raise ValueError(\"compute_func must be provided.\")\n\n        # Set 'n_order' to None, letting calculate_order handle it later\n        updated_data[\"n_order\"] = None\n\n        # Remove the old operator\n        old_operator = self.operators.pop(op_func_id)\n        self.symbol_to_operators[old_operator.symbol].remove(old_operator)\n        self.logger.info(f\"Removed old operator {old_operator.symbol} (ID: {op_func_id}).\")\n\n        # Add the updated operator\n        updated_operator = OperatorInfo(**updated_data)\n        self.operators[updated_operator.id] = updated_operator\n        self.symbol_to_operators[updated_operator.symbol].append(updated_operator)\n        self.logger.info(f\"Updated operator {updated_operator.symbol} (ID: {op_func_id}).\")\n\n        # Recalculate order after the update\n        self.calculate_order()\n        self.logger.debug(f\"Recalculated order for operator ID: {op_func_id}.\")\n\n    def delete_one_operator(self, op_func_id: str) -&gt; None:\n        \"\"\"\n        Delete an operator and recursively remove dependent operators.\n        Afterward, reassign IDs for the remaining operators.\n\n        Parameters:\n            op_func_id (int): The ID of the operator to be deleted.\n        \"\"\"\n        self.logger.debug(\"Attempting to delete operator with ID: %s\", op_func_id)\n\n        # Recursively delete the operator and its dependencies\n        self.delete_one_operator_by_dep(op_func_id)\n\n        # Reassign operator IDs after deletion\n        sorted_keys = sorted(self.operators.keys())\n        op_pattern = r\"def op_(\\s+)\"\n        op_count_pattern = r\"def op_count_(\\s+)\"\n\n        for i, old_key in enumerate(sorted_keys, start=1):\n            if old_key != i:\n                self.operators[i] = self.operators[old_key]\n                # Update the ID of the operator\n                self.operators[i].id = i\n                # Update the operator's function string\n                self.operators[i].op_compute_func = re.sub(\n                    op_pattern,\n                    lambda m: f\"def op_{i}\",\n                    self.operators[i].op_compute_func,\n                    count=1,\n                )\n                self.operators[i].op_count_func = re.sub(\n                    op_count_pattern,\n                    lambda m: f\"def op_count_{i}\",\n                    self.operators[i].op_count_func,\n                    count=1,\n                )\n                for operator in self.operators.values():\n                    if old_key in operator.dependencies:\n                        # Replace old_key with i in dependencies\n                        operator.dependencies = [\n                            i if dep == old_key else dep\n                            for dep in operator.dependencies\n                        ]\n                        # Also, update the operator's compute functions to reflect the new op_id\n                        operator.op_compute_func = re.sub(\n                            rf\"op_{old_key}\",\n                            lambda m: f\"op_{i}\",\n                            operator.op_compute_func,\n                        )\n                        operator.op_count_func = re.sub(\n                            rf\"op_count_{old_key}\",\n                            lambda m: f\"op_count_{i}\",\n                            operator.op_count_func,\n                        )\n                del self.operators[old_key]\n\n        self.logger.info(\n            \"Operator with ID %s and its dependencies removed. Operator IDs reassigned.\",\n            op_func_id)\n\n    def delete_one_operator_by_dep(self, op_func_id: str) -&gt; None:\n        \"\"\"\n        Recursively delete an operator and its dependencies.\n\n        Parameters:\n            op_func_id (int): The ID of the operator to be deleted.\n\n        Raises:\n            ValueError: If the operator with the given ID does not exist.\n        \"\"\"\n        self.logger.debug(\n            \"Attempting to recursively delete operator with ID: %s\", op_func_id\n        )\n\n        # Check if the operator exists\n        if op_func_id not in self.operators:\n            self.logger.error(f\"Operator ID {op_func_id} does not exist.\")\n            raise ValueError(f\"Operator ID {op_func_id} does not exist.\")\n\n        # Set to keep track of operators that need to be deleted\n        to_delete_ids = set()\n\n        # Recursively find all operators that depend on the given operator\n        self._find_all_dependent_operator_ids(op_func_id, to_delete_ids)\n\n        # Remove the operators\n        for op_id_to_delete in to_delete_ids:\n            self.remove_operator(op_id_to_delete)\n\n        self.logger.debug(\n            \"Completed recursive deletion for operator ID: %s and its dependencies.\",\n            op_func_id,\n        )\n\n    def _find_all_dependent_operator_ids(self, op_func_id: str, to_delete_ids: set) -&gt; None:\n        \"\"\"\n        Helper function to recursively find all dependent operators that should be deleted.\n\n        Parameters:\n            op_func_id (int): The ID of the operator whose dependencies should be found.\n            to_delete_ids (set): A set that stores all operator IDs that should be deleted.\n        \"\"\"\n        # If this operator has already been marked for deletion, return early\n        if op_func_id in to_delete_ids:\n            return\n\n        # Mark this operator for deletion\n        to_delete_ids.add(op_func_id)\n\n        # Recursively find operators that depend on the current operator\n        for operator in self.operators.values():\n            if op_func_id in operator.dependencies:\n                self._find_all_dependent_operator_ids(operator.func_id, to_delete_ids)\n</code></pre>"},{"location":"operatorplus/operator_manager/#opulse.operatorplus.operator_manager.OperatorManager.__init__","title":"<code>__init__(config_file, param_config, logger, cython_cache_dir, compiler, load_compile)</code>","text":"<p>Initializes the OperatorManager with configuration details and sets up internal data structures.</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str</code> <p>Path to the JSONL file containing operator definitions.</p> required <code>param_config</code> <code>ParamConfig</code> <p>Configuration object containing necessary settings.</p> required <code>logger</code> <code>LogConfig</code> <p>Logger configuration object for logging.</p> required <code>cython_cache_dir</code> <code>str</code> <p>Directory to store compiled Cython modules.</p> required <code>compiler</code> <code>CythonCompiler</code> <p>Compiler object for compiling operator functions.</p> required <code>load_compile</code> <code>bool</code> <p>Whether to compile operators during loading.</p> required Source code in <code>opulse/operatorplus/operator_manager.py</code> <pre><code>def __init__(self, config_file: str, param_config: ParamConfig, logger: LogConfig, cython_cache_dir: str, compiler: CythonCompiler, load_compile: True):\n    \"\"\"\n    Initializes the OperatorManager with configuration details and sets up internal data structures.\n\n    Parameters:\n        config_file (str): Path to the JSONL file containing operator definitions.\n        param_config (ParamConfig): Configuration object containing necessary settings.\n        logger (LogConfig): Logger configuration object for logging.\n        cython_cache_dir (str): Directory to store compiled Cython modules.\n        compiler (CythonCompiler): Compiler object for compiling operator functions.\n        load_compile (bool): Whether to compile operators during loading.\n    \"\"\"\n\n    self.config_file = config_file\n    self.param_config = param_config\n    self.logger = logger.get_logger()\n    self.compiler = compiler\n    self.operators: Dict[str, OperatorInfo] = (\n        {}\n    )  # key: operator id, value: OperatorInfo\n    self.symbol_to_operators: Dict[str, List[OperatorInfo]] = defaultdict(\n        list\n    )  # key: operator symbol, value: list of OperatorInfo\n    self.base_operators: Dict[int, List[OperatorInfo]] = defaultdict(list)\n    # key: is_base, value: list of OperatorInfo\n\n    # self.available_funcs: Dict[str, Any] = {}  # to store available functions\n    # self.available_funcs_str = f\"thres = {2**31 - 1}\\n\\n\"\n    # self.max_workers = max_workers\n    self.load_compile = load_compile\n    self.cython_cache_dir = cython_cache_dir\n    self.load_operators()\n</code></pre>"},{"location":"operatorplus/operator_manager/#opulse.operatorplus.operator_manager.OperatorManager.add_operator","title":"<code>add_operator(operator)</code>","text":"<p>Dynamically adds a new operator to the system.</p> <p>Parameters:</p> Name Type Description Default <code>operator</code> <code>OperatorInfo</code> <p>The operator to be added.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If an operator with the same function ID already exists.</p> Source code in <code>opulse/operatorplus/operator_manager.py</code> <pre><code>def add_operator(self, operator: OperatorInfo):\n    \"\"\"\n    Dynamically adds a new operator to the system.\n\n    Parameters:\n        operator (OperatorInfo): The operator to be added.\n\n    Raises:\n        ValueError: If an operator with the same function ID already exists.\n    \"\"\"\n\n    if operator.func_id in self.operators:\n        self.logger.error(f\"Operator ID {operator.func_id} already exists.\")\n        raise ValueError(f\"Operator ID {operator.func_id} already exists.\")\n\n\n    # Add the operator to the operators dictionary\n    self.operators[operator.func_id] = operator\n\n    # Map the operator to its symbol in the symbol_to_operators dictionary\n    if operator.symbol not in self.symbol_to_operators:\n        self.symbol_to_operators[operator.symbol] = []\n    self.symbol_to_operators[operator.symbol].append(operator)\n    self.logger.debug(\n        f\"Operator {operator.symbol} (ID: {operator.func_id}) added to symbol_to_operators.\"\n    )\n\n    # Add the operator to the base_operators dictionary based on its base type\n    if operator.is_base is not None:\n        if operator.is_base not in self.base_operators:\n            self.base_operators[operator.is_base] = []\n        self.base_operators[operator.is_base].append(operator)\n        self.logger.debug(\n            f\"Operator {operator.symbol} (ID: {operator.func_id}) added to base_operators.\"\n        )\n</code></pre>"},{"location":"operatorplus/operator_manager/#opulse.operatorplus.operator_manager.OperatorManager.calculate_order","title":"<code>calculate_order(operator)</code>","text":"<p>Calculates the order (n_order) of a specific operator based on its dependencies.</p> <p>Parameters:</p> Name Type Description Default <code>operator</code> <code>OperatorInfo</code> <p>The operator whose order needs to be calculated.</p> required Updates <ul> <li>The <code>n_order</code> attribute of the operator is updated based on its dependencies.</li> </ul> Source code in <code>opulse/operatorplus/operator_manager.py</code> <pre><code>def calculate_order(self, operator:OperatorInfo):\n    \"\"\"\n    Calculates the order (n_order) of a specific operator based on its dependencies.\n\n    Parameters:\n        operator (OperatorInfo): The operator whose order needs to be calculated.\n\n    Updates:\n        - The `n_order` attribute of the operator is updated based on its dependencies.\n    \"\"\"\n    # If the operator has dependencies, calculate its order based on them\n    if operator.dependencies:\n        # Get the n_order values of all dependencies\n        dependency_orders = [\n            self.operators[dep_id].n_order for dep_id in operator.dependencies\n        ]\n        self.logger.debug(\n            f\"Dependency orders for operator {operator.func_id}: {dependency_orders}.\"\n        )\n\n        if operator.definition_type == \"recursive_definition\":\n            # For recursive definitions, the order is the max order of dependencies + 1\n            operator.n_order = max(dependency_orders) + 1\n            self.logger.debug(\n                f\"Operator {operator.func_id} is recursive; setting n_order to {operator.n_order}.\"\n            )\n        else:\n            # For non-recursive definitions, the order is the max order of dependencies\n            operator.n_order = max(dependency_orders)\n            self.logger.debug(\n                f\"Operator {operator.func_id} is non-recursive; setting n_order to {operator.n_order}.\"\n            )\n    else:\n        # If the operator has no dependencies, set its order to 1\n        operator.n_order = 1\n        self.logger.debug(\n            f\"Operator {operator.func_id} has no dependencies; setting n_order to 1.\"\n        )\n    # operator_info.weight = exponential_decay(operator_info.n_order)\n    # Log the final n_order value for the operator\n    self.logger.info(\n        f\"Operator {operator.symbol} (ID: {operator.func_id}) has n_order: {operator.n_order}.\"\n    )\n</code></pre>"},{"location":"operatorplus/operator_manager/#opulse.operatorplus.operator_manager.OperatorManager.delete_one_operator","title":"<code>delete_one_operator(op_func_id)</code>","text":"<p>Delete an operator and recursively remove dependent operators. Afterward, reassign IDs for the remaining operators.</p> <p>Parameters:</p> Name Type Description Default <code>op_func_id</code> <code>int</code> <p>The ID of the operator to be deleted.</p> required Source code in <code>opulse/operatorplus/operator_manager.py</code> <pre><code>def delete_one_operator(self, op_func_id: str) -&gt; None:\n    \"\"\"\n    Delete an operator and recursively remove dependent operators.\n    Afterward, reassign IDs for the remaining operators.\n\n    Parameters:\n        op_func_id (int): The ID of the operator to be deleted.\n    \"\"\"\n    self.logger.debug(\"Attempting to delete operator with ID: %s\", op_func_id)\n\n    # Recursively delete the operator and its dependencies\n    self.delete_one_operator_by_dep(op_func_id)\n\n    # Reassign operator IDs after deletion\n    sorted_keys = sorted(self.operators.keys())\n    op_pattern = r\"def op_(\\s+)\"\n    op_count_pattern = r\"def op_count_(\\s+)\"\n\n    for i, old_key in enumerate(sorted_keys, start=1):\n        if old_key != i:\n            self.operators[i] = self.operators[old_key]\n            # Update the ID of the operator\n            self.operators[i].id = i\n            # Update the operator's function string\n            self.operators[i].op_compute_func = re.sub(\n                op_pattern,\n                lambda m: f\"def op_{i}\",\n                self.operators[i].op_compute_func,\n                count=1,\n            )\n            self.operators[i].op_count_func = re.sub(\n                op_count_pattern,\n                lambda m: f\"def op_count_{i}\",\n                self.operators[i].op_count_func,\n                count=1,\n            )\n            for operator in self.operators.values():\n                if old_key in operator.dependencies:\n                    # Replace old_key with i in dependencies\n                    operator.dependencies = [\n                        i if dep == old_key else dep\n                        for dep in operator.dependencies\n                    ]\n                    # Also, update the operator's compute functions to reflect the new op_id\n                    operator.op_compute_func = re.sub(\n                        rf\"op_{old_key}\",\n                        lambda m: f\"op_{i}\",\n                        operator.op_compute_func,\n                    )\n                    operator.op_count_func = re.sub(\n                        rf\"op_count_{old_key}\",\n                        lambda m: f\"op_count_{i}\",\n                        operator.op_count_func,\n                    )\n            del self.operators[old_key]\n\n    self.logger.info(\n        \"Operator with ID %s and its dependencies removed. Operator IDs reassigned.\",\n        op_func_id)\n</code></pre>"},{"location":"operatorplus/operator_manager/#opulse.operatorplus.operator_manager.OperatorManager.delete_one_operator_by_dep","title":"<code>delete_one_operator_by_dep(op_func_id)</code>","text":"<p>Recursively delete an operator and its dependencies.</p> <p>Parameters:</p> Name Type Description Default <code>op_func_id</code> <code>int</code> <p>The ID of the operator to be deleted.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the operator with the given ID does not exist.</p> Source code in <code>opulse/operatorplus/operator_manager.py</code> <pre><code>def delete_one_operator_by_dep(self, op_func_id: str) -&gt; None:\n    \"\"\"\n    Recursively delete an operator and its dependencies.\n\n    Parameters:\n        op_func_id (int): The ID of the operator to be deleted.\n\n    Raises:\n        ValueError: If the operator with the given ID does not exist.\n    \"\"\"\n    self.logger.debug(\n        \"Attempting to recursively delete operator with ID: %s\", op_func_id\n    )\n\n    # Check if the operator exists\n    if op_func_id not in self.operators:\n        self.logger.error(f\"Operator ID {op_func_id} does not exist.\")\n        raise ValueError(f\"Operator ID {op_func_id} does not exist.\")\n\n    # Set to keep track of operators that need to be deleted\n    to_delete_ids = set()\n\n    # Recursively find all operators that depend on the given operator\n    self._find_all_dependent_operator_ids(op_func_id, to_delete_ids)\n\n    # Remove the operators\n    for op_id_to_delete in to_delete_ids:\n        self.remove_operator(op_id_to_delete)\n\n    self.logger.debug(\n        \"Completed recursive deletion for operator ID: %s and its dependencies.\",\n        op_func_id,\n    )\n</code></pre>"},{"location":"operatorplus/operator_manager/#opulse.operatorplus.operator_manager.OperatorManager.extract_op_dependencies","title":"<code>extract_op_dependencies(operator)</code>","text":"<p>Extracts dependencies of a given operator by analyzing its compute function.</p> <p>This method uses a regular expression to match operator IDs in the <code>op_compute_func</code> field of the operator and identifies any dependencies (operators that the current operator relies on).</p> <p>Parameters:</p> Name Type Description Default <code>operator</code> <code>OperatorInfo</code> <p>The operator whose dependencies need to be extracted.</p> required Updates <ul> <li>The <code>dependencies</code> attribute of the operator is updated to a list of dependent operator IDs.</li> </ul> Source code in <code>opulse/operatorplus/operator_manager.py</code> <pre><code>def extract_op_dependencies(self, operator:OperatorInfo):\n    \"\"\"\n    Extracts dependencies of a given operator by analyzing its compute function.\n\n    This method uses a regular expression to match operator IDs in the `op_compute_func`\n    field of the operator and identifies any dependencies (operators that the current\n    operator relies on).\n\n    Parameters:\n        operator (OperatorInfo): The operator whose dependencies need to be extracted.\n\n    Updates:\n        - The `dependencies` attribute of the operator is updated to a list of dependent operator IDs.\n    \"\"\"\n    # Regular expression pattern to match operator dependencies (e.g., op_1, op_2, etc.)\n    op_pattern = r\"op_(\\w+)\\(\"\n\n    # Use re.findall to extract all matching operator IDs from the function\n    op_strs = re.findall(op_pattern, operator.op_compute_func)\n\n    # Convert matched strings and remove duplicates\n    op_strs = list(set(op_strs)) \n\n    # If the operator itself is in the list of dependencies, remove it\n    if operator.func_id in op_strs:\n        op_strs.remove(operator.func_id)\n\n    # Update operator dependencies\n    operator.dependencies = op_strs\n</code></pre>"},{"location":"operatorplus/operator_manager/#opulse.operatorplus.operator_manager.OperatorManager.get_operator_by_base","title":"<code>get_operator_by_base(base)</code>","text":"<p>Retrieves an operator based on the given base (number system).</p> <p>Parameters:</p> Name Type Description Default <code>base</code> <code>int</code> <p>The base (e.g., 2 for binary, 10 for decimal, etc.).</p> required <p>Returns:</p> Name Type Description <code>OperatorInfo</code> <code>OperatorInfo</code> <p>The operator corresponding to the given base.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no operators are available for the given base.</p> Source code in <code>opulse/operatorplus/operator_manager.py</code> <pre><code>def get_operator_by_base(self, base: int) -&gt; OperatorInfo:\n    \"\"\"\n    Retrieves an operator based on the given base (number system).\n\n    Args:\n        base (int): The base (e.g., 2 for binary, 10 for decimal, etc.).\n\n    Returns:\n        OperatorInfo: The operator corresponding to the given base.\n\n    Raises:\n        ValueError: If no operators are available for the given base.\n    \"\"\"\n    self.logger.debug(f\"Fetching operator for base {base}.\")\n\n    if base not in self.base_operators:\n        self.logger.error(f\"Base type {base} does not exist.\")\n        raise ValueError(f\"Base type {base} does not exist.\")\n\n    self.logger.debug(f\"Found operator(s) for base {base}.\")\n    return self.base_operators[base]\n</code></pre>"},{"location":"operatorplus/operator_manager/#opulse.operatorplus.operator_manager.OperatorManager.get_operator_by_func_id","title":"<code>get_operator_by_func_id(op_func_id)</code>","text":"<p>Retrieves an operator by its function ID.</p> <p>Parameters:</p> Name Type Description Default <code>op_func_id</code> <code>str</code> <p>The function ID of the operator.</p> required <p>Returns:</p> Name Type Description <code>OperatorInfo</code> <code>OperatorInfo</code> <p>The operator corresponding to the given function ID.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no operator with the given function ID exists.</p> Source code in <code>opulse/operatorplus/operator_manager.py</code> <pre><code>def get_operator_by_func_id(self, op_func_id: str) -&gt; OperatorInfo:\n    \"\"\"\n    Retrieves an operator by its function ID.\n\n    Parameters:\n        op_func_id (str): The function ID of the operator.\n\n    Returns:\n        OperatorInfo: The operator corresponding to the given function ID.\n\n    Raises:\n        ValueError: If no operator with the given function ID exists.\n    \"\"\"\n    self.logger.debug(f\"Fetching operator with func ID {op_func_id}.\")\n\n    if op_func_id not in self.operators:\n        self.logger.error(f\"Operator ID {op_func_id} does not exist.\")\n        raise ValueError(f\"Operator ID {op_func_id} does not exist.\")\n\n    self.logger.debug(f\"Operator ID {op_func_id} found.\")\n    return self.operators[op_func_id]\n</code></pre>"},{"location":"operatorplus/operator_manager/#opulse.operatorplus.operator_manager.OperatorManager.get_operator_function_id","title":"<code>get_operator_function_id(operator_symbol, is_unary, unary_position)</code>","text":"<p>Retrieves the function ID and temporary status of an operator based on its symbol and type (unary or binary).</p> <p>Parameters:</p> Name Type Description Default <code>operator_symbol</code> <code>str</code> <p>The operator symbol.</p> required <code>is_unary</code> <code>bool</code> <p>A boolean indicating whether the operator is unary (True) or binary (False).</p> required <p>Returns:</p> Type Description <code>Optional[tuple[int, bool]]</code> <p>Optional[tuple[int, bool]]: A tuple containing the operator's function ID and its temporary status.                         If no matching operator is found, returns (None, False).</p> Source code in <code>opulse/operatorplus/operator_manager.py</code> <pre><code>def get_operator_function_id(\n    self, operator_symbol: str, is_unary: bool, unary_position: str\n) -&gt; Optional[tuple[int, bool]]:\n    \"\"\"\n    Retrieves the function ID and temporary status of an operator based on its symbol and type (unary or binary).\n\n    Args:\n        operator_symbol (str): The operator symbol.\n        is_unary (bool): A boolean indicating whether the operator is unary (True) or binary (False).\n\n    Returns:\n        Optional[tuple[int, bool]]: A tuple containing the operator's function ID and its temporary status.\n                                    If no matching operator is found, returns (None, False).\n    \"\"\"\n    self.logger.debug(\n        f\"Fetching function ID for operator symbol '{operator_symbol}' and type {'unary' if is_unary else 'binary'}.\"\n    )\n\n    for operator in self.symbol_to_operators.get(operator_symbol, []):\n        if (is_unary and operator.n_ary == 1 and operator.unary_position == unary_position) or (\n            not is_unary and operator.n_ary == 2\n        ):\n            self.logger.debug(\n                f\"Found operator {operator.id} ({operator.symbol}) matching the criteria.\"\n            )\n            return operator.func_id, operator.is_temporary\n\n    self.logger.debug(\n        f\"No matching operator found for symbol '{operator_symbol}' and type {'unary' if is_unary else 'binary'}.\"\n    )\n    return None, False\n</code></pre>"},{"location":"operatorplus/operator_manager/#opulse.operatorplus.operator_manager.OperatorManager.get_operator_symbols","title":"<code>get_operator_symbols()</code>","text":"<p>Retrieves a list of all operator symbols.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: A list of operator symbols.</p> Source code in <code>opulse/operatorplus/operator_manager.py</code> <pre><code>def get_operator_symbols(self) -&gt; List[str]:\n    \"\"\"\n    Retrieves a list of all operator symbols.\n\n    Returns:\n        List[str]: A list of operator symbols.\n    \"\"\"\n    self.logger.debug(\"Fetching all operator symbols.\")\n\n    symbols = list(self.symbol_to_operators.keys())\n\n    self.logger.debug(f\"Found {len(symbols)} operator symbols.\")\n    return symbols\n</code></pre>"},{"location":"operatorplus/operator_manager/#opulse.operatorplus.operator_manager.OperatorManager.get_operators_by_priority","title":"<code>get_operators_by_priority()</code>","text":"<p>Sorts and returns operators based on their priority.</p> <p>This method sorts all operators by their priority, where operators with lower priority come first.</p> <p>Returns:</p> Type Description <code>List[OperatorInfo]</code> <p>List[OperatorInfo]: A list of operators sorted by priority.</p> Source code in <code>opulse/operatorplus/operator_manager.py</code> <pre><code>def get_operators_by_priority(self) -&gt; List[OperatorInfo]:\n    \"\"\"\n    Sorts and returns operators based on their priority.\n\n    This method sorts all operators by their priority, where operators with lower priority come first.\n\n    Returns:\n        List[OperatorInfo]: A list of operators sorted by priority.\n    \"\"\"\n    self.logger.debug(\"Sorting operators by priority.\")\n\n    # Sort operators by priority in ascending order (lower priority first)\n    sorted_operators = sorted(\n        self.operators.values(), key=lambda op: op.priority, reverse=False\n    )\n\n    self.logger.debug(f\"Sorted {len(sorted_operators)} operators by priority.\")\n\n    return sorted_operators\n</code></pre>"},{"location":"operatorplus/operator_manager/#opulse.operatorplus.operator_manager.OperatorManager.get_operators_by_symbol","title":"<code>get_operators_by_symbol(symbol)</code>","text":"<p>Retrieves all operators corresponding to a given symbol.</p> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>The operator symbol.</p> required <p>Returns:</p> Type Description <code>List[OperatorInfo]</code> <p>List[OperatorInfo]: A list of operators corresponding to the symbol.</p> Source code in <code>opulse/operatorplus/operator_manager.py</code> <pre><code>def get_operators_by_symbol(self, symbol: str) -&gt; List[OperatorInfo]:\n    \"\"\"\n    Retrieves all operators corresponding to a given symbol.\n\n    Args:\n        symbol (str): The operator symbol.\n\n    Returns:\n        List[OperatorInfo]: A list of operators corresponding to the symbol.\n    \"\"\"\n    self.logger.debug(f\"Fetching operators with symbol '{symbol}'.\")\n\n    operators = self.symbol_to_operators.get(symbol, [])\n\n    self.logger.debug(f\"Found {len(operators)} operators for symbol '{symbol}'.\")\n    return operators\n</code></pre>"},{"location":"operatorplus/operator_manager/#opulse.operatorplus.operator_manager.OperatorManager.get_unary_and_binary_operators","title":"<code>get_unary_and_binary_operators()</code>","text":"<p>Retrieves the lists of unary prefix operators, unary postfix operators, and binary operators.</p> <p>This method categorizes the operators into three types: - Unary prefix operators: Operators that appear before their operands. - Unary postfix operators: Operators that appear after their operands. - Binary operators: Operators that take two operands.</p> <p>Returns:</p> Type Description <code>List[OperatorInfo]</code> <p>Tuple[List[OperatorInfo], List[OperatorInfo], List[OperatorInfo]]:</p> <code>List[OperatorInfo]</code> <p>A tuple containing three lists:</p> <code>List[OperatorInfo]</code> <ol> <li>List of unary prefix operators</li> </ol> <code>Tuple[List[OperatorInfo], List[OperatorInfo], List[OperatorInfo]]</code> <ol> <li>List of unary postfix operators</li> </ol> <code>Tuple[List[OperatorInfo], List[OperatorInfo], List[OperatorInfo]]</code> <ol> <li>List of binary operators</li> </ol> Source code in <code>opulse/operatorplus/operator_manager.py</code> <pre><code>def get_unary_and_binary_operators(\n    self,\n) -&gt; Tuple[List[OperatorInfo], List[OperatorInfo], List[OperatorInfo]]:\n    \"\"\"\n    Retrieves the lists of unary prefix operators, unary postfix operators, and binary operators.\n\n    This method categorizes the operators into three types:\n    - Unary prefix operators: Operators that appear before their operands.\n    - Unary postfix operators: Operators that appear after their operands.\n    - Binary operators: Operators that take two operands.\n\n    Returns:\n        Tuple[List[OperatorInfo], List[OperatorInfo], List[OperatorInfo]]:\n        A tuple containing three lists:\n        1. List of unary prefix operators\n        2. List of unary postfix operators\n        3. List of binary operators\n    \"\"\"\n    self.logger.debug(\"Fetching unary and binary operators.\")\n\n    # Get unary prefix operators\n    unary_prefix_ops = [\n        op\n        for op in self.operators.values()\n        if op.n_ary == 1 and op.unary_position == \"prefix\"\n    ]\n\n    self.logger.debug(f\"Found {len(unary_prefix_ops)} unary prefix operators.\")\n\n    # Get unary postfix operators\n    unary_postfix_ops = [\n        op\n        for op in self.operators.values()\n        if op.n_ary == 1 and op.unary_position == \"postfix\"\n    ]\n\n    self.logger.debug(f\"Found {len(unary_postfix_ops)} unary postfix operators.\")\n\n    # Get binary operators\n    binary_ops = [op for op in self.operators.values() if op.n_ary == 2]\n\n    self.logger.debug(f\"Found {len(binary_ops)} binary operators.\")\n\n    return unary_prefix_ops, unary_postfix_ops, binary_ops\n</code></pre>"},{"location":"operatorplus/operator_manager/#opulse.operatorplus.operator_manager.OperatorManager.load_operators","title":"<code>load_operators()</code>","text":"<p>Loads operator definitions from a JSONL file.</p> <p>This method reads the configuration file line by line, parses each line into an <code>OperatorInfo</code> object, and stores the operators in various structures: - <code>self.operators</code>: A dictionary with operator ID as the key and <code>OperatorInfo</code> as the value. - <code>self.symbol_to_operators</code>: A dictionary with operator symbol as the key and a list of <code>OperatorInfo</code> as the value. - <code>self.base_operators</code>: A dictionary to store base operators based on their base status.</p> <p>Additionally, it updates the available functions for computation and counting based on the loaded operators.</p> <p>Logs relevant information about the loading process for monitoring and debugging purposes.</p> Source code in <code>opulse/operatorplus/operator_manager.py</code> <pre><code>def load_operators(self):\n    \"\"\"\n    Loads operator definitions from a JSONL file.\n\n    This method reads the configuration file line by line, parses each line into an\n    `OperatorInfo` object, and stores the operators in various structures:\n    - `self.operators`: A dictionary with operator ID as the key and `OperatorInfo` as the value.\n    - `self.symbol_to_operators`: A dictionary with operator symbol as the key and a list of `OperatorInfo` as the value.\n    - `self.base_operators`: A dictionary to store base operators based on their base status.\n\n    Additionally, it updates the available functions for computation and counting based on the loaded operators.\n\n    Logs relevant information about the loading process for monitoring and debugging purposes.\n    \"\"\"\n    self.logger.info(\n        f\"Loading operators from configuration file: {self.config_file}\"\n    )\n\n    with open(self.config_file, \"r\", encoding=\"utf-8\") as f:\n        line_count = 0\n        for line in f:\n            line_count += 1\n            if not line.strip():\n                self.logger.debug(f\"Skipping empty line {line_count}.\")\n                continue  # Skip empty lines\n            try:\n                operator = OperatorInfo.from_json(line)\n                if self.load_compile:\n                    so_file = f\"module_{operator.func_id}.cpython-310-x86_64-linux-gnu.so\"\n                    full_path = os.path.join(self.cython_cache_dir, so_file)\n                    if os.path.exists(full_path):\n                        operator.module = self.compiler.import_module_from_path(f\"module_{operator.func_id}\")\n                    else:    \n                        func_code_str = f\"thres = {2**31 - 1}\\n\\n\"#Add the value and limit of the thres variable.\n                        func_code_str += f\"# Operator Func ID: {operator.func_id} - op_compute_func\\n\"\n                        func_code_str += f\"{operator.op_compute_func}\\n\\n\"\n                        func_code_str += f\"# Operator Func ID: {operator.func_id} - op_count_func\\n\"\n                        func_code_str += f\"{operator.op_count_func}\\n\\n\"\n                        self.compiler.compile_function(func_code_str, operator.func_id, deps = None) \n                        operator.module = self.compiler.import_module_from_path(f\"module_{operator.func_id}\")\n\n                self.operators[operator.func_id] = operator\n                self.symbol_to_operators[operator.symbol].append(operator)\n\n                # Update available functions for the operator\n                if operator.is_base:\n                    self.base_operators[operator.is_base].append(operator)\n\n                # self._update_available_funcs(operator)\n                self.logger.info(\n                    f\"Loaded operator {operator.id} ({operator.symbol}) from line {line_count}.\"\n                )\n\n            except Exception as e:\n                self.logger.warning(\n                    f\"Failed to parse operator from line {line_count}: {e}\"\n                )\n    # self.save_op_funcs_to_file()   \n    self.logger.info(\n        f\"Successfully loaded {len(self.operators)} operators from the configuration file.\"\n    )\n</code></pre>"},{"location":"operatorplus/operator_manager/#opulse.operatorplus.operator_manager.OperatorManager.remove_operator","title":"<code>remove_operator(op_func_id)</code>","text":"<p>Dynamically removes an operator from the system.</p> <p>This method removes an operator by its ID, updating the internal storage (both <code>self.operators</code> and <code>self.symbol_to_operators</code>) accordingly.</p> <p>Parameters:</p> Name Type Description Default <code>op_func_id</code> <code>int</code> <p>The ID of the operator to be removed.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the operator ID does not exist in the system.</p> Source code in <code>opulse/operatorplus/operator_manager.py</code> <pre><code>def remove_operator(self, op_func_id: str):\n    \"\"\"\n    Dynamically removes an operator from the system.\n\n    This method removes an operator by its ID, updating the internal storage\n    (both `self.operators` and `self.symbol_to_operators`) accordingly.\n\n    Parameters:\n        op_func_id (int): The ID of the operator to be removed.\n\n    Raises:\n        ValueError: If the operator ID does not exist in the system.\n    \"\"\"\n    self.logger.debug(\"Attempting to remove operator with ID: %s\", op_func_id)\n\n    if op_func_id not in self.operators:\n        self.logger.error(f\"Operator ID {op_func_id} does not exist.\")\n        raise ValueError(f\"Operator ID {op_func_id} does not exist.\")\n\n    # Retrieve and remove the operator from the operators dictionary\n    operator = self.operators.pop(op_func_id)\n    self.logger.info(f\"Removed operator {operator.symbol} (ID: {op_func_id}).\")\n\n    # Remove the operator from the symbol_to_operators mapping\n    if operator.symbol in self.symbol_to_operators:\n        self.symbol_to_operators[operator.symbol].remove(operator)\n        self.logger.debug(\n            f\"Operator {operator.symbol} (ID: {op_func_id}) removed from symbol_to_operators.\"\n        )\n</code></pre>"},{"location":"operatorplus/operator_manager/#opulse.operatorplus.operator_manager.OperatorManager.save_op_funcs_to_file","title":"<code>save_op_funcs_to_file(file_path)</code>","text":"<p>Saves all operator functions to a <code>.pyx</code> file for compilation.</p> <p>This method writes the compute and count functions of all operators to a <code>.pyx</code> file, ensuring that they can be compiled later.</p> Source code in <code>opulse/operatorplus/operator_manager.py</code> <pre><code>def save_op_funcs_to_file(self, file_path:str):\n    \"\"\"\n    Saves all operator functions to a `.pyx` file for compilation.\n\n    This method writes the compute and count functions of all operators to a `.pyx` file,\n    ensuring that they can be compiled later.\n    \"\"\"\n    with open(file_path, \"w\") as file:\n        # Write the necessary imports and initializations at the start of the file\n        file.write(f\"thres = {2**31 - 1}\\n\\n\")\n\n        # Now, write the operator functions\n        for op_func_id, operator_info in self.operators.items():\n            # Ensure both op_compute_func and op_count_func exist\n            if hasattr(operator_info, 'op_compute_func') and hasattr(operator_info, 'op_count_func'):\n                # Write the op_compute_func (as string)\n                op_compute_func_str = operator_info.op_compute_func\n                file.write(f\"# Operator ID: {op_func_id} - op_compute_func\\n\")\n                file.write(f\"{op_compute_func_str}\\n\\n\")\n\n                # Write the op_count_func (as string)\n                op_count_func_str = operator_info.op_count_func\n                file.write(f\"# Operator ID: {op_func_id} - op_count_func\\n\")\n                file.write(f\"{op_count_func_str}\\n\\n\")\n            else:\n                self.logger.warning(f\"Operator ID {op_func_id} does not have a valid op_compute_func or op_count_func.\")\n</code></pre>"},{"location":"operatorplus/operator_manager/#opulse.operatorplus.operator_manager.OperatorManager.save_operators_to_jsonl","title":"<code>save_operators_to_jsonl(file_path)</code>","text":"<p>Saves all operators to a JSONL file.</p> <p>This method serializes each operator in <code>self.operators</code> and writes it to the specified file path in JSONL format.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>The path to the file where the operators should be saved.</p> required <p>Logs the process of saving operators to the file.</p> Source code in <code>opulse/operatorplus/operator_manager.py</code> <pre><code>def save_operators_to_jsonl(self, file_path: str):\n    \"\"\"\n    Saves all operators to a JSONL file.\n\n    This method serializes each operator in `self.operators` and writes it to the specified file path in JSONL format.\n\n    Parameters:\n        file_path (str): The path to the file where the operators should be saved.\n\n    Logs the process of saving operators to the file.\n    \"\"\"\n    self.logger.info(f\"Saving operators to {file_path}.\")\n\n    with open(file_path, \"w\", encoding=\"utf-8\") as file:\n        for operator in self.operators.values():\n            json_line = operator.to_json()\n            file.write(json_line + \"\\n\")\n            file.flush()  \n            self.logger.debug(\n                f\"Saved operator {operator.id} ({operator.symbol}) to {file_path}.\"\n            )\n\n    self.logger.info(f\"Successfully saved all operators to {file_path}.\")\n</code></pre>"},{"location":"operatorplus/operator_manager/#opulse.operatorplus.operator_manager.OperatorManager.update_operator","title":"<code>update_operator(op_func_id, updated_data)</code>","text":"<p>Dynamically updates an existing operator in the system.</p> <p>This method replaces the operator with the given ID (<code>op_id</code>) using the data in <code>updated_data</code>. It performs the necessary checks and ensures that all required fields are provided before updating the operator in the internal storage.</p> <p>Parameters:</p> Name Type Description Default <code>op_func_id</code> <code>int</code> <p>The ID of the operator to be updated.</p> required <code>updated_data</code> <code>dict</code> <p>A dictionary containing the updated data for the operator.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the operator ID does not exist or required fields are missing.</p> Source code in <code>opulse/operatorplus/operator_manager.py</code> <pre><code>def update_operator(self, op_func_id: str, updated_data: Dict[str, Any]):\n    \"\"\"\n    Dynamically updates an existing operator in the system.\n\n    This method replaces the operator with the given ID (`op_id`) using the data\n    in `updated_data`. It performs the necessary checks and ensures that all required fields\n    are provided before updating the operator in the internal storage.\n\n    Parameters:\n        op_func_id (int): The ID of the operator to be updated.\n        updated_data (dict): A dictionary containing the updated data for the operator.\n\n    Raises:\n        ValueError: If the operator ID does not exist or required fields are missing.\n    \"\"\"\n    self.logger.debug(\"Attempting to update operator with ID: %s\", op_func_id)\n\n    # Check if the operator exists\n    if op_func_id not in self.operators:\n        self.logger.error(f\"Operator ID {op_func_id} does not exist.\")\n        raise ValueError(f\"Operator ID {op_func_id} does not exist.\")\n\n    # Ensure the 'id' in updated_data matches the op_id\n    updated_data[\"func_id\"] = op_func_id\n\n    # Ensure 'compute_func' is provided in the updated data\n    if \"compute_func\" not in updated_data or not updated_data[\"compute_func\"]:\n        self.logger.error(\"compute_func must be provided.\")\n        raise ValueError(\"compute_func must be provided.\")\n\n    # Set 'n_order' to None, letting calculate_order handle it later\n    updated_data[\"n_order\"] = None\n\n    # Remove the old operator\n    old_operator = self.operators.pop(op_func_id)\n    self.symbol_to_operators[old_operator.symbol].remove(old_operator)\n    self.logger.info(f\"Removed old operator {old_operator.symbol} (ID: {op_func_id}).\")\n\n    # Add the updated operator\n    updated_operator = OperatorInfo(**updated_data)\n    self.operators[updated_operator.id] = updated_operator\n    self.symbol_to_operators[updated_operator.symbol].append(updated_operator)\n    self.logger.info(f\"Updated operator {updated_operator.symbol} (ID: {op_func_id}).\")\n\n    # Recalculate order after the update\n    self.calculate_order()\n    self.logger.debug(f\"Recalculated order for operator ID: {op_func_id}.\")\n</code></pre>"},{"location":"operatorplus/operator_manager/#opulse.operatorplus.operator_manager.OperatorManager.update_operator_temporary_status","title":"<code>update_operator_temporary_status(op_func_id, new_status)</code>","text":"<p>Updates the 'is_temporary' status of the specified operator.</p> <p>This function looks for an operator by its ID and sets its 'is_temporary' status to the provided new status.</p> <p>Parameters:</p> Name Type Description Default <code>op_func_id</code> <code>int</code> <p>The ID of the operator to update.</p> required <code>new_status</code> <code>bool</code> <p>The new 'is_temporary' status to set for the operator.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Returns True if the update was successful, otherwise returns False if the operator was not found.</p> Source code in <code>opulse/operatorplus/operator_manager.py</code> <pre><code>def update_operator_temporary_status(\n    self, op_func_id: str, new_status: bool\n) -&gt; bool:\n    \"\"\"\n    Updates the 'is_temporary' status of the specified operator.\n\n    This function looks for an operator by its ID and sets its 'is_temporary' status\n    to the provided new status.\n\n    Parameters:\n        op_func_id (int): The ID of the operator to update.\n        new_status (bool): The new 'is_temporary' status to set for the operator.\n\n    Returns:\n        bool: Returns True if the update was successful, otherwise returns False if the operator was not found.\n    \"\"\"\n    self.logger.debug(\n        f\"Attempting to update 'is_temporary' status for operator ID {op_func_id} to {new_status}.\"\n    )\n\n    # Loop through all operators to find the one with the specified ID\n    for operators in self.symbol_to_operators.values():\n        for operator in operators:\n            if operator.func_id == op_func_id:\n                # Found the operator, updating its is_temporary status\n                operator.is_temporary = new_status\n                self.logger.info(\n                    f\"Operator {op_func_id}: 'is_temporary' status successfully updated to {new_status}.\"\n                )\n                return True  # Update successful\n\n    # If the operator ID was not found, log an error and return False\n    self.logger.error(f\"Operator with ID {op_func_id} not found. Update failed.\")\n    return False  # Operator not found\n</code></pre>"},{"location":"operatorplus/operator_priority_manager/","title":"OperatorPriorityManager","text":""},{"location":"operatorplus/operator_priority_manager/#opulse.operatorplus.operator_priority_manager.OperatorPriorityManager","title":"<code>OperatorPriorityManager</code>","text":"Source code in <code>opulse/operatorplus/operator_priority_manager.py</code> <pre><code>class OperatorPriorityManager:\n    def __init__(\n        self,\n        logger: LogConfig,\n        operator_manager: \"OperatorManager\" = None,\n    ):\n        \"\"\"\n        Initializes the OperatorPriorityManager with a logger and an optional OperatorManager.\n\n        Parameters:\n            logger (logging.Logger): Logger instance for logging messages.\n            operator_manager (OperatorManager, optional): An instance of OperatorManager for managing operators.\n        \"\"\"\n        self.logger = logger.get_logger()\n        self.operator_manager = operator_manager\n\n    def assign_priorities(self):\n        \"\"\"\n        Assigns priorities and associativities to operators.\n\n        Rules:\n        1. Postfix operators have a higher priority than prefix operators.\n        2. Operators with the same priority have the same associativity.\n\n        This method assigns priorities and associativities to all operators managed by the OperatorManager.\n        The assignment follows the rules defined above.\n        \"\"\"\n        self.logger.info(\"Starting to assign operator priorities and associativities...\")\n\n        # A dictionary to hold the associativity direction for each priority level\n        self.priority_associativity = {}\n        self.max_priority = 0\n\n        # Reset the current priority and associativity of each operator\n        for op in self.operator_manager.operators.values():\n            op.priority = 0\n            op.associativity_direction = None\n\n        # Iterate over all operators to assign priority and associativity\n        for op in self.operator_manager.operators.values():\n            if op.n_ary == 1:\n                # Assign priority for unary operators (either prefix or postfix)\n                if op.unary_position == \"prefix\":\n                    # Prefix operators typically have right associativity\n                    available_priority = [\n                        p for p, a in self.priority_associativity.items() if a == \"right\"\n                    ]\n                    available_priority.append(self.max_priority + 1)\n                    op.priority = random.choice(available_priority)\n                    op.associativity_direction = \"right\"\n                    self.logger.debug(f\"Assigned 'prefix' unary operator '{op.symbol}' a priority of {op.priority} and right associativity.\")\n                elif op.unary_position == \"postfix\":\n                    # Postfix operators typically have left associativity\n                    available_priority = [\n                        p for p, a in self.priority_associativity.items() if a == \"left\"\n                    ]\n                    available_priority.append(self.max_priority + 1)\n                    op.priority = random.choice(available_priority)\n                    op.associativity_direction = \"left\"\n                    self.logger.debug(f\"Assigned 'postfix' unary operator '{op.symbol}' a priority of {op.priority} and left associativity.\")\n\n                # If a new priority was assigned, update max_priority and associativity\n                if op.priority == self.max_priority + 1:\n                    self.max_priority += 1\n                    self.priority_associativity[self.max_priority] = op.associativity_direction\n\n            elif op.n_ary == 2:\n                # Assign priority for binary operators\n                available_priority = [p for p, a in self.priority_associativity.items()]\n                available_priority.append(self.max_priority + 1)\n                op.priority = random.choice(available_priority)\n\n                # If a new priority is assigned, set associativity\n                if op.priority == self.max_priority + 1:\n                    op.associativity_direction = random.choice([\"left\", \"right\"])\n                    self.max_priority += 1\n                    self.priority_associativity[self.max_priority] = op.associativity_direction\n                    self.logger.debug(f\"Assigned binary operator '{op.symbol}' a new priority of {op.priority} and random associativity.\")\n                else:\n                    op.associativity_direction = self.priority_associativity[op.priority]\n                    self.logger.debug(f\"Assigned binary operator '{op.symbol}' the existing priority of {op.priority} and associativity {op.associativity_direction}.\")\n\n            # Log the assigned priority and associativity for each operator\n            self.logger.info(\n                f\"Assigned operator '{op.symbol}' ({op.n_ary}-ary, ID: {op.id}) with priority: {op.priority}, associativity: {op.associativity_direction}\"\n            )\n\n        self.logger.info(\"Operator priority and associativity assignment completed.\")\n</code></pre>"},{"location":"operatorplus/operator_priority_manager/#opulse.operatorplus.operator_priority_manager.OperatorPriorityManager.__init__","title":"<code>__init__(logger, operator_manager=None)</code>","text":"<p>Initializes the OperatorPriorityManager with a logger and an optional OperatorManager.</p> <p>Parameters:</p> Name Type Description Default <code>logger</code> <code>Logger</code> <p>Logger instance for logging messages.</p> required <code>operator_manager</code> <code>OperatorManager</code> <p>An instance of OperatorManager for managing operators.</p> <code>None</code> Source code in <code>opulse/operatorplus/operator_priority_manager.py</code> <pre><code>def __init__(\n    self,\n    logger: LogConfig,\n    operator_manager: \"OperatorManager\" = None,\n):\n    \"\"\"\n    Initializes the OperatorPriorityManager with a logger and an optional OperatorManager.\n\n    Parameters:\n        logger (logging.Logger): Logger instance for logging messages.\n        operator_manager (OperatorManager, optional): An instance of OperatorManager for managing operators.\n    \"\"\"\n    self.logger = logger.get_logger()\n    self.operator_manager = operator_manager\n</code></pre>"},{"location":"operatorplus/operator_priority_manager/#opulse.operatorplus.operator_priority_manager.OperatorPriorityManager.assign_priorities","title":"<code>assign_priorities()</code>","text":"<p>Assigns priorities and associativities to operators.</p> <p>Rules: 1. Postfix operators have a higher priority than prefix operators. 2. Operators with the same priority have the same associativity.</p> <p>This method assigns priorities and associativities to all operators managed by the OperatorManager. The assignment follows the rules defined above.</p> Source code in <code>opulse/operatorplus/operator_priority_manager.py</code> <pre><code>def assign_priorities(self):\n    \"\"\"\n    Assigns priorities and associativities to operators.\n\n    Rules:\n    1. Postfix operators have a higher priority than prefix operators.\n    2. Operators with the same priority have the same associativity.\n\n    This method assigns priorities and associativities to all operators managed by the OperatorManager.\n    The assignment follows the rules defined above.\n    \"\"\"\n    self.logger.info(\"Starting to assign operator priorities and associativities...\")\n\n    # A dictionary to hold the associativity direction for each priority level\n    self.priority_associativity = {}\n    self.max_priority = 0\n\n    # Reset the current priority and associativity of each operator\n    for op in self.operator_manager.operators.values():\n        op.priority = 0\n        op.associativity_direction = None\n\n    # Iterate over all operators to assign priority and associativity\n    for op in self.operator_manager.operators.values():\n        if op.n_ary == 1:\n            # Assign priority for unary operators (either prefix or postfix)\n            if op.unary_position == \"prefix\":\n                # Prefix operators typically have right associativity\n                available_priority = [\n                    p for p, a in self.priority_associativity.items() if a == \"right\"\n                ]\n                available_priority.append(self.max_priority + 1)\n                op.priority = random.choice(available_priority)\n                op.associativity_direction = \"right\"\n                self.logger.debug(f\"Assigned 'prefix' unary operator '{op.symbol}' a priority of {op.priority} and right associativity.\")\n            elif op.unary_position == \"postfix\":\n                # Postfix operators typically have left associativity\n                available_priority = [\n                    p for p, a in self.priority_associativity.items() if a == \"left\"\n                ]\n                available_priority.append(self.max_priority + 1)\n                op.priority = random.choice(available_priority)\n                op.associativity_direction = \"left\"\n                self.logger.debug(f\"Assigned 'postfix' unary operator '{op.symbol}' a priority of {op.priority} and left associativity.\")\n\n            # If a new priority was assigned, update max_priority and associativity\n            if op.priority == self.max_priority + 1:\n                self.max_priority += 1\n                self.priority_associativity[self.max_priority] = op.associativity_direction\n\n        elif op.n_ary == 2:\n            # Assign priority for binary operators\n            available_priority = [p for p, a in self.priority_associativity.items()]\n            available_priority.append(self.max_priority + 1)\n            op.priority = random.choice(available_priority)\n\n            # If a new priority is assigned, set associativity\n            if op.priority == self.max_priority + 1:\n                op.associativity_direction = random.choice([\"left\", \"right\"])\n                self.max_priority += 1\n                self.priority_associativity[self.max_priority] = op.associativity_direction\n                self.logger.debug(f\"Assigned binary operator '{op.symbol}' a new priority of {op.priority} and random associativity.\")\n            else:\n                op.associativity_direction = self.priority_associativity[op.priority]\n                self.logger.debug(f\"Assigned binary operator '{op.symbol}' the existing priority of {op.priority} and associativity {op.associativity_direction}.\")\n\n        # Log the assigned priority and associativity for each operator\n        self.logger.info(\n            f\"Assigned operator '{op.symbol}' ({op.n_ary}-ary, ID: {op.id}) with priority: {op.priority}, associativity: {op.associativity_direction}\"\n        )\n\n    self.logger.info(\"Operator priority and associativity assignment completed.\")\n</code></pre>"},{"location":"operatorplus/operator_transformer/","title":"OperatorTransformer.md","text":""},{"location":"operatorplus/operator_transformer/#opulse.operatorplus.operator_transformer.OperatorTransformer","title":"<code>OperatorTransformer</code>","text":"<p>               Bases: <code>Transformer</code></p> Source code in <code>opulse/operatorplus/operator_transformer.py</code> <pre><code>class OperatorTransformer(Transformer):\n    def __init__(\n        self,\n        param_config: ParamConfig,\n        logger: LogConfig,\n        operator_manager: \"OperatorManager\" = None,\n    ):\n        \"\"\"\n        Initializes the OperatorTransformer instance with given configurations.\n\n        Args:\n           param_config (ParamConfig): Configuration for parameters.\n           logger (LogConfig): Logger configuration for logging debug and info messages.\n           operator_manager (OperatorManager, optional): Operator manager for handling operators.\n        \"\"\"\n        self.param_config = param_config\n        self.logger = logger.get_logger()\n        self.operator_manager = operator_manager\n        self.count_result = []\n\n    @v_args(inline=True)\n    def no_solution(self, token):\n        \"\"\"\n        Handles the NO_SOLUTION rule, returns the string 'NaN'.\n\n        Parameters:\n            token (Token): The token representing NO_SOLUTION.\n\n        Returns:\n            (str): The string '\"NaN\"'.\n        \"\"\"\n        self.logger.debug(f\"Processing NO_SOLUTION: {token}\")\n        result = float('nan')  # Ensure to return 'NaN' as a quoted string.\n        self.logger.debug(f\"Returning NO_SOLUTION result: {result}\")\n        return result\n\n    @v_args(inline=True)\n    def int_conversion(self, token):\n        \"\"\"\n        Converts an INT token to a string.\n\n        Parameters:\n            token (Token): The INT token to convert.\n\n        Returns:\n            (str): The string representation of the token's value.\n        \"\"\"\n        self.logger.debug(f\"Converting INT token: {token}\")\n        result = str(token.value)\n        self.logger.debug(f\"Returning INT conversion result: {result}\")\n        return result\n\n    @v_args(inline=True)\n    def variable_conversion(self, token):\n        \"\"\"\n        Converts a VARIABLE token to its string value.\n\n        Parameters:\n            token (Token): The VARIABLE token to convert.\n\n        Returns:\n            (str): The string representation of the token's value.\n        \"\"\"\n        self.logger.debug(f\"Converting VARIABLE token: {token}\")\n        result = token.value  # Assumes it's a simple variable name like 'a' or 'b'.\n        self.logger.debug(f\"Returning VARIABLE conversion result: {result}\")\n        return result\n\n    @v_args(inline=True)\n    def binary_operation(self, left, operator, right):\n        \"\"\"\n        Converts a binary operation into a function call.\n\n        Parameters:\n            left (str): The left operand.\n            operator (str): The operator symbol.\n            right (str): The right operand.\n\n        Returns:\n            (str): The function call string using the operator's function ID.\n        \"\"\"\n        self.logger.debug(\n            f\"Binary operation: left={left}, operator={operator}, right={right}\"\n        )\n        func_id, is_temporary = self.operator_manager.get_operator_function_id(\n            operator, is_unary=False, unary_position=\"null\"\n        )\n        self.logger.debug(f\"Function ID: {func_id}, Is temporary: {is_temporary}\")\n        if func_id and not is_temporary:\n            result = f\"op_{func_id}({left},{right})\"\n            count_result = f\"op_count_{func_id}({left},{right})\"\n            self.count_result.append(count_result)\n        else:\n            raise ValueError(\n                f\"Operator '{operator}' is not supported or lacks a function ID.\"\n            )\n        self.logger.debug(f\"Returning binary operation result: {result}\")\n        self.logger.debug(f\"self.count_result: {self.count_result}\")\n        return result\n\n    @v_args(inline=True)\n    def unary_operation_prefix(self, operator, operand):\n        \"\"\"\n        Converts a prefix unary operation into a function call.\n\n        Parameters:\n            operator (str): The operator symbol.\n            operand (str): The operand.\n\n        Returns:\n            (str): The function call string using the operator's function ID.\n        \"\"\"\n        self.logger.debug(\n            f\"Prefix unary operation: operator={operator}, operand={operand}\"\n        )\n        func_id, is_temporary = self.operator_manager.get_operator_function_id(\n            operator, is_unary=True, unary_position=\"prefix\"\n        )\n        self.logger.debug(f\"Function ID: {func_id}, Is temporary: {is_temporary}\")\n        if func_id and not is_temporary:\n            result = f\"op_{func_id}({operand})\"\n            count_result = f\"op_count_{func_id}({operand})\"\n            self.count_result.append(count_result)\n        else:\n            raise ValueError(\n                f\"Operator '{operator}' is not supported or lacks a function ID.\"\n            )\n        self.logger.debug(f\"Returning prefix unary operation result: {result}\")\n        self.logger.debug(f\"self.count_result: {self.count_result}\")\n        return result\n\n    @v_args(inline=True)\n    def unary_operation_postfix(self, operand, operator):\n        \"\"\"\n        Converts a postfix unary operation into a function call.\n\n        Parameters:\n            operand (str): The operand.\n            operator (str): The operator symbol.\n\n        Returns:\n            (str): The function call string using the operator's function ID.\n        \"\"\"\n        self.logger.debug(\n            f\"Postfix unary operation: operand={operand}, operator={operator}\"\n        )\n        func_id, is_temporary = self.operator_manager.get_operator_function_id(\n            operator, is_unary=True, unary_position=\"postfix\"\n        )\n        self.logger.debug(f\"Function ID: {func_id}, Is temporary: {is_temporary}\")\n        if func_id and not is_temporary:\n            result = f\"op_{func_id}({operand})\"\n            count_result = f\"op_count_{func_id}({operand})\"\n            self.count_result.append(count_result)\n        else:\n            raise ValueError(\n                f\"Operator '{operator}' is not supported or lacks a function ID.\"\n            )\n        self.logger.debug(f\"Returning postfix unary operation result: {result}\")\n        self.logger.debug(f\"self.count_result: {self.count_result}\")\n        return result\n\n    @v_args(inline=True)\n    def grouped_condition(self, condition):\n        \"\"\"\n        Wraps a condition in parentheses.\n\n        Parameters:\n            condition (str): The condition to wrap.\n\n        Returns:\n            (str): The condition wrapped in parentheses.\n        \"\"\"\n        self.logger.debug(f\"Processing grouped condition: {condition}\")\n        result = f\"({condition})\"\n        self.logger.debug(f\"Returning grouped condition result: {result}\")\n        return result\n\n    @v_args(inline=True)\n    def comparison(self, left, condition_operator, right):\n        \"\"\"\n        Converts a comparison expression into a string representation.\n\n        Parameters:\n            left (str): The left operand.\n            condition_operator (str): The comparison operator.\n            right (str): The right operand.\n\n        Returns:\n            (str): The comparison expression as a string.\n        \"\"\"\n        self.logger.debug(\n            f\"Processing comparison: left={left}, operator={condition_operator}, right={right}\"\n        )\n        result = f\"{left} {condition_operator} {right}\"\n        self.logger.debug(f\"Returning comparison result: {result}\")\n        return result\n\n    @v_args(inline=True)\n    def not_condition(self, condition):\n        \"\"\"\n        Wraps the condition with a 'not' operator.\n\n        Parameters:\n            condition (str): The condition to negate.\n\n        Returns:\n            (str): The negated condition as a string.\n        \"\"\"\n        self.logger.debug(f\"Processing 'not' condition: {condition}\")\n        result = f\"not ({condition})\"\n        self.logger.debug(f\"Returning 'not' condition result: {result}\")\n        return result\n\n    @v_args(inline=True)\n    def and_condition(self, left, right):\n        \"\"\"\n        Converts an 'and' condition into a string representation.\n\n        Parameters:\n            left (str): The left operand.\n            right (str): The right operand.\n\n        Returns:\n            (str): The 'and' condition as a string.\n        \"\"\"\n        self.logger.debug(f\"Processing 'and' condition: left={left}, right={right}\")\n        result = f\"{left} and {right}\"\n        self.logger.debug(f\"Returning 'and' condition result: {result}\")\n        return result\n\n    @v_args(inline=True)\n    def or_condition(self, left, right):\n        \"\"\"\n        Converts an 'or' condition into a string representation.\n\n        Parameters:\n            left (str): The left operand.\n            right (str): The right operand.\n\n        Returns:\n            (str): The 'or' condition as a string.\n        \"\"\"\n        self.logger.debug(f\"Processing 'or' condition: left={left}, right={right}\")\n        result = f\"{left} or {right}\"\n        self.logger.debug(f\"Returning 'or' condition result: {result}\")\n        return result\n\n    @v_args(inline=True)\n    def if_branch(self, expr, condition):\n        \"\"\"\n        Converts an 'if' branch into a tuple.\n\n        Parameters:\n            expr (str): The expression for the if branch.\n            condition (str): The condition for the if branch.\n\n        Returns:\n            (tuple): A tuple representing the if branch.\n        \"\"\"\n        self.logger.debug(f\"Processing 'if' branch: expr={expr}, condition={condition}\")\n        count_str = \"+\".join(str(item) for item in self.count_result)\n        self.count_result.clear()\n        result = (\"if_branch\", expr, condition, count_str)\n        self.logger.debug(f\"Returning 'if' branch result: {result}\")\n        return result\n\n    @v_args(inline=True)\n    def else_branch(self, expr):\n        \"\"\"\n        Converts an 'else' branch into a tuple.\n\n        Parameters:\n            expr (str): The expression for the else branch.\n\n        Returns:\n            (tuple): A tuple representing the else branch.\n        \"\"\"\n        self.logger.debug(f\"Processing 'else' branch: expr={expr}\")\n        count_str = \"+\".join(str(item) for item in self.count_result)\n        self.count_result.clear()\n        result = (\"else_branch\", expr, count_str)\n        self.logger.debug(f\"Returning 'else' branch result: {result}\")\n        return result\n\n    @v_args(inline=True)\n    def unconditional_branch(self, expr):\n        \"\"\"\n        Converts an unconditional branch into a tuple.\n\n        Parameters:\n            expr (str): The expression for the unconditional branch.\n\n        Returns:\n            (tuple): A tuple representing the unconditional branch.\n        \"\"\"\n        self.logger.debug(f\"Processing unconditional branch: expr={expr}\")\n        count_str = \"+\".join(str(item) for item in self.count_result)\n        self.count_result.clear()\n        result = (\"unconditional_branch\", expr, count_str)\n        self.logger.debug(f\"Returning unconditional branch result: {result}\")\n        return result\n\n    @v_args(inline=True)\n    def rhs_expr(self, *args) -&gt; list:\n        \"\"\"\n        Processes the right-hand side expressions, filtering out semicolons and empty items.\n\n        Parameters:\n            *args: Variadic arguments representing the expressions.\n\n        Returns:\n            (list): The filtered list of right-hand side expressions.\n        \"\"\"\n        self.logger.debug(f\"Processing rhs_expr with args: {args}\")\n        filtered_rhs_expr = [\n            item\n            for item in args\n            if not isinstance(item, Token) or item.type != \"SEMICOLON\" and item\n        ]\n        self.logger.debug(f\"Filtered rhs_expr: {filtered_rhs_expr}\")\n        result = filtered_rhs_expr\n        self.logger.debug(f\"Returning rhs_expr result: {result}\")\n        return result\n\n    def extract_rhs_expr(self, parsed_tree):\n        \"\"\"\n        Extracts the rhs_expr part from the parsed tree.\n\n        Args:\n            parsed_tree (Tree): The root of the parsed syntax tree.\n\n        Returns:\n            (Tree): The subtree corresponding to rhs_expr, or None if not found.\n        \"\"\"\n        self.logger.debug(f\"Extracting rhs_expr from parsed tree.\")\n        for child in parsed_tree.children:\n            if isinstance(child, Tree) and child.data == \"rhs_expr\":\n                return child\n        return None  # Return None if rhs_expr is not found\n\n    def generate_function(self, func_id, func_unary, parsed_definition):\n        \"\"\"\n        Generates and saves the function code from the parsed definition.\n\n        Parameters:\n            func_id (int): The function ID.\n            func_unary (int): Indicates if the function is unary (1) or binary (2).\n            parsed_definition (Tree): The parsed definition tree.\n\n        Returns:\n            (tuple): A tuple containing the compute function definition and the count function definition as strings.\n        \"\"\"\n        rhs_tree = self.extract_rhs_expr(parsed_definition)\n        filtered_rhs_expr = self.transform(rhs_tree)\n\n        func_name = f\"op_{func_id}\"\n        count_func_name = f\"op_count_{func_id}\"\n        if func_unary == 1:\n            params = [\"a\"]\n        elif func_unary == 2:\n            params = [\"a\", \"b\"]\n\n        # func_head=f\"@numba.jit(nopython=True)\\n\"\n        func_def = f\"def {func_name}({', '.join(params)}):\\n\"\n        count_func_def = f\"def {count_func_name}({', '.join(params)}):\\n\"\n        indent = \"    \"\n\n        # if func_unary == 1:\n        #     nan_check = f\"{indent}if {params[0]} in special_values:\\n{indent*2}return 1\\n\"\n        # elif func_unary == 2:\n        #     nan_check = f\"{indent}if {params[0]} in special_values or {params[1]} in special_values:\\n{indent*2}return 1\\n\"\n\n        # count_func_def += nan_check\n\n        for i, branch in enumerate(filtered_rhs_expr):\n            branch_type = branch[0]\n            if branch_type == \"if_branch\":\n                _, expr, condition, count_str = branch\n\n                # condition = add_nan_check_to_conditions(condition)\n\n                #Because of the previous judgement on NaN, all are elif\n                if i == 0:\n                    func_def += f\"{indent}if {condition}:\\n\"\n                    count_func_def += f\"{indent}if {condition}:\\n\"\n                else:\n                    func_def += f\"{indent}elif {condition}:\\n\"\n                    count_func_def += f\"{indent}elif {condition}:\\n\"\n\n                if isinstance(expr, int) or expr in [\"a\", \"b\"]:\n                    func_def += f\"{indent*2}return {expr}\\n\"\n                    count_func_def += f\"{indent*2}count = 1\\n\"\n                else:\n                    func_def += f\"{indent*2}return {expr}\\n\"\n                    count_func_def += f\"{indent*2}count = {count_str}\\n\"\n\n            elif branch_type == \"else_branch\":\n                _, expr,count_str = branch\n                func_def += f\"{indent}else:\\n\"\n                count_func_def += f\"{indent}else:\\n\"\n\n                if isinstance(expr, int) or expr in [\"a\", \"b\"]:\n                    func_def += f\"{indent*2}return {expr}\\n\"\n                    count_func_def += f\"{indent*2}count = 1\\n\"\n                else:\n                    func_def += f\"{indent*2}return {expr}\\n\"\n                    count_func_def += f\"{indent*2}count = {count_str}\\n\"\n\n            elif branch_type == \"unconditional_branch\":\n                _, expr,count_str = branch\n                if isinstance(expr, int) or expr in [\"a\", \"b\"]:\n                    func_def += f\"{indent}return {expr}\\n\"\n                    count_func_def += (\n                        f\"{indent}count = 1\\n\"\n                    )\n                else:\n                    func_def += f\"{indent}return {expr}\\n\"\n                    count_func_def += f\"{indent}count = {count_str}\\n\"\n        count_func_def += f\"{indent}return count\\n\"\n        self.logger.debug(f\"Generated Compute function:\\n{func_def}\")\n        self.logger.debug(f\"Generated Count function:\\n{count_func_def}\")\n\n        return func_def, count_func_def\n</code></pre>"},{"location":"operatorplus/operator_transformer/#opulse.operatorplus.operator_transformer.OperatorTransformer.__init__","title":"<code>__init__(param_config, logger, operator_manager=None)</code>","text":"<p>Initializes the OperatorTransformer instance with given configurations.</p> <p>Parameters:</p> Name Type Description Default <code>param_config</code> <code>ParamConfig</code> <p>Configuration for parameters.</p> required <code>logger</code> <code>LogConfig</code> <p>Logger configuration for logging debug and info messages.</p> required <code>operator_manager</code> <code>OperatorManager</code> <p>Operator manager for handling operators.</p> <code>None</code> Source code in <code>opulse/operatorplus/operator_transformer.py</code> <pre><code>def __init__(\n    self,\n    param_config: ParamConfig,\n    logger: LogConfig,\n    operator_manager: \"OperatorManager\" = None,\n):\n    \"\"\"\n    Initializes the OperatorTransformer instance with given configurations.\n\n    Args:\n       param_config (ParamConfig): Configuration for parameters.\n       logger (LogConfig): Logger configuration for logging debug and info messages.\n       operator_manager (OperatorManager, optional): Operator manager for handling operators.\n    \"\"\"\n    self.param_config = param_config\n    self.logger = logger.get_logger()\n    self.operator_manager = operator_manager\n    self.count_result = []\n</code></pre>"},{"location":"operatorplus/operator_transformer/#opulse.operatorplus.operator_transformer.OperatorTransformer.and_condition","title":"<code>and_condition(left, right)</code>","text":"<p>Converts an 'and' condition into a string representation.</p> <p>Parameters:</p> Name Type Description Default <code>left</code> <code>str</code> <p>The left operand.</p> required <code>right</code> <code>str</code> <p>The right operand.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The 'and' condition as a string.</p> Source code in <code>opulse/operatorplus/operator_transformer.py</code> <pre><code>@v_args(inline=True)\ndef and_condition(self, left, right):\n    \"\"\"\n    Converts an 'and' condition into a string representation.\n\n    Parameters:\n        left (str): The left operand.\n        right (str): The right operand.\n\n    Returns:\n        (str): The 'and' condition as a string.\n    \"\"\"\n    self.logger.debug(f\"Processing 'and' condition: left={left}, right={right}\")\n    result = f\"{left} and {right}\"\n    self.logger.debug(f\"Returning 'and' condition result: {result}\")\n    return result\n</code></pre>"},{"location":"operatorplus/operator_transformer/#opulse.operatorplus.operator_transformer.OperatorTransformer.binary_operation","title":"<code>binary_operation(left, operator, right)</code>","text":"<p>Converts a binary operation into a function call.</p> <p>Parameters:</p> Name Type Description Default <code>left</code> <code>str</code> <p>The left operand.</p> required <code>operator</code> <code>str</code> <p>The operator symbol.</p> required <code>right</code> <code>str</code> <p>The right operand.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The function call string using the operator's function ID.</p> Source code in <code>opulse/operatorplus/operator_transformer.py</code> <pre><code>@v_args(inline=True)\ndef binary_operation(self, left, operator, right):\n    \"\"\"\n    Converts a binary operation into a function call.\n\n    Parameters:\n        left (str): The left operand.\n        operator (str): The operator symbol.\n        right (str): The right operand.\n\n    Returns:\n        (str): The function call string using the operator's function ID.\n    \"\"\"\n    self.logger.debug(\n        f\"Binary operation: left={left}, operator={operator}, right={right}\"\n    )\n    func_id, is_temporary = self.operator_manager.get_operator_function_id(\n        operator, is_unary=False, unary_position=\"null\"\n    )\n    self.logger.debug(f\"Function ID: {func_id}, Is temporary: {is_temporary}\")\n    if func_id and not is_temporary:\n        result = f\"op_{func_id}({left},{right})\"\n        count_result = f\"op_count_{func_id}({left},{right})\"\n        self.count_result.append(count_result)\n    else:\n        raise ValueError(\n            f\"Operator '{operator}' is not supported or lacks a function ID.\"\n        )\n    self.logger.debug(f\"Returning binary operation result: {result}\")\n    self.logger.debug(f\"self.count_result: {self.count_result}\")\n    return result\n</code></pre>"},{"location":"operatorplus/operator_transformer/#opulse.operatorplus.operator_transformer.OperatorTransformer.comparison","title":"<code>comparison(left, condition_operator, right)</code>","text":"<p>Converts a comparison expression into a string representation.</p> <p>Parameters:</p> Name Type Description Default <code>left</code> <code>str</code> <p>The left operand.</p> required <code>condition_operator</code> <code>str</code> <p>The comparison operator.</p> required <code>right</code> <code>str</code> <p>The right operand.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The comparison expression as a string.</p> Source code in <code>opulse/operatorplus/operator_transformer.py</code> <pre><code>@v_args(inline=True)\ndef comparison(self, left, condition_operator, right):\n    \"\"\"\n    Converts a comparison expression into a string representation.\n\n    Parameters:\n        left (str): The left operand.\n        condition_operator (str): The comparison operator.\n        right (str): The right operand.\n\n    Returns:\n        (str): The comparison expression as a string.\n    \"\"\"\n    self.logger.debug(\n        f\"Processing comparison: left={left}, operator={condition_operator}, right={right}\"\n    )\n    result = f\"{left} {condition_operator} {right}\"\n    self.logger.debug(f\"Returning comparison result: {result}\")\n    return result\n</code></pre>"},{"location":"operatorplus/operator_transformer/#opulse.operatorplus.operator_transformer.OperatorTransformer.else_branch","title":"<code>else_branch(expr)</code>","text":"<p>Converts an 'else' branch into a tuple.</p> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>str</code> <p>The expression for the else branch.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple representing the else branch.</p> Source code in <code>opulse/operatorplus/operator_transformer.py</code> <pre><code>@v_args(inline=True)\ndef else_branch(self, expr):\n    \"\"\"\n    Converts an 'else' branch into a tuple.\n\n    Parameters:\n        expr (str): The expression for the else branch.\n\n    Returns:\n        (tuple): A tuple representing the else branch.\n    \"\"\"\n    self.logger.debug(f\"Processing 'else' branch: expr={expr}\")\n    count_str = \"+\".join(str(item) for item in self.count_result)\n    self.count_result.clear()\n    result = (\"else_branch\", expr, count_str)\n    self.logger.debug(f\"Returning 'else' branch result: {result}\")\n    return result\n</code></pre>"},{"location":"operatorplus/operator_transformer/#opulse.operatorplus.operator_transformer.OperatorTransformer.extract_rhs_expr","title":"<code>extract_rhs_expr(parsed_tree)</code>","text":"<p>Extracts the rhs_expr part from the parsed tree.</p> <p>Parameters:</p> Name Type Description Default <code>parsed_tree</code> <code>Tree</code> <p>The root of the parsed syntax tree.</p> required <p>Returns:</p> Type Description <code>Tree</code> <p>The subtree corresponding to rhs_expr, or None if not found.</p> Source code in <code>opulse/operatorplus/operator_transformer.py</code> <pre><code>def extract_rhs_expr(self, parsed_tree):\n    \"\"\"\n    Extracts the rhs_expr part from the parsed tree.\n\n    Args:\n        parsed_tree (Tree): The root of the parsed syntax tree.\n\n    Returns:\n        (Tree): The subtree corresponding to rhs_expr, or None if not found.\n    \"\"\"\n    self.logger.debug(f\"Extracting rhs_expr from parsed tree.\")\n    for child in parsed_tree.children:\n        if isinstance(child, Tree) and child.data == \"rhs_expr\":\n            return child\n    return None  # Return None if rhs_expr is not found\n</code></pre>"},{"location":"operatorplus/operator_transformer/#opulse.operatorplus.operator_transformer.OperatorTransformer.generate_function","title":"<code>generate_function(func_id, func_unary, parsed_definition)</code>","text":"<p>Generates and saves the function code from the parsed definition.</p> <p>Parameters:</p> Name Type Description Default <code>func_id</code> <code>int</code> <p>The function ID.</p> required <code>func_unary</code> <code>int</code> <p>Indicates if the function is unary (1) or binary (2).</p> required <code>parsed_definition</code> <code>Tree</code> <p>The parsed definition tree.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing the compute function definition and the count function definition as strings.</p> Source code in <code>opulse/operatorplus/operator_transformer.py</code> <pre><code>def generate_function(self, func_id, func_unary, parsed_definition):\n    \"\"\"\n    Generates and saves the function code from the parsed definition.\n\n    Parameters:\n        func_id (int): The function ID.\n        func_unary (int): Indicates if the function is unary (1) or binary (2).\n        parsed_definition (Tree): The parsed definition tree.\n\n    Returns:\n        (tuple): A tuple containing the compute function definition and the count function definition as strings.\n    \"\"\"\n    rhs_tree = self.extract_rhs_expr(parsed_definition)\n    filtered_rhs_expr = self.transform(rhs_tree)\n\n    func_name = f\"op_{func_id}\"\n    count_func_name = f\"op_count_{func_id}\"\n    if func_unary == 1:\n        params = [\"a\"]\n    elif func_unary == 2:\n        params = [\"a\", \"b\"]\n\n    # func_head=f\"@numba.jit(nopython=True)\\n\"\n    func_def = f\"def {func_name}({', '.join(params)}):\\n\"\n    count_func_def = f\"def {count_func_name}({', '.join(params)}):\\n\"\n    indent = \"    \"\n\n    # if func_unary == 1:\n    #     nan_check = f\"{indent}if {params[0]} in special_values:\\n{indent*2}return 1\\n\"\n    # elif func_unary == 2:\n    #     nan_check = f\"{indent}if {params[0]} in special_values or {params[1]} in special_values:\\n{indent*2}return 1\\n\"\n\n    # count_func_def += nan_check\n\n    for i, branch in enumerate(filtered_rhs_expr):\n        branch_type = branch[0]\n        if branch_type == \"if_branch\":\n            _, expr, condition, count_str = branch\n\n            # condition = add_nan_check_to_conditions(condition)\n\n            #Because of the previous judgement on NaN, all are elif\n            if i == 0:\n                func_def += f\"{indent}if {condition}:\\n\"\n                count_func_def += f\"{indent}if {condition}:\\n\"\n            else:\n                func_def += f\"{indent}elif {condition}:\\n\"\n                count_func_def += f\"{indent}elif {condition}:\\n\"\n\n            if isinstance(expr, int) or expr in [\"a\", \"b\"]:\n                func_def += f\"{indent*2}return {expr}\\n\"\n                count_func_def += f\"{indent*2}count = 1\\n\"\n            else:\n                func_def += f\"{indent*2}return {expr}\\n\"\n                count_func_def += f\"{indent*2}count = {count_str}\\n\"\n\n        elif branch_type == \"else_branch\":\n            _, expr,count_str = branch\n            func_def += f\"{indent}else:\\n\"\n            count_func_def += f\"{indent}else:\\n\"\n\n            if isinstance(expr, int) or expr in [\"a\", \"b\"]:\n                func_def += f\"{indent*2}return {expr}\\n\"\n                count_func_def += f\"{indent*2}count = 1\\n\"\n            else:\n                func_def += f\"{indent*2}return {expr}\\n\"\n                count_func_def += f\"{indent*2}count = {count_str}\\n\"\n\n        elif branch_type == \"unconditional_branch\":\n            _, expr,count_str = branch\n            if isinstance(expr, int) or expr in [\"a\", \"b\"]:\n                func_def += f\"{indent}return {expr}\\n\"\n                count_func_def += (\n                    f\"{indent}count = 1\\n\"\n                )\n            else:\n                func_def += f\"{indent}return {expr}\\n\"\n                count_func_def += f\"{indent}count = {count_str}\\n\"\n    count_func_def += f\"{indent}return count\\n\"\n    self.logger.debug(f\"Generated Compute function:\\n{func_def}\")\n    self.logger.debug(f\"Generated Count function:\\n{count_func_def}\")\n\n    return func_def, count_func_def\n</code></pre>"},{"location":"operatorplus/operator_transformer/#opulse.operatorplus.operator_transformer.OperatorTransformer.grouped_condition","title":"<code>grouped_condition(condition)</code>","text":"<p>Wraps a condition in parentheses.</p> <p>Parameters:</p> Name Type Description Default <code>condition</code> <code>str</code> <p>The condition to wrap.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The condition wrapped in parentheses.</p> Source code in <code>opulse/operatorplus/operator_transformer.py</code> <pre><code>@v_args(inline=True)\ndef grouped_condition(self, condition):\n    \"\"\"\n    Wraps a condition in parentheses.\n\n    Parameters:\n        condition (str): The condition to wrap.\n\n    Returns:\n        (str): The condition wrapped in parentheses.\n    \"\"\"\n    self.logger.debug(f\"Processing grouped condition: {condition}\")\n    result = f\"({condition})\"\n    self.logger.debug(f\"Returning grouped condition result: {result}\")\n    return result\n</code></pre>"},{"location":"operatorplus/operator_transformer/#opulse.operatorplus.operator_transformer.OperatorTransformer.if_branch","title":"<code>if_branch(expr, condition)</code>","text":"<p>Converts an 'if' branch into a tuple.</p> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>str</code> <p>The expression for the if branch.</p> required <code>condition</code> <code>str</code> <p>The condition for the if branch.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple representing the if branch.</p> Source code in <code>opulse/operatorplus/operator_transformer.py</code> <pre><code>@v_args(inline=True)\ndef if_branch(self, expr, condition):\n    \"\"\"\n    Converts an 'if' branch into a tuple.\n\n    Parameters:\n        expr (str): The expression for the if branch.\n        condition (str): The condition for the if branch.\n\n    Returns:\n        (tuple): A tuple representing the if branch.\n    \"\"\"\n    self.logger.debug(f\"Processing 'if' branch: expr={expr}, condition={condition}\")\n    count_str = \"+\".join(str(item) for item in self.count_result)\n    self.count_result.clear()\n    result = (\"if_branch\", expr, condition, count_str)\n    self.logger.debug(f\"Returning 'if' branch result: {result}\")\n    return result\n</code></pre>"},{"location":"operatorplus/operator_transformer/#opulse.operatorplus.operator_transformer.OperatorTransformer.int_conversion","title":"<code>int_conversion(token)</code>","text":"<p>Converts an INT token to a string.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Token</code> <p>The INT token to convert.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The string representation of the token's value.</p> Source code in <code>opulse/operatorplus/operator_transformer.py</code> <pre><code>@v_args(inline=True)\ndef int_conversion(self, token):\n    \"\"\"\n    Converts an INT token to a string.\n\n    Parameters:\n        token (Token): The INT token to convert.\n\n    Returns:\n        (str): The string representation of the token's value.\n    \"\"\"\n    self.logger.debug(f\"Converting INT token: {token}\")\n    result = str(token.value)\n    self.logger.debug(f\"Returning INT conversion result: {result}\")\n    return result\n</code></pre>"},{"location":"operatorplus/operator_transformer/#opulse.operatorplus.operator_transformer.OperatorTransformer.no_solution","title":"<code>no_solution(token)</code>","text":"<p>Handles the NO_SOLUTION rule, returns the string 'NaN'.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Token</code> <p>The token representing NO_SOLUTION.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The string '\"NaN\"'.</p> Source code in <code>opulse/operatorplus/operator_transformer.py</code> <pre><code>@v_args(inline=True)\ndef no_solution(self, token):\n    \"\"\"\n    Handles the NO_SOLUTION rule, returns the string 'NaN'.\n\n    Parameters:\n        token (Token): The token representing NO_SOLUTION.\n\n    Returns:\n        (str): The string '\"NaN\"'.\n    \"\"\"\n    self.logger.debug(f\"Processing NO_SOLUTION: {token}\")\n    result = float('nan')  # Ensure to return 'NaN' as a quoted string.\n    self.logger.debug(f\"Returning NO_SOLUTION result: {result}\")\n    return result\n</code></pre>"},{"location":"operatorplus/operator_transformer/#opulse.operatorplus.operator_transformer.OperatorTransformer.not_condition","title":"<code>not_condition(condition)</code>","text":"<p>Wraps the condition with a 'not' operator.</p> <p>Parameters:</p> Name Type Description Default <code>condition</code> <code>str</code> <p>The condition to negate.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The negated condition as a string.</p> Source code in <code>opulse/operatorplus/operator_transformer.py</code> <pre><code>@v_args(inline=True)\ndef not_condition(self, condition):\n    \"\"\"\n    Wraps the condition with a 'not' operator.\n\n    Parameters:\n        condition (str): The condition to negate.\n\n    Returns:\n        (str): The negated condition as a string.\n    \"\"\"\n    self.logger.debug(f\"Processing 'not' condition: {condition}\")\n    result = f\"not ({condition})\"\n    self.logger.debug(f\"Returning 'not' condition result: {result}\")\n    return result\n</code></pre>"},{"location":"operatorplus/operator_transformer/#opulse.operatorplus.operator_transformer.OperatorTransformer.or_condition","title":"<code>or_condition(left, right)</code>","text":"<p>Converts an 'or' condition into a string representation.</p> <p>Parameters:</p> Name Type Description Default <code>left</code> <code>str</code> <p>The left operand.</p> required <code>right</code> <code>str</code> <p>The right operand.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The 'or' condition as a string.</p> Source code in <code>opulse/operatorplus/operator_transformer.py</code> <pre><code>@v_args(inline=True)\ndef or_condition(self, left, right):\n    \"\"\"\n    Converts an 'or' condition into a string representation.\n\n    Parameters:\n        left (str): The left operand.\n        right (str): The right operand.\n\n    Returns:\n        (str): The 'or' condition as a string.\n    \"\"\"\n    self.logger.debug(f\"Processing 'or' condition: left={left}, right={right}\")\n    result = f\"{left} or {right}\"\n    self.logger.debug(f\"Returning 'or' condition result: {result}\")\n    return result\n</code></pre>"},{"location":"operatorplus/operator_transformer/#opulse.operatorplus.operator_transformer.OperatorTransformer.rhs_expr","title":"<code>rhs_expr(*args)</code>","text":"<p>Processes the right-hand side expressions, filtering out semicolons and empty items.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>Variadic arguments representing the expressions.</p> <code>()</code> <p>Returns:</p> Type Description <code>list</code> <p>The filtered list of right-hand side expressions.</p> Source code in <code>opulse/operatorplus/operator_transformer.py</code> <pre><code>@v_args(inline=True)\ndef rhs_expr(self, *args) -&gt; list:\n    \"\"\"\n    Processes the right-hand side expressions, filtering out semicolons and empty items.\n\n    Parameters:\n        *args: Variadic arguments representing the expressions.\n\n    Returns:\n        (list): The filtered list of right-hand side expressions.\n    \"\"\"\n    self.logger.debug(f\"Processing rhs_expr with args: {args}\")\n    filtered_rhs_expr = [\n        item\n        for item in args\n        if not isinstance(item, Token) or item.type != \"SEMICOLON\" and item\n    ]\n    self.logger.debug(f\"Filtered rhs_expr: {filtered_rhs_expr}\")\n    result = filtered_rhs_expr\n    self.logger.debug(f\"Returning rhs_expr result: {result}\")\n    return result\n</code></pre>"},{"location":"operatorplus/operator_transformer/#opulse.operatorplus.operator_transformer.OperatorTransformer.unary_operation_postfix","title":"<code>unary_operation_postfix(operand, operator)</code>","text":"<p>Converts a postfix unary operation into a function call.</p> <p>Parameters:</p> Name Type Description Default <code>operand</code> <code>str</code> <p>The operand.</p> required <code>operator</code> <code>str</code> <p>The operator symbol.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The function call string using the operator's function ID.</p> Source code in <code>opulse/operatorplus/operator_transformer.py</code> <pre><code>@v_args(inline=True)\ndef unary_operation_postfix(self, operand, operator):\n    \"\"\"\n    Converts a postfix unary operation into a function call.\n\n    Parameters:\n        operand (str): The operand.\n        operator (str): The operator symbol.\n\n    Returns:\n        (str): The function call string using the operator's function ID.\n    \"\"\"\n    self.logger.debug(\n        f\"Postfix unary operation: operand={operand}, operator={operator}\"\n    )\n    func_id, is_temporary = self.operator_manager.get_operator_function_id(\n        operator, is_unary=True, unary_position=\"postfix\"\n    )\n    self.logger.debug(f\"Function ID: {func_id}, Is temporary: {is_temporary}\")\n    if func_id and not is_temporary:\n        result = f\"op_{func_id}({operand})\"\n        count_result = f\"op_count_{func_id}({operand})\"\n        self.count_result.append(count_result)\n    else:\n        raise ValueError(\n            f\"Operator '{operator}' is not supported or lacks a function ID.\"\n        )\n    self.logger.debug(f\"Returning postfix unary operation result: {result}\")\n    self.logger.debug(f\"self.count_result: {self.count_result}\")\n    return result\n</code></pre>"},{"location":"operatorplus/operator_transformer/#opulse.operatorplus.operator_transformer.OperatorTransformer.unary_operation_prefix","title":"<code>unary_operation_prefix(operator, operand)</code>","text":"<p>Converts a prefix unary operation into a function call.</p> <p>Parameters:</p> Name Type Description Default <code>operator</code> <code>str</code> <p>The operator symbol.</p> required <code>operand</code> <code>str</code> <p>The operand.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The function call string using the operator's function ID.</p> Source code in <code>opulse/operatorplus/operator_transformer.py</code> <pre><code>@v_args(inline=True)\ndef unary_operation_prefix(self, operator, operand):\n    \"\"\"\n    Converts a prefix unary operation into a function call.\n\n    Parameters:\n        operator (str): The operator symbol.\n        operand (str): The operand.\n\n    Returns:\n        (str): The function call string using the operator's function ID.\n    \"\"\"\n    self.logger.debug(\n        f\"Prefix unary operation: operator={operator}, operand={operand}\"\n    )\n    func_id, is_temporary = self.operator_manager.get_operator_function_id(\n        operator, is_unary=True, unary_position=\"prefix\"\n    )\n    self.logger.debug(f\"Function ID: {func_id}, Is temporary: {is_temporary}\")\n    if func_id and not is_temporary:\n        result = f\"op_{func_id}({operand})\"\n        count_result = f\"op_count_{func_id}({operand})\"\n        self.count_result.append(count_result)\n    else:\n        raise ValueError(\n            f\"Operator '{operator}' is not supported or lacks a function ID.\"\n        )\n    self.logger.debug(f\"Returning prefix unary operation result: {result}\")\n    self.logger.debug(f\"self.count_result: {self.count_result}\")\n    return result\n</code></pre>"},{"location":"operatorplus/operator_transformer/#opulse.operatorplus.operator_transformer.OperatorTransformer.unconditional_branch","title":"<code>unconditional_branch(expr)</code>","text":"<p>Converts an unconditional branch into a tuple.</p> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>str</code> <p>The expression for the unconditional branch.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple representing the unconditional branch.</p> Source code in <code>opulse/operatorplus/operator_transformer.py</code> <pre><code>@v_args(inline=True)\ndef unconditional_branch(self, expr):\n    \"\"\"\n    Converts an unconditional branch into a tuple.\n\n    Parameters:\n        expr (str): The expression for the unconditional branch.\n\n    Returns:\n        (tuple): A tuple representing the unconditional branch.\n    \"\"\"\n    self.logger.debug(f\"Processing unconditional branch: expr={expr}\")\n    count_str = \"+\".join(str(item) for item in self.count_result)\n    self.count_result.clear()\n    result = (\"unconditional_branch\", expr, count_str)\n    self.logger.debug(f\"Returning unconditional branch result: {result}\")\n    return result\n</code></pre>"},{"location":"operatorplus/operator_transformer/#opulse.operatorplus.operator_transformer.OperatorTransformer.variable_conversion","title":"<code>variable_conversion(token)</code>","text":"<p>Converts a VARIABLE token to its string value.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Token</code> <p>The VARIABLE token to convert.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The string representation of the token's value.</p> Source code in <code>opulse/operatorplus/operator_transformer.py</code> <pre><code>@v_args(inline=True)\ndef variable_conversion(self, token):\n    \"\"\"\n    Converts a VARIABLE token to its string value.\n\n    Parameters:\n        token (Token): The VARIABLE token to convert.\n\n    Returns:\n        (str): The string representation of the token's value.\n    \"\"\"\n    self.logger.debug(f\"Converting VARIABLE token: {token}\")\n    result = token.value  # Assumes it's a simple variable name like 'a' or 'b'.\n    self.logger.debug(f\"Returning VARIABLE conversion result: {result}\")\n    return result\n</code></pre>"}]}